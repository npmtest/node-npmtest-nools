{"/home/travis/build/npmtest/node-npmtest-nools/test.js":"/* istanbul instrument in package npmtest_nools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nools/lib.npmtest_nools.js":"/* istanbul instrument in package npmtest_nools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nools = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nools = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nools/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nools && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nools\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nools.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nools.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nools.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nools.__dirname + '/lib.npmtest_nools.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/index.js":"module.exports = exports = require(\"./lib\");","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/index.js":"/**\n *\n * @projectName nools\n * @github https://github.com/C2FO/nools\n * @includeDoc [Examples] ../docs-md/examples.md\n * @includeDoc [Change Log] ../history.md\n * @header [../readme.md]\n */\n\n\"use strict\";\nvar extd = require(\"./extended\"),\n    fs = require(\"fs\"),\n    path = require(\"path\"),\n    compile = require(\"./compile\"),\n    FlowContainer = require(\"./flowContainer\");\n\nfunction isNoolsFile(file) {\n    return (/\\.nools$/).test(file);\n}\n\nfunction parse(source) {\n    var ret;\n    if (isNoolsFile(source)) {\n        ret = compile.parse(fs.readFileSync(source, \"utf8\"), source);\n    } else {\n        ret = compile.parse(source);\n    }\n    return ret;\n}\n\nexports.Flow = FlowContainer;\n\nexports.getFlow = FlowContainer.getFlow;\nexports.hasFlow = FlowContainer.hasFlow;\n\nexports.deleteFlow = function (name) {\n    FlowContainer.deleteFlow(name);\n    return this;\n};\n\nexports.deleteFlows = function () {\n    FlowContainer.deleteFlows();\n    return this;\n};\n\nexports.flow = FlowContainer.create;\n\nexports.compile = function (file, options, cb) {\n    if (extd.isFunction(options)) {\n        cb = options;\n        options = {};\n    } else {\n        options = options || {};\n    }\n    if (extd.isString(file)) {\n        options.name = options.name || (isNoolsFile(file) ? path.basename(file, path.extname(file)) : null);\n        file = parse(file);\n    }\n    if (!options.name) {\n        throw new Error(\"Name required when compiling nools source\");\n    }\n    return  compile.compile(file, options, cb, FlowContainer);\n};\n\nexports.transpile = function (file, options) {\n    options = options || {};\n    if (extd.isString(file)) {\n        options.name = options.name || (isNoolsFile(file) ? path.basename(file, path.extname(file)) : null);\n        file = parse(file);\n    }\n    return compile.transpile(file, options);\n};\n\nexports.parse = parse;","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/extended.js":"var arr = require(\"array-extended\"),\n    unique = arr.unique,\n    indexOf = arr.indexOf,\n    map = arr.map,\n    pSlice = Array.prototype.slice,\n    pSplice = Array.prototype.splice;\n\nfunction plucked(prop) {\n    var exec = prop.match(/(\\w+)\\(\\)$/);\n    if (exec) {\n        prop = exec[1];\n        return function (item) {\n            return item[prop]();\n        };\n    } else {\n        return function (item) {\n            return item[prop];\n        };\n    }\n}\n\nfunction plucker(prop) {\n    prop = prop.split(\".\");\n    if (prop.length === 1) {\n        return plucked(prop[0]);\n    } else {\n        var pluckers = map(prop, function (prop) {\n            return plucked(prop);\n        });\n        var l = pluckers.length;\n        return function (item) {\n            var i = -1, res = item;\n            while (++i < l) {\n                res = pluckers[i](res);\n            }\n            return res;\n        };\n    }\n}\n\nfunction intersection(a, b) {\n    a = pSlice.call(a);\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) === -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction inPlaceIntersection(a, b) {\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) === -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction inPlaceDifference(a, b) {\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) !== -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction diffArr(arr1, arr2) {\n    var ret = [], i = -1, j, l2 = arr2.length, l1 = arr1.length, a, found;\n    if (l2 > l1) {\n        ret = arr1.slice();\n        while (++i < l2) {\n            a = arr2[i];\n            j = -1;\n            l1 = ret.length;\n            while (++j < l1) {\n                if (ret[j] === a) {\n                    ret.splice(j, 1);\n                    break;\n                }\n            }\n        }\n    } else {\n        while (++i < l1) {\n            a = arr1[i];\n            j = -1;\n            found = false;\n            while (++j < l2) {\n                if (arr2[j] === a) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ret.push(a);\n            }\n        }\n    }\n    return ret;\n}\n\nfunction diffHash(h1, h2) {\n    var ret = {};\n    for (var i in h1) {\n        if (!hasOwnProperty.call(h2, i)) {\n            ret[i] = h1[i];\n        }\n    }\n    return ret;\n}\n\n\nfunction union(arr1, arr2) {\n    return unique(arr1.concat(arr2));\n}\n\nmodule.exports = require(\"extended\")()\n    .register(require(\"date-extended\"))\n    .register(arr)\n    .register(require(\"object-extended\"))\n    .register(require(\"string-extended\"))\n    .register(require(\"promise-extended\"))\n    .register(require(\"function-extended\"))\n    .register(require(\"is-extended\"))\n    .register(\"intersection\", intersection)\n    .register(\"inPlaceIntersection\", inPlaceIntersection)\n    .register(\"inPlaceDifference\", inPlaceDifference)\n    .register(\"diffArr\", diffArr)\n    .register(\"diffHash\", diffHash)\n    .register(\"unionArr\", union)\n    .register(\"plucker\", plucker)\n    .register(\"HashTable\", require(\"ht\"))\n    .register(\"declare\", require(\"declare.js\"))\n    .register(require(\"leafy\"))\n    .register(\"LinkedList\", require(\"./linkedList\"));\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/linkedList.js":"var declare = require(\"declare.js\");\ndeclare({\n\n    instance: {\n        constructor: function () {\n            this.head = null;\n            this.tail = null;\n            this.length = null;\n        },\n\n        push: function (data) {\n            var tail = this.tail, head = this.head, node = {data: data, prev: tail, next: null};\n            if (tail) {\n                this.tail.next = node;\n            }\n            this.tail = node;\n            if (!head) {\n                this.head = node;\n            }\n            this.length++;\n            return node;\n        },\n\n        remove: function (node) {\n            if (node.prev) {\n                node.prev.next = node.next;\n            } else {\n                this.head = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            } else {\n                this.tail = node.prev;\n            }\n            //node.data = node.prev = node.next = null;\n            this.length--;\n        },\n\n        forEach: function (cb) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                cb(head.data);\n            }\n        },\n\n        toArray: function () {\n            var head = {next: this.head}, ret = [];\n            while ((head = head.next)) {\n                ret.push(head);\n            }\n            return ret;\n        },\n\n        removeByData: function (data) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                if (head.data === data) {\n                    this.remove(head);\n                    break;\n                }\n            }\n        },\n\n        getByData: function (data) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                if (head.data === data) {\n                    return head;\n                }\n            }\n        },\n\n        clear: function () {\n            this.head = this.tail = null;\n            this.length = 0;\n        }\n\n    }\n\n}).as(module);\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/compile/index.js":"/*jshint evil:true*/\n\"use strict\";\nvar extd = require(\"../extended\"),\n    parser = require(\"../parser\"),\n    constraintMatcher = require(\"../constraintMatcher.js\"),\n    indexOf = extd.indexOf,\n    forEach = extd.forEach,\n    removeDuplicates = extd.removeDuplicates,\n    map = extd.map,\n    obj = extd.hash,\n    keys = obj.keys,\n    merge = extd.merge,\n    rules = require(\"../rule\"),\n    common = require(\"./common\"),\n    modifiers = common.modifiers,\n    createDefined = common.createDefined,\n    createFunction = common.createFunction;\n\n\n/**\n * @private\n * Parses an action from a rule definition\n * @param {String} action the body of the action to execute\n * @param {Array} identifiers array of identifiers collected\n * @param {Object} defined an object of defined\n * @param scope\n * @return {Object}\n */\nvar parseAction = function (action, identifiers, defined, scope) {\n    var declares = [];\n    forEach(identifiers, function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= facts.\" + i + \";\");\n        }\n    });\n    extd(defined).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    extd(scope).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    extd(modifiers).forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"if(!\" + i + \"){ var \" + i + \"= flow.\" + i + \";}\");\n        }\n    });\n    var params = [\"facts\", 'flow'];\n    if (/next\\(.*\\)/.test(action)) {\n        params.push(\"next\");\n    }\n    action = declares.join(\"\") + action;\n    try {\n        return new Function(\"defined, scope\", \"return \" + new Function(params.join(\",\"), action).toString())(defined, scope);\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + action + \"\\n\" + e.message);\n    }\n};\n\nvar createRuleFromObject = (function () {\n    var __resolveRule = function (rule, identifiers, conditions, defined, name) {\n        var condition = [], definedClass = rule[0], alias = rule[1], constraint = rule[2], refs = rule[3];\n        if (extd.isHash(constraint)) {\n            refs = constraint;\n            constraint = null;\n        }\n        if (definedClass && !!(definedClass = defined[definedClass])) {\n            condition.push(definedClass);\n        } else {\n            throw new Error(\"Invalid class \" + rule[0] + \" for rule \" + name);\n        }\n        condition.push(alias, constraint, refs);\n        conditions.push(condition);\n        identifiers.push(alias);\n        if (constraint) {\n            forEach(constraintMatcher.getIdentifiers(parser.parseConstraint(constraint)), function (i) {\n                identifiers.push(i);\n            });\n        }\n        if (extd.isObject(refs)) {\n            for (var j in refs) {\n                var ident = refs[j];\n                if (indexOf(identifiers, ident) === -1) {\n                    identifiers.push(ident);\n                }\n            }\n        }\n    };\n\n    function parseRule(rule, conditions, identifiers, defined, name) {\n        if (rule.length) {\n            var r0 = rule[0];\n            if (r0 === \"not\" || r0 === \"exists\") {\n                var temp = [];\n                rule.shift();\n                __resolveRule(rule, identifiers, temp, defined, name);\n                var cond = temp[0];\n                cond.unshift(r0);\n                conditions.push(cond);\n            } else if (r0 === \"or\") {\n                var conds = [r0];\n                rule.shift();\n                forEach(rule, function (cond) {\n                    parseRule(cond, conds, identifiers, defined, name);\n                });\n                conditions.push(conds);\n            } else {\n                __resolveRule(rule, identifiers, conditions, defined, name);\n                identifiers = removeDuplicates(identifiers);\n            }\n        }\n\n    }\n\n    return function (obj, defined, scope) {\n        var name = obj.name;\n        if (extd.isEmpty(obj)) {\n            throw new Error(\"Rule is empty\");\n        }\n        var options = obj.options || {};\n        options.scope = scope;\n        var constraints = obj.constraints || [], l = constraints.length;\n        if (!l) {\n            constraints = [\"true\"];\n        }\n        var action = obj.action;\n        if (extd.isUndefined(action)) {\n            throw new Error(\"No action was defined for rule \" + name);\n        }\n        var conditions = [], identifiers = [];\n        forEach(constraints, function (rule) {\n            parseRule(rule, conditions, identifiers, defined, name);\n        });\n        return rules.createRule(name, options, conditions, parseAction(action, identifiers, defined, scope));\n    };\n})();\n\nexports.parse = function (src, file) {\n    //parse flow from file\n    return parser.parseRuleSet(src, file);\n\n};\nexports.compile = function (flowObj, options, cb, Container) {\n    if (extd.isFunction(options)) {\n        cb = options;\n        options = {};\n    } else {\n        options = options || {};\n    }\n    var name = flowObj.name || options.name;\n    //if !name throw an error\n    if (!name) {\n        throw new Error(\"Name must be present in JSON or options\");\n    }\n    var flow = new Container(name);\n    var defined = merge({Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, options.define || {});\n    if (typeof Buffer !== \"undefined\") {\n        defined.Buffer = Buffer;\n    }\n    var scope = merge({console: console}, options.scope);\n    //add the anything added to the scope as a property\n    forEach(flowObj.scope, function (s) {\n        scope[s.name] = true;\n    });\n    //add any defined classes in the parsed flowObj to defined\n    forEach(flowObj.define, function (d) {\n        defined[d.name] = createDefined(d, defined, scope);\n    });\n\n    //expose any defined classes to the flow.\n    extd(defined).forEach(function (cls, name) {\n        flow.addDefined(name, cls);\n    });\n\n    var scopeNames = extd(flowObj.scope).pluck(\"name\").union(extd(scope).keys().value()).value();\n    var definedNames = map(keys(defined), function (s) {\n        return s;\n    });\n    forEach(flowObj.scope, function (s) {\n        scope[s.name] = createFunction(s.body, defined, scope, scopeNames, definedNames);\n    });\n    var rules = flowObj.rules;\n    if (rules.length) {\n        forEach(rules, function (rule) {\n            flow.__rules = flow.__rules.concat(createRuleFromObject(rule, defined, scope));\n        });\n    }\n    if (cb) {\n        cb.call(flow, flow);\n    }\n    return flow;\n};\n\nexports.transpile = require(\"./transpile\").transpile;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/index.js":"(function () {\n    \"use strict\";\n    var constraintParser = require(\"./constraint/parser\"),\n        noolParser = require(\"./nools/nool.parser\");\n\n    exports.parseConstraint = function (expression) {\n        try {\n            return constraintParser.parse(expression);\n        } catch (e) {\n            throw new Error(\"Invalid expression '\" + expression + \"'\");\n        }\n    };\n\n    exports.parseRuleSet = function (source, file) {\n        return noolParser.parse(source, file);\n    };\n})();","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/constraint/parser.js":"/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,29],$V1=[1,30],$V2=[1,26],$V3=[1,24],$V4=[1,16],$V5=[1,18],$V6=[1,19],$V7=[1,20],$V8=[1,21],$V9=[1,22],$Va=[5,38,49],$Vb=[1,33],$Vc=[5,36,38,49],$Vd=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Ve=[2,2],$Vf=[5,24,25,26,27,28,29,36,38,49],$Vg=[1,42],$Vh=[1,43],$Vi=[1,44],$Vj=[1,45],$Vk=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,31,33,36,38,40,46,49],$Vl=[1,46],$Vm=[1,47],$Vn=[1,48],$Vo=[5,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vp=[1,50],$Vq=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,31,33,36,38,40,43,44,46,48,49],$Vr=[5,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vs=[1,55],$Vt=[1,54],$Vu=[5,8,15,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vv=[1,56],$Vw=[1,57],$Vx=[1,58],$Vy=[1,87],$Vz=[40,46,49];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"EXPRESSION\":4,\"EOF\":5,\"UNARY_EXPRESSION\":6,\"LITERAL_EXPRESSION\":7,\"-\":8,\"!\":9,\"MULTIPLICATIVE_EXPRESSION\":10,\"*\":11,\"/\":12,\"%\":13,\"ADDITIVE_EXPRESSION\":14,\"+\":15,\"EXPONENT_EXPRESSION\":16,\"^\":17,\"RELATIONAL_EXPRESSION\":18,\"<\":19,\">\":20,\"<=\":21,\">=\":22,\"EQUALITY_EXPRESSION\":23,\"==\":24,\"===\":25,\"!=\":26,\"!==\":27,\"=~\":28,\"!=~\":29,\"IN_EXPRESSION\":30,\"in\":31,\"ARRAY_EXPRESSION\":32,\"notIn\":33,\"OBJECT_EXPRESSION\":34,\"AND_EXPRESSION\":35,\"&&\":36,\"OR_EXPRESSION\":37,\"||\":38,\"ARGUMENT_LIST\":39,\",\":40,\"IDENTIFIER_EXPRESSION\":41,\"IDENTIFIER\":42,\".\":43,\"[\":44,\"STRING_EXPRESSION\":45,\"]\":46,\"NUMBER_EXPRESSION\":47,\"(\":48,\")\":49,\"STRING\":50,\"NUMBER\":51,\"REGEXP_EXPRESSION\":52,\"REGEXP\":53,\"BOOLEAN_EXPRESSION\":54,\"BOOLEAN\":55,\"NULL_EXPRESSION\":56,\"NULL\":57,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",8:\"-\",9:\"!\",11:\"*\",12:\"/\",13:\"%\",15:\"+\",17:\"^\",19:\"<\",20:\">\",21:\"<=\",22:\">=\",24:\"==\",25:\"===\",26:\"!=\",27:\"!==\",28:\"=~\",29:\"!=~\",31:\"in\",33:\"notIn\",36:\"&&\",38:\"||\",40:\",\",42:\"IDENTIFIER\",43:\".\",44:\"[\",46:\"]\",48:\"(\",49:\")\",50:\"STRING\",51:\"NUMBER\",53:\"REGEXP\",55:\"BOOLEAN\",57:\"NULL\"},\nproductions_: [0,[3,2],[6,1],[6,2],[6,2],[10,1],[10,3],[10,3],[10,3],[14,1],[14,3],[14,3],[16,1],[16,3],[18,1],[18,3],[18,3],[18,3],[18,3],[23,1],[23,3],[23,3],[23,3],[23,3],[23,3],[23,3],[30,1],[30,3],[30,3],[30,3],[30,3],[35,1],[35,3],[37,1],[37,3],[39,1],[39,3],[41,1],[34,1],[34,3],[34,4],[34,4],[34,4],[34,3],[34,4],[45,1],[47,1],[52,1],[54,1],[56,1],[32,2],[32,3],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,3],[4,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\nreturn $$[$0-1];\nbreak;\ncase 3:\nthis.$ = [$$[$0], null, 'unary'];\nbreak;\ncase 4:\nthis.$ = [$$[$0], null, 'logicalNot'];\nbreak;\ncase 6:\nthis.$ = [$$[$0-2], $$[$0], 'mult'];\nbreak;\ncase 7:\nthis.$ = [$$[$0-2], $$[$0], 'div'];\nbreak;\ncase 8:\nthis.$ = [$$[$0-2], $$[$0], 'mod'];\nbreak;\ncase 10:\nthis.$ = [$$[$0-2], $$[$0], 'plus'];\nbreak;\ncase 11:\nthis.$ = [$$[$0-2], $$[$0], 'minus'];\nbreak;\ncase 13:\nthis.$ = [$$[$0-2], $$[$0], 'pow'];\nbreak;\ncase 15:\nthis.$ = [$$[$0-2], $$[$0], 'lt'];\nbreak;\ncase 16:\nthis.$ = [$$[$0-2], $$[$0], 'gt'];\nbreak;\ncase 17:\nthis.$ = [$$[$0-2], $$[$0], 'lte'];\nbreak;\ncase 18:\nthis.$ = [$$[$0-2], $$[$0], 'gte'];\nbreak;\ncase 20:\nthis.$ = [$$[$0-2], $$[$0], 'eq'];\nbreak;\ncase 21:\nthis.$ = [$$[$0-2], $$[$0], 'seq'];\nbreak;\ncase 22:\nthis.$ = [$$[$0-2], $$[$0], 'neq'];\nbreak;\ncase 23:\nthis.$ = [$$[$0-2], $$[$0], 'sneq'];\nbreak;\ncase 24:\nthis.$ = [$$[$0-2], $$[$0], 'like'];\nbreak;\ncase 25:\nthis.$ = [$$[$0-2], $$[$0], 'notLike'];\nbreak;\ncase 27: case 29:\nthis.$ = [$$[$0-2], $$[$0], 'in'];\nbreak;\ncase 28: case 30:\nthis.$ = [$$[$0-2], $$[$0], 'notIn'];\nbreak;\ncase 32:\nthis.$ = [$$[$0-2], $$[$0], 'and'];\nbreak;\ncase 34:\nthis.$ = [$$[$0-2], $$[$0], 'or'];\nbreak;\ncase 36:\nthis.$ = [$$[$0-2], $$[$0], 'arguments']\nbreak;\ncase 37:\nthis.$ = [String(yytext), null, 'identifier'];\nbreak;\ncase 39:\nthis.$ = [$$[$0-2],$$[$0], 'prop'];\nbreak;\ncase 40: case 41: case 42:\nthis.$ = [$$[$0-3],$$[$0-1], 'propLookup'];\nbreak;\ncase 43:\nthis.$ = [$$[$0-2], [null, null, 'arguments'], 'function']\nbreak;\ncase 44:\nthis.$ = [$$[$0-3], $$[$0-1], 'function']\nbreak;\ncase 45:\nthis.$ = [String(yytext.replace(/^['|\"]|['|\"]$/g, '')), null, 'string'];\nbreak;\ncase 46:\nthis.$ = [Number(yytext), null, 'number'];\nbreak;\ncase 47:\nthis.$ = [yytext, null, 'regexp'];\nbreak;\ncase 48:\nthis.$ = [yytext.replace(/^\\s+/, '') == 'true', null, 'boolean'];\nbreak;\ncase 49:\nthis.$ = [null, null, 'null'];\nbreak;\ncase 50:\nthis.$ = [null, null, 'array'];\nbreak;\ncase 51:\nthis.$ = [$$[$0-1], null, 'array'];\nbreak;\ncase 59:\nthis.$ = [$$[$0-1], null, 'composite']\nbreak;\n}\n},\ntable: [{3:1,4:2,6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:4,37:3,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{1:[3]},{5:[1,31]},o([5,49],[2,60],{38:[1,32]}),o($Va,[2,33],{36:$Vb}),o($Vc,[2,31]),o($Vc,[2,26],{24:[1,34],25:[1,35],26:[1,36],27:[1,37],28:[1,38],29:[1,39]}),o($Vd,$Ve,{31:[1,40],33:[1,41]}),o($Vf,[2,19],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vk,[2,52]),o($Vk,[2,53]),o($Vk,[2,54]),o($Vk,[2,55]),o($Vk,[2,56]),o($Vk,[2,57],{43:$Vl,44:$Vm,48:$Vn}),o($Vk,[2,58]),{4:49,6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:4,37:3,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vo,[2,14],{17:$Vp}),o($Vk,[2,45]),o($Vk,[2,46]),o($Vk,[2,47]),o($Vk,[2,48]),o($Vk,[2,49]),o($Vq,[2,38]),{7:53,32:15,34:14,39:52,41:23,42:$V2,44:$V3,45:9,46:[1,51],47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vr,[2,12],{8:$Vs,15:$Vt}),o($Vq,[2,37]),o($Vu,[2,9],{11:$Vv,12:$Vw,13:$Vx}),o($Vd,[2,5]),{6:59,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:61,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{1:[2,1]},{6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:62,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:63,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:64,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:65,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:66,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:67,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:68,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:69,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{32:70,34:71,41:23,42:$V2,44:$V3},{32:72,34:73,41:23,42:$V2,44:$V3},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:74,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:75,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:76,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:77,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{41:78,42:$V2},{34:81,41:23,42:$V2,45:79,47:80,50:$V5,51:$V6},{7:53,32:15,34:14,39:83,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,49:[1,82],50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{49:[1,84]},{6:28,7:60,8:$V0,9:$V1,10:27,14:85,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vk,[2,50]),{40:$Vy,46:[1,86]},o($Vz,[2,35]),{6:28,7:60,8:$V0,9:$V1,10:88,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:89,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:90,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:91,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:92,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vd,[2,3]),o($Vd,$Ve),o($Vd,[2,4]),o($Va,[2,34],{36:$Vb}),o($Vc,[2,32]),o($Vf,[2,20],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,21],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,22],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,23],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,24],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,25],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vc,[2,27]),o($Vc,[2,29],{43:$Vl,44:$Vm,48:$Vn}),o($Vc,[2,28]),o($Vc,[2,30],{43:$Vl,44:$Vm,48:$Vn}),o($Vo,[2,15],{17:$Vp}),o($Vo,[2,16],{17:$Vp}),o($Vo,[2,17],{17:$Vp}),o($Vo,[2,18],{17:$Vp}),o($Vq,[2,39]),{46:[1,93]},{46:[1,94]},{43:$Vl,44:$Vm,46:[1,95],48:$Vn},o($Vq,[2,43]),{40:$Vy,49:[1,96]},o($Vk,[2,59]),o($Vr,[2,13],{8:$Vs,15:$Vt}),o($Vk,[2,51]),{7:97,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vu,[2,10],{11:$Vv,12:$Vw,13:$Vx}),o($Vu,[2,11],{11:$Vv,12:$Vw,13:$Vx}),o($Vd,[2,6]),o($Vd,[2,7]),o($Vd,[2,8]),o($Vq,[2,40]),o($Vq,[2,41]),o($Vq,[2,42]),o($Vq,[2,44]),o($Vz,[2,36])],\ndefaultActions: {31:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 31;\nbreak;\ncase 1:return 33;\nbreak;\ncase 2:return 'from';\nbreak;\ncase 3:return 24;\nbreak;\ncase 4:return 25;\nbreak;\ncase 5:return 26;\nbreak;\ncase 6:return 27;\nbreak;\ncase 7:return 21;\nbreak;\ncase 8:return 19;\nbreak;\ncase 9:return 22;\nbreak;\ncase 10:return 20;\nbreak;\ncase 11:return 28;\nbreak;\ncase 12:return 29;\nbreak;\ncase 13:return 36;\nbreak;\ncase 14:return 38;\nbreak;\ncase 15:return 57;\nbreak;\ncase 16:return 55;\nbreak;\ncase 17:/* skip whitespace */\nbreak;\ncase 18:return 51;\nbreak;\ncase 19:return 50;\nbreak;\ncase 20:return 50;\nbreak;\ncase 21:return 42;\nbreak;\ncase 22:return 53;\nbreak;\ncase 23:return 43;\nbreak;\ncase 24:return 11;\nbreak;\ncase 25:return 12;\nbreak;\ncase 26:return 13;\nbreak;\ncase 27:return 40;\nbreak;\ncase 28:return 8;\nbreak;\ncase 29:return 28;\nbreak;\ncase 30:return 29;\nbreak;\ncase 31:return 25;\nbreak;\ncase 32:return 24;\nbreak;\ncase 33:return 27;\nbreak;\ncase 34:return 26;\nbreak;\ncase 35:return 21;\nbreak;\ncase 36:return 22;\nbreak;\ncase 37:return 20;\nbreak;\ncase 38:return 19;\nbreak;\ncase 39:return 36;\nbreak;\ncase 40:return 38;\nbreak;\ncase 41:return 15;\nbreak;\ncase 42:return 17;\nbreak;\ncase 43:return 48;\nbreak;\ncase 44:return 46;\nbreak;\ncase 45:return 44;\nbreak;\ncase 46:return 49;\nbreak;\ncase 47:return 9;\nbreak;\ncase 48:return 5;\nbreak;\n}\n},\nrules: [/^(?:\\s+in\\b)/,/^(?:\\s+notIn\\b)/,/^(?:\\s+from\\b)/,/^(?:\\s+(eq|EQ)\\b)/,/^(?:\\s+(seq|SEQ)\\b)/,/^(?:\\s+(neq|NEQ)\\b)/,/^(?:\\s+(sneq|SNEQ)\\b)/,/^(?:\\s+(lte|LTE)\\b)/,/^(?:\\s+(lt|LT)\\b)/,/^(?:\\s+(gte|GTE)\\b)/,/^(?:\\s+(gt|GT)\\b)/,/^(?:\\s+(like|LIKE)\\b)/,/^(?:\\s+(notLike|NOT_LIKE)\\b)/,/^(?:\\s+(and|AND)\\b)/,/^(?:\\s+(or|OR)\\b)/,/^(?:\\s*(null)\\b)/,/^(?:\\s*(true|false)\\b)/,/^(?:\\s+)/,/^(?:-?[0-9]+(?:\\.[0-9]+)?\\b)/,/^(?:'[^']*')/,/^(?:\"[^\"]*\")/,/^(?:([a-zA-Z_$][0-9a-zA-Z_$]*))/,/^(?:^\\/((?![\\s=])[^[\\/\\n\\\\]*(?:(?:\\\\[\\s\\S]|\\[[^\\]\\n\\\\]*(?:\\\\[\\s\\S][^\\]\\n\\\\]*)*])[^[\\/\\n\\\\]*)*\\/[imgy]{0,4})(?!\\w))/,/^(?:\\.)/,/^(?:\\*)/,/^(?:\\/)/,/^(?:\\%)/,/^(?:,)/,/^(?:-)/,/^(?:=~)/,/^(?:!=~)/,/^(?:===)/,/^(?:==)/,/^(?:!==)/,/^(?:!=)/,/^(?:<=)/,/^(?:>=)/,/^(?:>)/,/^(?:<)/,/^(?:&&)/,/^(?:\\|\\|)/,/^(?:\\+)/,/^(?:\\^)/,/^(?:\\()/,/^(?:\\])/,/^(?:\\[)/,/^(?:\\))/,/^(?:!)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/nools/nool.parser.js":"\"use strict\";\n\nvar tokens = require(\"./tokens.js\"),\n    extd = require(\"../../extended\"),\n    keys = extd.hash.keys,\n    utils = require(\"./util.js\");\n\nvar parse = function (src, keywords, context) {\n    var orig = src;\n    src = src.replace(/\\/\\/(.*)/g, \"\").replace(/\\r\\n|\\r|\\n/g, \" \");\n\n    var blockTypes = new RegExp(\"^(\" + keys(keywords).join(\"|\") + \")\"), index;\n    while (src && (index = utils.findNextTokenIndex(src)) !== -1) {\n        src = src.substr(index);\n        var blockType = src.match(blockTypes);\n        if (blockType !== null) {\n            blockType = blockType[1];\n            if (blockType in keywords) {\n                try {\n                    src = keywords[blockType](src, context, parse).replace(/^\\s*|\\s*$/g, \"\");\n                } catch (e) {\n                    throw new Error(\"Invalid \" + blockType + \" definition \\n\" + e.message + \"; \\nstarting at : \" + orig);\n                }\n            } else {\n                throw new Error(\"Unknown token\" + blockType);\n            }\n        } else {\n            throw new Error(\"Error parsing \" + src);\n        }\n    }\n};\n\nexports.parse = function (src, file) {\n    var context = {define: [], rules: [], scope: [], loaded: [], file: file};\n    parse(src, tokens, context);\n    return context;\n};\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/nools/tokens.js":"\"use strict\";\n\nvar utils = require(\"./util.js\"),\n    fs = require(\"fs\"),\n    extd = require(\"../../extended\"),\n    filter = extd.filter,\n    indexOf = extd.indexOf,\n    predicates = [\"not\", \"or\", \"exists\"],\n    predicateRegExp = new RegExp(\"^(\" + predicates.join(\"|\") + \") *\\\\((.*)\\\\)$\", \"m\"),\n    predicateBeginExp = new RegExp(\" *(\" + predicates.join(\"|\") + \") *\\\\(\", \"g\");\n\nvar isWhiteSpace = function (str) {\n    return str.replace(/[\\s|\\n|\\r|\\t]/g, \"\").length === 0;\n};\n\nvar joinFunc = function (m, str) {\n    return \"; \" + str;\n};\n\nvar splitRuleLineByPredicateExpressions = function (ruleLine) {\n    var str = ruleLine.replace(/,\\s*(\\$?\\w+\\s*:)/g, joinFunc);\n    var parts = filter(str.split(predicateBeginExp), function (str) {\n            return str !== \"\";\n        }),\n        l = parts.length, ret = [];\n\n    if (l) {\n        for (var i = 0; i < l; i++) {\n            if (indexOf(predicates, parts[i]) !== -1) {\n                ret.push([parts[i], \"(\", parts[++i].replace(/, *$/, \"\")].join(\"\"));\n            } else {\n                ret.push(parts[i].replace(/, *$/, \"\"));\n            }\n        }\n    } else {\n        return str;\n    }\n    return ret.join(\";\");\n};\n\nvar ruleTokens = {\n\n    salience: (function () {\n        var salienceRegexp = /^(salience|priority)\\s*:\\s*(-?\\d+)\\s*[,;]?/;\n        return function (src, context) {\n            if (salienceRegexp.test(src)) {\n                var parts = src.match(salienceRegexp),\n                    priority = parseInt(parts[2], 10);\n                if (!isNaN(priority)) {\n                    context.options.priority = priority;\n                } else {\n                    throw new Error(\"Invalid salience/priority \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    agendaGroup: (function () {\n        var agendaGroupRegexp = /^(agenda-group|agendaGroup)\\s*:\\s*([a-zA-Z_$][0-9a-zA-Z_$]*|\"[^\"]*\"|'[^']*')\\s*[,;]?/;\n        return function (src, context) {\n            if (agendaGroupRegexp.test(src)) {\n                var parts = src.match(agendaGroupRegexp),\n                    agendaGroup = parts[2];\n                if (agendaGroup) {\n                    context.options.agendaGroup = agendaGroup.replace(/^[\"']|[\"']$/g, \"\");\n                } else {\n                    throw new Error(\"Invalid agenda-group \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    autoFocus: (function () {\n        var autoFocusRegexp = /^(auto-focus|autoFocus)\\s*:\\s*(true|false)\\s*[,;]?/;\n        return function (src, context) {\n            if (autoFocusRegexp.test(src)) {\n                var parts = src.match(autoFocusRegexp),\n                    autoFocus = parts[2];\n                if (autoFocus) {\n                    context.options.autoFocus = autoFocus === \"true\" ? true : false;\n                } else {\n                    throw new Error(\"Invalid auto-focus \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    \"agenda-group\": function () {\n        return this.agendaGroup.apply(this, arguments);\n    },\n\n    \"auto-focus\": function () {\n        return this.autoFocus.apply(this, arguments);\n    },\n\n    priority: function () {\n        return this.salience.apply(this, arguments);\n    },\n\n    when: (function () {\n        /*jshint evil:true*/\n\n        var ruleRegExp = /^(\\$?\\w+) *: *(\\w+)(.*)/;\n\n        var constraintRegExp = /(\\{ *(?:[\"']?\\$?\\w+[\"']?\\s*:\\s*[\"']?\\$?\\w+[\"']? *(?:, *[\"']?\\$?\\w+[\"']?\\s*:\\s*[\"']?\\$?\\w+[\"']?)*)+ *\\})/;\n        var fromRegExp = /(\\bfrom\\s+.*)/;\n        var parseRules = function (str) {\n            var rules = [];\n            var ruleLines = str.split(\";\"), l = ruleLines.length, ruleLine;\n            for (var i = 0; i < l && (ruleLine = ruleLines[i].replace(/^\\s*|\\s*$/g, \"\").replace(/\\n/g, \"\")); i++) {\n                if (!isWhiteSpace(ruleLine)) {\n                    var rule = [];\n                    if (predicateRegExp.test(ruleLine)) {\n                        var m = ruleLine.match(predicateRegExp);\n                        var pred = m[1].replace(/^\\s*|\\s*$/g, \"\");\n                        rule.push(pred);\n                        ruleLine = m[2].replace(/^\\s*|\\s*$/g, \"\");\n                        if (pred === \"or\") {\n                            rule = rule.concat(parseRules(splitRuleLineByPredicateExpressions(ruleLine)));\n                            rules.push(rule);\n                            continue;\n                        }\n\n                    }\n                    var parts = ruleLine.match(ruleRegExp);\n                    if (parts && parts.length) {\n                        rule.push(parts[2], parts[1]);\n                        var constraints = parts[3].replace(/^\\s*|\\s*$/g, \"\");\n                        var hashParts = constraints.match(constraintRegExp), from = null, fromMatch;\n                        if (hashParts) {\n                            var hash = hashParts[1], constraint = constraints.replace(hash, \"\");\n                            if (fromRegExp.test(constraint)) {\n                                fromMatch = constraint.match(fromRegExp);\n                                from = fromMatch[0];\n                                constraint = constraint.replace(fromMatch[0], \"\");\n                            }\n                            if (constraint) {\n                                rule.push(constraint.replace(/^\\s*|\\s*$/g, \"\"));\n                            }\n                            if (hash) {\n                                rule.push(eval(\"(\" + hash.replace(/(\\$?\\w+)\\s*:\\s*(\\$?\\w+)/g, '\"$1\" : \"$2\"') + \")\"));\n                            }\n                        } else if (constraints && !isWhiteSpace(constraints)) {\n                            if (fromRegExp.test(constraints)) {\n                                fromMatch = constraints.match(fromRegExp);\n                                from = fromMatch[0];\n                                constraints = constraints.replace(fromMatch[0], \"\");\n                            }\n                            rule.push(constraints);\n                        }\n                        if (from) {\n                            rule.push(from);\n                        }\n                        rules.push(rule);\n                    } else {\n                        throw new Error(\"Invalid constraint \" + ruleLine);\n                    }\n                }\n            }\n            return rules;\n        };\n\n        return function (orig, context) {\n            var src = orig.replace(/^when\\s*/, \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                context.constraints = parseRules(body.replace(/^\\{\\s*|\\}\\s*$/g, \"\"));\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        };\n    })(),\n\n    then: (function () {\n        return function (orig, context) {\n            if (!context.action) {\n                var src = orig.replace(/^then\\s*/, \"\").replace(/^\\s*|\\s*$/g, \"\");\n                if (utils.findNextToken(src) === \"{\") {\n                    var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                    src = src.replace(body, \"\");\n                    if (!context.action) {\n                        context.action = body.replace(/^\\{\\s*|\\}\\s*$/g, \"\");\n                    }\n                    if (!isWhiteSpace(src)) {\n                        throw new Error(\"Error parsing then block \" + orig);\n                    }\n                    return src;\n                } else {\n                    throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n                }\n            } else {\n                throw new Error(\"action already defined for rule\" + context.name);\n            }\n\n        };\n    })()\n};\n\nvar topLevelTokens = {\n    \"/\": function (orig) {\n        if (orig.match(/^\\/\\*/)) {\n            // Block Comment parse\n            return orig.replace(/\\/\\*.*?\\*\\//, \"\");\n        } else {\n            return orig;\n        }\n    },\n\n    \"define\": function (orig, context) {\n        var src = orig.replace(/^define\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*)/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                name = name[1];\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                //should\n                context.define.push({name: name, properties: \"(\" + body + \")\"});\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    \"import\": function (orig, context, parse) {\n        if (typeof window !== 'undefined') {\n            throw new Error(\"import cannot be used in a browser\");\n        }\n        var src = orig.replace(/^import\\s*/, \"\");\n        if (utils.findNextToken(src) === \"(\") {\n            var file = utils.getParamList(src);\n            src = src.replace(file, \"\").replace(/^\\s*|\\s*$/g, \"\");\n            utils.findNextToken(src) === \";\" && (src = src.replace(/\\s*;/, \"\"));\n            file = file.replace(/[\\(|\\)]/g, \"\").split(\",\");\n            if (file.length === 1) {\n                file = utils.resolve(context.file || process.cwd(), file[0].replace(/[\"|']/g, \"\"));\n                if (indexOf(context.loaded, file) === -1) {\n                    var origFile = context.file;\n                    context.file = file;\n                    parse(fs.readFileSync(file, \"utf8\"), topLevelTokens, context);\n                    context.loaded.push(file);\n                    context.file = origFile;\n                }\n                return src;\n            } else {\n                throw new Error(\"import accepts a single file\");\n            }\n        } else {\n            throw new Error(\"unexpected token : expected : '(' found : '\" + utils.findNextToken(src) + \"'\");\n        }\n\n    },\n\n    //define a global\n    \"global\": function (orig, context) {\n        var src = orig.replace(/^global\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*\\s*)/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"=\") {\n                name = name[1].replace(/^\\s+|\\s+$/g, '');\n                var fullbody = utils.getTokensBetween(src, \"=\", \";\", true).join(\"\");\n                var body = fullbody.substring(1, fullbody.length - 1);\n                body = body.replace(/^\\s+|\\s+$/g, '');\n                if (/^require\\(/.test(body)) {\n                    var file = utils.getParamList(body.replace(\"require\")).replace(/[\\(|\\)]/g, \"\").split(\",\");\n                    if (file.length === 1) {\n                        //handle relative require calls\n                        file = file[0].replace(/[\"|']/g, \"\");\n                        body = [\"require('\", utils.resolve(context.file || process.cwd(), file) , \"')\"].join(\"\");\n                    }\n                }\n                context.scope.push({name: name, body: body});\n                src = src.replace(fullbody, \"\");\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '=' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    //define a function\n    \"function\": function (orig, context) {\n        var src = orig.replace(/^function\\s*/, \"\");\n        //parse the function name\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*)\\s*/);\n        if (name) {\n            src = src.replace(name[0], \"\");\n            if (utils.findNextToken(src) === \"(\") {\n                name = name[1];\n                var params = utils.getParamList(src);\n                src = src.replace(params, \"\").replace(/^\\s*|\\s*$/g, \"\");\n                if (utils.findNextToken(src) === \"{\") {\n                    var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                    src = src.replace(body, \"\");\n                    //should\n                    context.scope.push({name: name, body: \"function\" + params + body});\n                    return src;\n                } else {\n                    throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n                }\n            } else {\n                throw new Error(\"unexpected token : expected : '(' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    \"rule\": function (orig, context, parse) {\n        var src = orig.replace(/^rule\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*|\"[^\"]*\"|'[^']*')/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                name = name[1].replace(/^[\"']|[\"']$/g, \"\");\n                var rule = {name: name, options: {}, constraints: null, action: null};\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                parse(body.replace(/^\\{\\s*|\\}\\s*$/g, \"\"), ruleTokens, rule);\n                context.rules.push(rule);\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n\n    }\n};\nmodule.exports = topLevelTokens;\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/nools/util.js":"\"use strict\";\n\nvar path = require(\"path\");\nvar WHITE_SPACE_REG = /[\\s|\\n|\\r|\\t]/,\n    pathSep = path.sep || ( process.platform === 'win32' ? '\\\\' : '/' );\n\nvar TOKEN_INVERTS = {\n    \"{\": \"}\",\n    \"}\": \"{\",\n    \"(\": \")\",\n    \")\": \"(\",\n    \"[\": \"]\"\n};\n\nvar getTokensBetween = exports.getTokensBetween = function (str, start, stop, includeStartEnd) {\n    var depth = 0, ret = [];\n    if (!start) {\n        start = TOKEN_INVERTS[stop];\n        depth = 1;\n    }\n    if (!stop) {\n        stop = TOKEN_INVERTS[start];\n    }\n    str = Object(str);\n    var startPushing = false, token, cursor = 0, found = false;\n    while ((token = str.charAt(cursor++))) {\n        if (token === start) {\n            depth++;\n            if (!startPushing) {\n                startPushing = true;\n                if (includeStartEnd) {\n                    ret.push(token);\n                }\n            } else {\n                ret.push(token);\n            }\n        } else if (token === stop && cursor) {\n            depth--;\n            if (depth === 0) {\n                if (includeStartEnd) {\n                    ret.push(token);\n                }\n                found = true;\n                break;\n            }\n            ret.push(token);\n        } else if (startPushing) {\n            ret.push(token);\n        }\n    }\n    if (!found) {\n        throw new Error(\"Unable to match \" + start + \" in \" + str);\n    }\n    return ret;\n};\n\nexports.getParamList = function (str) {\n    return  getTokensBetween(str, \"(\", \")\", true).join(\"\");\n};\n\nexports.resolve = function (from, to) {\n    if (process.platform === 'win32') {\n        to = to.replace(/\\//g, '\\\\');\n    }\n    if (path.extname(from) !== '') {\n        from = path.dirname(from);\n    }\n    if (to.split(pathSep).length === 1) {\n        return to;\n    }\n    return path.resolve(from, to).replace(/\\\\/g, '/');\n\n};\n\nvar findNextTokenIndex = exports.findNextTokenIndex = function (str, startIndex, endIndex) {\n    startIndex = startIndex || 0;\n    endIndex = endIndex || str.length;\n    var ret = -1, l = str.length;\n    if (!endIndex || endIndex > l) {\n        endIndex = l;\n    }\n    for (; startIndex < endIndex; startIndex++) {\n        var c = str.charAt(startIndex);\n        if (!WHITE_SPACE_REG.test(c)) {\n            ret = startIndex;\n            break;\n        }\n    }\n    return ret;\n};\n\nexports.findNextToken = function (str, startIndex, endIndex) {\n    return str.charAt(findNextTokenIndex(str, startIndex, endIndex));\n};","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/constraintMatcher.js":"\"use strict\";\n\nvar extd = require(\"./extended\"),\n    isArray = extd.isArray,\n    forEach = extd.forEach,\n    some = extd.some,\n    indexOf = extd.indexOf,\n    isNumber = extd.isNumber,\n    removeDups = extd.removeDuplicates,\n    atoms = require(\"./constraint\");\n\nfunction getProps(val) {\n    return extd(val).map(function mapper(val) {\n        return isArray(val) ? isArray(val[0]) ? getProps(val).value() : val.reverse().join(\".\") : val;\n    }).flatten().filter(function (v) {\n        return !!v;\n    });\n}\n\nvar definedFuncs = {\n    indexOf: extd.indexOf,\n    now: function () {\n        return new Date();\n    },\n\n    Date: function (y, m, d, h, min, s, ms) {\n        var date = new Date();\n        if (isNumber(y)) {\n            date.setYear(y);\n        }\n        if (isNumber(m)) {\n            date.setMonth(m);\n        }\n        if (isNumber(d)) {\n            date.setDate(d);\n        }\n        if (isNumber(h)) {\n            date.setHours(h);\n        }\n        if (isNumber(min)) {\n            date.setMinutes(min);\n        }\n        if (isNumber(s)) {\n            date.setSeconds(s);\n        }\n        if (isNumber(ms)) {\n            date.setMilliseconds(ms);\n        }\n        return date;\n    },\n\n    lengthOf: function (arr, length) {\n        return arr.length === length;\n    },\n\n    isTrue: function (val) {\n        return val === true;\n    },\n\n    isFalse: function (val) {\n        return val === false;\n    },\n\n    isNotNull: function (actual) {\n        return actual !== null;\n    },\n\n    dateCmp: function (dt1, dt2) {\n        return extd.compare(dt1, dt2);\n    }\n\n};\n\nforEach([\"years\", \"days\", \"months\", \"hours\", \"minutes\", \"seconds\"], function (k) {\n    definedFuncs[k + \"FromNow\"] = extd[k + \"FromNow\"];\n    definedFuncs[k + \"Ago\"] = extd[k + \"Ago\"];\n});\n\n\nforEach([\"isArray\", \"isNumber\", \"isHash\", \"isObject\", \"isDate\", \"isBoolean\", \"isString\", \"isRegExp\", \"isNull\", \"isEmpty\",\n    \"isUndefined\", \"isDefined\", \"isUndefinedOrNull\", \"isPromiseLike\", \"isFunction\", \"deepEqual\"], function (k) {\n    var m = extd[k];\n    definedFuncs[k] = function () {\n        return m.apply(extd, arguments);\n    };\n});\n\n\nvar lang = {\n\n    equal: function (c1, c2) {\n        var ret = false;\n        if (c1 === c2) {\n            ret = true;\n        } else {\n            if (c1[2] === c2[2]) {\n                if (indexOf([\"string\", \"number\", \"boolean\", \"regexp\", \"identifier\", \"null\"], c1[2]) !== -1) {\n                    ret = c1[0] === c2[0];\n                } else if (c1[2] === \"unary\" || c1[2] === \"logicalNot\") {\n                    ret = this.equal(c1[0], c2[0]);\n                } else {\n                    ret = this.equal(c1[0], c2[0]) && this.equal(c1[1], c2[1]);\n                }\n            }\n        }\n        return ret;\n    },\n\n    __getProperties: function (rule) {\n        var ret = [];\n        if (rule) {\n            var rule2 = rule[2];\n            if (!rule2) {\n                return ret;\n            }\n            if (rule2 !== \"prop\" &&\n                rule2 !== \"identifier\" &&\n                rule2 !== \"string\" &&\n                rule2 !== \"number\" &&\n                rule2 !== \"boolean\" &&\n                rule2 !== \"regexp\" &&\n                rule2 !== \"unary\" &&\n                rule2 !== \"unary\") {\n                ret[0] = this.__getProperties(rule[0]);\n                ret[1] = this.__getProperties(rule[1]);\n            } else if (rule2 === \"identifier\") {\n                //at the bottom\n                ret = [rule[0]];\n            } else {\n                ret = lang.__getProperties(rule[1]).concat(lang.__getProperties(rule[0]));\n            }\n        }\n        return ret;\n    },\n\n    getIndexableProperties: function (rule) {\n        if (rule[2] === \"composite\") {\n            return this.getIndexableProperties(rule[0]);\n        } else if (/^(\\w+(\\['[^']*'])*) *([!=]==?|[<>]=?) (\\w+(\\['[^']*'])*)$/.test(this.parse(rule))) {\n            return getProps(this.__getProperties(rule)).flatten().value();\n        } else {\n            return [];\n        }\n    },\n\n    getIdentifiers: function (rule) {\n        var ret = [];\n        var rule2 = rule[2];\n\n        if (rule2 === \"identifier\") {\n            //its an identifier so stop\n            return [rule[0]];\n        } else if (rule2 === \"function\") {\n            ret = ret.concat(this.getIdentifiers(rule[0])).concat(this.getIdentifiers(rule[1]));\n        } else if (rule2 !== \"string\" &&\n            rule2 !== \"number\" &&\n            rule2 !== \"boolean\" &&\n            rule2 !== \"regexp\" &&\n            rule2 !== \"unary\" &&\n            rule2 !== \"unary\") {\n            //its an expression so keep going\n            if (rule2 === \"prop\") {\n                ret = ret.concat(this.getIdentifiers(rule[0]));\n                if (rule[1]) {\n                    var propChain = rule[1];\n                    //go through the member variables and collect any identifiers that may be in functions\n                    while (isArray(propChain)) {\n                        if (propChain[2] === \"function\") {\n                            ret = ret.concat(this.getIdentifiers(propChain[1]));\n                            break;\n                        } else {\n                            propChain = propChain[1];\n                        }\n                    }\n                }\n\n            } else {\n                if (rule[0]) {\n                    ret = ret.concat(this.getIdentifiers(rule[0]));\n                }\n                if (rule[1]) {\n                    ret = ret.concat(this.getIdentifiers(rule[1]));\n                }\n            }\n        }\n        //remove dups and return\n        return removeDups(ret);\n    },\n\n    toConstraints: function (rule, options) {\n        var ret = [],\n            alias = options.alias,\n            scope = options.scope || {};\n\n        var rule2 = rule[2];\n\n\n        if (rule2 === \"and\") {\n            ret = ret.concat(this.toConstraints(rule[0], options)).concat(this.toConstraints(rule[1], options));\n        } else if (\n            rule2 === \"composite\" ||\n            rule2 === \"or\" ||\n            rule2 === \"lt\" ||\n            rule2 === \"gt\" ||\n            rule2 === \"lte\" ||\n            rule2 === \"gte\" ||\n            rule2 === \"like\" ||\n            rule2 === \"notLike\" ||\n            rule2 === \"eq\" ||\n            rule2 === \"neq\" ||\n            rule2 === \"seq\" ||\n            rule2 === \"sneq\" ||\n            rule2 === \"in\" ||\n            rule2 === \"notIn\" ||\n            rule2 === \"prop\" ||\n            rule2 === \"propLookup\" ||\n            rule2 === \"function\" ||\n            rule2 === \"logicalNot\") {\n            var isReference = some(this.getIdentifiers(rule), function (i) {\n                return i !== alias && !(i in definedFuncs) && !(i in scope);\n            });\n            switch (rule2) {\n            case \"eq\":\n                ret.push(new atoms[isReference ? \"ReferenceEqualityConstraint\" : \"EqualityConstraint\"](rule, options));\n                break;\n            case \"seq\":\n                ret.push(new atoms[isReference ? \"ReferenceEqualityConstraint\" : \"EqualityConstraint\"](rule, options));\n                break;\n            case \"neq\":\n                ret.push(new atoms[isReference ? \"ReferenceInequalityConstraint\" : \"InequalityConstraint\"](rule, options));\n                break;\n            case \"sneq\":\n                ret.push(new atoms[isReference ? \"ReferenceInequalityConstraint\" : \"InequalityConstraint\"](rule, options));\n                break;\n            case \"gt\":\n                ret.push(new atoms[isReference ? \"ReferenceGTConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"gte\":\n                ret.push(new atoms[isReference ? \"ReferenceGTEConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"lt\":\n                ret.push(new atoms[isReference ? \"ReferenceLTConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"lte\":\n                ret.push(new atoms[isReference ? \"ReferenceLTEConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            default:\n                ret.push(new atoms[isReference ? \"ReferenceConstraint\" : \"ComparisonConstraint\"](rule, options));\n            }\n\n        }\n        return ret;\n    },\n\n\n    parse: function (rule) {\n        return this[rule[2]](rule[0], rule[1]);\n    },\n\n    composite: function (lhs) {\n        return this.parse(lhs);\n    },\n\n    and: function (lhs, rhs) {\n        return [\"(\", this.parse(lhs), \"&&\", this.parse(rhs), \")\"].join(\" \");\n    },\n\n    or: function (lhs, rhs) {\n        return [\"(\", this.parse(lhs), \"||\", this.parse(rhs), \")\"].join(\" \");\n    },\n\n    prop: function (name, prop) {\n        if (prop[2] === \"function\") {\n            return [this.parse(name), this.parse(prop)].join(\".\");\n        } else {\n            return [this.parse(name), \"['\", this.parse(prop), \"']\"].join(\"\");\n        }\n    },\n\n    propLookup: function (name, prop) {\n        if (prop[2] === \"function\") {\n            return [this.parse(name), this.parse(prop)].join(\".\");\n        } else {\n            return [this.parse(name), \"[\", this.parse(prop), \"]\"].join(\"\");\n        }\n    },\n\n    unary: function (lhs) {\n        return -1 * this.parse(lhs);\n    },\n\n    plus: function (lhs, rhs) {\n        return [this.parse(lhs), \"+\", this.parse(rhs)].join(\" \");\n    },\n    minus: function (lhs, rhs) {\n        return [this.parse(lhs), \"-\", this.parse(rhs)].join(\" \");\n    },\n\n    mult: function (lhs, rhs) {\n        return [this.parse(lhs), \"*\", this.parse(rhs)].join(\" \");\n    },\n\n    div: function (lhs, rhs) {\n        return [this.parse(lhs), \"/\", this.parse(rhs)].join(\" \");\n    },\n\n    mod: function (lhs, rhs) {\n        return [this.parse(lhs), \"%\", this.parse(rhs)].join(\" \");\n    },\n\n    lt: function (lhs, rhs) {\n        return [this.parse(lhs), \"<\", this.parse(rhs)].join(\" \");\n    },\n    gt: function (lhs, rhs) {\n        return [this.parse(lhs), \">\", this.parse(rhs)].join(\" \");\n    },\n    lte: function (lhs, rhs) {\n        return [this.parse(lhs), \"<=\", this.parse(rhs)].join(\" \");\n    },\n    gte: function (lhs, rhs) {\n        return [this.parse(lhs), \">=\", this.parse(rhs)].join(\" \");\n    },\n    like: function (lhs, rhs) {\n        return [this.parse(rhs), \".test(\", this.parse(lhs), \")\"].join(\"\");\n    },\n    notLike: function (lhs, rhs) {\n        return [\"!\", this.parse(rhs), \".test(\", this.parse(lhs), \")\"].join(\"\");\n    },\n    eq: function (lhs, rhs) {\n        return [this.parse(lhs), \"==\", this.parse(rhs)].join(\" \");\n    },\n\n    seq: function (lhs, rhs) {\n        return [this.parse(lhs), \"===\", this.parse(rhs)].join(\" \");\n    },\n\n    neq: function (lhs, rhs) {\n        return [this.parse(lhs), \"!=\", this.parse(rhs)].join(\" \");\n    },\n\n    sneq: function (lhs, rhs) {\n        return [this.parse(lhs), \"!==\", this.parse(rhs)].join(\" \");\n    },\n\n    \"in\": function (lhs, rhs) {\n        return [\"(indexOf(\", this.parse(rhs), \",\", this.parse(lhs), \")) != -1\"].join(\"\");\n    },\n\n    \"notIn\": function (lhs, rhs) {\n        return [\"(indexOf(\", this.parse(rhs), \",\", this.parse(lhs), \")) == -1\"].join(\"\");\n    },\n\n    \"arguments\": function (lhs, rhs) {\n        var ret = [];\n        if (lhs) {\n            ret.push(this.parse(lhs));\n        }\n        if (rhs) {\n            ret.push(this.parse(rhs));\n        }\n        return ret.join(\",\");\n    },\n\n    \"array\": function (lhs) {\n        var args = [];\n        if (lhs) {\n            args = this.parse(lhs);\n            if (isArray(args)) {\n                return args;\n            } else {\n                return [\"[\", args, \"]\"].join(\"\");\n            }\n        }\n        return [\"[\", args.join(\",\"), \"]\"].join(\"\");\n    },\n\n    \"function\": function (lhs, rhs) {\n        var args = this.parse(rhs);\n        return [this.parse(lhs), \"(\", args, \")\"].join(\"\");\n    },\n\n    \"string\": function (lhs) {\n        return \"'\" + lhs + \"'\";\n    },\n\n    \"number\": function (lhs) {\n        return lhs;\n    },\n\n    \"boolean\": function (lhs) {\n        return lhs;\n    },\n\n    regexp: function (lhs) {\n        return lhs;\n    },\n\n    identifier: function (lhs) {\n        return lhs;\n    },\n\n    \"null\": function () {\n        return \"null\";\n    },\n\n    logicalNot: function (lhs) {\n        return [\"!(\", this.parse(lhs), \")\"].join(\"\");\n    }\n};\n\nvar matcherCount = 0;\nvar toJs = exports.toJs = function (rule, scope, alias, equality, wrap) {\n    /*jshint evil:true*/\n    var js = lang.parse(rule);\n    scope = scope || {};\n    var vars = lang.getIdentifiers(rule);\n    var closureVars = [\"var indexOf = definedFuncs.indexOf; var hasOwnProperty = Object.prototype.hasOwnProperty;\"], funcVars = [];\n    extd(vars).filter(function (v) {\n        var ret = [\"var \", v, \" = \"];\n        if (definedFuncs.hasOwnProperty(v)) {\n            ret.push(\"definedFuncs['\", v, \"']\");\n        } else if (scope.hasOwnProperty(v)) {\n            ret.push(\"scope['\", v, \"']\");\n        } else {\n            return true;\n        }\n        ret.push(\";\");\n        closureVars.push(ret.join(\"\"));\n        return false;\n    }).forEach(function (v) {\n        var ret = [\"var \", v, \" = \"];\n        if (equality || v !== alias) {\n            ret.push(\"fact.\" + v);\n        } else if (v === alias) {\n            ret.push(\"hash.\", v, \"\");\n        }\n        ret.push(\";\");\n        funcVars.push(ret.join(\"\"));\n    });\n    var closureBody = closureVars.join(\"\") + \"return function matcher\" + (matcherCount++) + (!equality ? \"(fact, hash){\" : \"(fact){\") + funcVars.join(\"\") + \" return \" + (wrap ? wrap(js) : js) + \";}\";\n    var f = new Function(\"definedFuncs, scope\", closureBody)(definedFuncs, scope);\n    //console.log(f.toString());\n    return f;\n};\n\nexports.getMatcher = function (rule, options, equality) {\n    options = options || {};\n    return toJs(rule, options.scope, options.alias, equality, function (src) {\n        return \"!!(\" + src + \")\";\n    });\n};\n\nexports.getSourceMatcher = function (rule, options, equality) {\n    options = options || {};\n    return toJs(rule, options.scope, options.alias, equality, function (src) {\n        return src;\n    });\n};\n\nexports.toConstraints = function (constraint, options) {\n    if (typeof constraint === 'function') {\n        return [new atoms.CustomConstraint(constraint, options)];\n    }\n    //constraint.split(\"&&\")\n    return lang.toConstraints(constraint, options);\n};\n\nexports.equal = function (c1, c2) {\n    return lang.equal(c1, c2);\n};\n\nexports.getIdentifiers = function (constraint) {\n    return lang.getIdentifiers(constraint);\n};\n\nexports.getIndexableProperties = function (constraint) {\n    return lang.getIndexableProperties(constraint);\n};","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/constraint.js":"\"use strict\";\n\nvar extd = require(\"./extended\"),\n    deepEqual = extd.deepEqual,\n    merge = extd.merge,\n    instanceOf = extd.instanceOf,\n    filter = extd.filter,\n    declare = extd.declare,\n    constraintMatcher;\n\nvar id = 0;\nvar Constraint = declare({\n\n    type: null,\n\n    instance: {\n        constructor: function (constraint) {\n            if (!constraintMatcher) {\n                constraintMatcher = require(\"./constraintMatcher\");\n            }\n            this.id = id++;\n            this.constraint = constraint;\n            extd.bindAll(this, [\"assert\"]);\n        },\n        \"assert\": function () {\n            throw new Error(\"not implemented\");\n        },\n\n        getIndexableProperties: function () {\n            return [];\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n        getters: {\n            variables: function () {\n                return [this.get(\"alias\")];\n            }\n        }\n\n\n    }\n});\n\nConstraint.extend({\n    instance: {\n\n        type: \"object\",\n\n        constructor: function (type) {\n            this._super([type]);\n        },\n\n        \"assert\": function (param) {\n            return param instanceof this.constraint || param.constructor === this.constraint;\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.constraint === constraint.constraint;\n        }\n    }\n}).as(exports, \"ObjectConstraint\");\n\nvar EqualityConstraint = Constraint.extend({\n\n    instance: {\n\n        type: \"equality\",\n\n        constructor: function (constraint, options) {\n            this._super([constraint]);\n            options = options || {};\n            this.pattern = options.pattern;\n            this._matcher = constraintMatcher.getMatcher(constraint, options, true);\n        },\n\n        \"assert\": function (values) {\n            return this._matcher(values);\n        }\n    }\n}).as(exports, \"EqualityConstraint\");\n\nEqualityConstraint.extend({instance: {type: \"inequality\"}}).as(exports, \"InequalityConstraint\");\nEqualityConstraint.extend({instance: {type: \"comparison\"}}).as(exports, \"ComparisonConstraint\");\n\nConstraint.extend({\n\n    instance: {\n\n        type: \"equality\",\n\n        constructor: function () {\n            this._super([\n                [true]\n            ]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\");\n        },\n\n\n        \"assert\": function () {\n            return true;\n        }\n    }\n}).as(exports, \"TrueConstraint\");\n\nvar ReferenceConstraint = Constraint.extend({\n\n    instance: {\n\n        type: \"reference\",\n\n        constructor: function (constraint, options) {\n            this.cache = {};\n            this._super([constraint]);\n            options = options || {};\n            this.values = [];\n            this.pattern = options.pattern;\n            this._options = options;\n            this._matcher = constraintMatcher.getMatcher(constraint, options, false);\n        },\n\n        \"assert\": function (fact, fh) {\n            try {\n                return this._matcher(fact, fh);\n            } catch (e) {\n                throw new Error(\"Error with evaluating pattern \" + this.pattern + \" \" + e.message);\n            }\n\n        },\n\n        merge: function (that) {\n            var ret = this;\n            if (that instanceof ReferenceConstraint) {\n                ret = new this._static([this.constraint, that.constraint, \"and\"], merge({}, this._options, this._options));\n                ret._alias = this._alias || that._alias;\n                ret.vars = this.vars.concat(that.vars);\n            }\n            return ret;\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n\n        getters: {\n            variables: function () {\n                return this.vars;\n            },\n\n            alias: function () {\n                return this._alias;\n            }\n        },\n\n        setters: {\n            alias: function (alias) {\n                this._alias = alias;\n                this.vars = filter(constraintMatcher.getIdentifiers(this.constraint), function (v) {\n                    return v !== alias;\n                });\n            }\n        }\n    }\n\n}).as(exports, \"ReferenceConstraint\");\n\n\nReferenceConstraint.extend({\n    instance: {\n        type: \"reference_equality\",\n        op: \"eq\",\n        getIndexableProperties: function () {\n            return constraintMatcher.getIndexableProperties(this.constraint);\n        }\n    }\n}).as(exports, \"ReferenceEqualityConstraint\")\n    .extend({instance: {type: \"reference_inequality\", op: \"neq\"}}).as(exports, \"ReferenceInequalityConstraint\")\n    .extend({instance: {type: \"reference_gt\", op: \"gt\"}}).as(exports, \"ReferenceGTConstraint\")\n    .extend({instance: {type: \"reference_gte\", op: \"gte\"}}).as(exports, \"ReferenceGTEConstraint\")\n    .extend({instance: {type: \"reference_lt\", op: \"lt\"}}).as(exports, \"ReferenceLTConstraint\")\n    .extend({instance: {type: \"reference_lte\", op: \"lte\"}}).as(exports, \"ReferenceLTEConstraint\");\n\n\nConstraint.extend({\n    instance: {\n\n        type: \"hash\",\n\n        constructor: function (hash) {\n            this._super([hash]);\n        },\n\n        equal: function (constraint) {\n            return extd.instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n        \"assert\": function () {\n            return true;\n        },\n\n        getters: {\n            variables: function () {\n                return this.constraint;\n            }\n        }\n\n    }\n}).as(exports, \"HashConstraint\");\n\nConstraint.extend({\n    instance: {\n        constructor: function (constraints, options) {\n            this.type = \"from\";\n            this.constraints = constraintMatcher.getSourceMatcher(constraints, (options || {}), true);\n            extd.bindAll(this, [\"assert\"]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && deepEqual(this.constraints, constraint.constraints);\n        },\n\n        \"assert\": function (fact, fh) {\n            return this.constraints(fact, fh);\n        },\n\n        getters: {\n            variables: function () {\n                return this.constraint;\n            }\n        }\n\n    }\n}).as(exports, \"FromConstraint\");\n\nConstraint.extend({\n    instance: {\n        constructor: function (func, options) {\n            this.type = \"custom\";\n            this.fn = func;\n            this.options = options;\n            extd.bindAll(this, [\"assert\"]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.fn === constraint.constraint;\n        },\n\n        \"assert\": function (fact, fh) {\n            return this.fn(fact, fh);\n        }\n    }\n}).as(exports, \"CustomConstraint\");\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/rule.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    isArray = extd.isArray,\n    Promise = extd.Promise,\n    declare = extd.declare,\n    isHash = extd.isHash,\n    isString = extd.isString,\n    format = extd.format,\n    parser = require(\"./parser\"),\n    pattern = require(\"./pattern\"),\n    ObjectPattern = pattern.ObjectPattern,\n    FromPattern = pattern.FromPattern,\n    NotPattern = pattern.NotPattern,\n    ExistsPattern = pattern.ExistsPattern,\n    FromNotPattern = pattern.FromNotPattern,\n    FromExistsPattern = pattern.FromExistsPattern,\n    CompositePattern = pattern.CompositePattern;\n\nvar parseConstraint = function (constraint) {\n    if (typeof constraint === 'function') {\n        // No parsing is needed for constraint functions\n        return constraint;\n    }\n    return parser.parseConstraint(constraint);\n};\n\nvar parseExtra = extd\n    .switcher()\n    .isUndefinedOrNull(function () {\n        return null;\n    })\n    .isLike(/^from +/, function (s) {\n        return {from: s.replace(/^from +/, \"\").replace(/^\\s*|\\s*$/g, \"\")};\n    })\n    .def(function (o) {\n        throw new Error(\"invalid rule constraint option \" + o);\n    })\n    .switcher();\n\nvar normailizeConstraint = extd\n    .switcher()\n    .isLength(1, function (c) {\n        throw new Error(\"invalid rule constraint \" + format(\"%j\", [c]));\n    })\n    .isLength(2, function (c) {\n        c.push(\"true\");\n        return c;\n    })\n    //handle case where c[2] is a hash rather than a constraint string\n    .isLength(3, function (c) {\n        if (isString(c[2]) && /^from +/.test(c[2])) {\n            var extra = c[2];\n            c.splice(2, 0, \"true\");\n            c[3] = null;\n            c[4] = parseExtra(extra);\n        } else if (isHash(c[2])) {\n            c.splice(2, 0, \"true\");\n        }\n        return c;\n    })\n    //handle case where c[3] is a from clause rather than a hash for references\n    .isLength(4, function (c) {\n        if (isString(c[3])) {\n            c.splice(3, 0, null);\n            c[4] = parseExtra(c[4]);\n        }\n        return c;\n    })\n    .def(function (c) {\n        if (c.length === 5) {\n            c[4] = parseExtra(c[4]);\n        }\n        return c;\n    })\n    .switcher();\n\nvar getParamType = function getParamType(type, scope) {\n    scope = scope || {};\n    var getParamTypeSwitch = extd\n        .switcher()\n        .isEq(\"string\", function () {\n            return String;\n        })\n        .isEq(\"date\", function () {\n            return Date;\n        })\n        .isEq(\"array\", function () {\n            return Array;\n        })\n        .isEq(\"boolean\", function () {\n            return Boolean;\n        })\n        .isEq(\"regexp\", function () {\n            return RegExp;\n        })\n        .isEq(\"number\", function () {\n            return Number;\n        })\n        .isEq(\"object\", function () {\n            return Object;\n        })\n        .isEq(\"hash\", function () {\n            return Object;\n        })\n        .def(function (param) {\n            throw new TypeError(\"invalid param type \" + param);\n        })\n        .switcher();\n\n    var _getParamType = extd\n        .switcher()\n        .isString(function (param) {\n            var t = scope[param];\n            if (!t) {\n                return getParamTypeSwitch(param.toLowerCase());\n            } else {\n                return t;\n            }\n        })\n        .isFunction(function (func) {\n            return func;\n        })\n        .deepEqual([], function () {\n            return Array;\n        })\n        .def(function (param) {\n            throw  new Error(\"invalid param type \" + param);\n        })\n        .switcher();\n\n    return _getParamType(type);\n};\n\nvar parsePattern = extd\n    .switcher()\n    .containsAt(\"or\", 0, function (condition) {\n        condition.shift();\n        return extd(condition).map(function (cond) {\n            cond.scope = condition.scope;\n            return parsePattern(cond);\n        }).flatten().value();\n    })\n    .containsAt(\"not\", 0, function (condition) {\n        condition.shift();\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromNotPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new NotPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    })\n    .containsAt(\"exists\", 0, function (condition) {\n        condition.shift();\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromExistsPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new ExistsPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    })\n    .def(function (condition) {\n        if (typeof condition === 'function') {\n            return [condition];\n        }\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new ObjectPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    }).switcher();\n\nvar Rule = declare({\n    instance: {\n        constructor: function (name, options, pattern, cb) {\n            this.name = name;\n            this.pattern = pattern;\n            this.cb = cb;\n            if (options.agendaGroup) {\n                this.agendaGroup = options.agendaGroup;\n                this.autoFocus = extd.isBoolean(options.autoFocus) ? options.autoFocus : false;\n            }\n            this.priority = options.priority || options.salience || 0;\n        },\n\n        fire: function (flow, match) {\n            var ret = new Promise(), cb = this.cb;\n            try {\n                if (cb.length === 3) {\n                    cb.call(flow, match.factHash, flow, ret.resolve);\n                } else {\n                    ret = cb.call(flow, match.factHash, flow);\n                }\n            } catch (e) {\n                ret.errback(e);\n            }\n            return ret;\n        }\n    }\n});\n\nfunction createRule(name, options, conditions, cb) {\n    if (isArray(options)) {\n        cb = conditions;\n        conditions = options;\n    } else {\n        options = options || {};\n    }\n    var isRules = extd.every(conditions, function (cond) {\n        return isArray(cond);\n    });\n    if (isRules && conditions.length === 1) {\n        conditions = conditions[0];\n        isRules = false;\n    }\n    var rules = [];\n    var scope = options.scope || {};\n    conditions.scope = scope;\n    if (isRules) {\n        var _mergePatterns = function (patt, i) {\n            if (!patterns[i]) {\n                patterns[i] = i === 0 ? [] : patterns[i - 1].slice();\n                //remove dup\n                if (i !== 0) {\n                    patterns[i].pop();\n                }\n                patterns[i].push(patt);\n            } else {\n                extd(patterns).forEach(function (p) {\n                    p.push(patt);\n                });\n            }\n\n        };\n        var l = conditions.length, patterns = [], condition;\n        for (var i = 0; i < l; i++) {\n            condition = conditions[i];\n            condition.scope = scope;\n            extd.forEach(parsePattern(condition), _mergePatterns);\n\n        }\n        rules = extd.map(patterns, function (patterns) {\n            var compPat = null;\n            for (var i = 0; i < patterns.length; i++) {\n                if (compPat === null) {\n                    compPat = new CompositePattern(patterns[i++], patterns[i]);\n                } else {\n                    compPat = new CompositePattern(compPat, patterns[i]);\n                }\n            }\n            return new Rule(name, options, compPat, cb);\n        });\n    } else {\n        rules = extd.map(parsePattern(conditions), function (cond) {\n            return new Rule(name, options, cond, cb);\n        });\n    }\n    return rules;\n}\n\nexports.createRule = createRule;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/pattern.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    isEmpty = extd.isEmpty,\n    merge = extd.merge,\n    forEach = extd.forEach,\n    declare = extd.declare,\n    constraintMatcher = require(\"./constraintMatcher\"),\n    constraint = require(\"./constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    FromConstraint = constraint.FromConstraint;\n\nvar id = 0;\nvar Pattern = declare({});\n\nvar ObjectPattern = Pattern.extend({\n    instance: {\n        constructor: function (type, alias, conditions, store, options) {\n            options = options || {};\n            this.id = id++;\n            this.type = type;\n            this.alias = alias;\n            this.conditions = conditions;\n            this.pattern = options.pattern;\n            var constraints = [new constraint.ObjectConstraint(type)];\n            var constrnts = constraintMatcher.toConstraints(conditions, merge({alias: alias}, options));\n            if (constrnts.length) {\n                constraints = constraints.concat(constrnts);\n            } else {\n                var cnstrnt = new constraint.TrueConstraint();\n                constraints.push(cnstrnt);\n            }\n            if (store && !isEmpty(store)) {\n                var atm = new constraint.HashConstraint(store);\n                constraints.push(atm);\n            }\n\n            forEach(constraints, function (constraint) {\n                constraint.set(\"alias\", alias);\n            });\n            this.constraints = constraints;\n        },\n\n        getSpecificity: function () {\n            var constraints = this.constraints, specificity = 0;\n            for (var i = 0, l = constraints.length; i < l; i++) {\n                if (constraints[i] instanceof EqualityConstraint) {\n                    specificity++;\n                }\n            }\n            return specificity;\n        },\n\n        hasConstraint: function (type) {\n            return extd.some(this.constraints, function (c) {\n                return c instanceof type;\n            });\n        },\n\n        hashCode: function () {\n            return [this.type, this.alias, extd.format(\"%j\", this.conditions)].join(\":\");\n        },\n\n        toString: function () {\n            return extd.format(\"%j\", this.constraints);\n        }\n    }\n}).as(exports, \"ObjectPattern\");\n\nvar FromPattern = ObjectPattern.extend({\n    instance: {\n        constructor: function (type, alias, conditions, store, from, options) {\n            this._super([type, alias, conditions, store, options]);\n            this.from = new FromConstraint(from, options);\n        },\n\n        hasConstraint: function (type) {\n            return extd.some(this.constraints, function (c) {\n                return c instanceof type;\n            });\n        },\n\n        getSpecificity: function () {\n            return this._super(arguments) + 1;\n        },\n\n        hashCode: function () {\n            return [this.type, this.alias, extd.format(\"%j\", this.conditions), this.from.from].join(\":\");\n        },\n\n        toString: function () {\n            return extd.format(\"%j from %s\", this.constraints, this.from.from);\n        }\n    }\n}).as(exports, \"FromPattern\");\n\n\nFromPattern.extend().as(exports, \"FromNotPattern\");\nObjectPattern.extend().as(exports, \"NotPattern\");\nObjectPattern.extend().as(exports, \"ExistsPattern\");\nFromPattern.extend().as(exports, \"FromExistsPattern\");\n\nPattern.extend({\n\n    instance: {\n        constructor: function (left, right) {\n            this.id = id++;\n            this.leftPattern = left;\n            this.rightPattern = right;\n        },\n\n        hashCode: function () {\n            return [this.leftPattern.hashCode(), this.rightPattern.hashCode()].join(\":\");\n        },\n\n        getSpecificity: function () {\n            return this.rightPattern.getSpecificity() + this.leftPattern.getSpecificity();\n        },\n\n        getters: {\n            constraints: function () {\n                return this.leftPattern.constraints.concat(this.rightPattern.constraints);\n            }\n        }\n    }\n\n}).as(exports, \"CompositePattern\");\n\n\nvar InitialFact = declare({\n    instance: {\n        constructor: function () {\n            this.id = id++;\n            this.recency = 0;\n        }\n    }\n}).as(exports, \"InitialFact\");\n\nObjectPattern.extend({\n    instance: {\n        constructor: function () {\n            this._super([InitialFact, \"__i__\", [], {}]);\n        },\n\n        assert: function () {\n            return true;\n        }\n    }\n}).as(exports, \"InitialFactPattern\");\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/compile/common.js":"/*jshint evil:true*/\n\"use strict\";\nvar extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    isString = extd.isString;\n\nexports.modifiers = [\"assert\", \"modify\", \"retract\", \"emit\", \"halt\", \"focus\", \"getFacts\"];\n\nvar createFunction = function (body, defined, scope, scopeNames, definedNames) {\n    var declares = [];\n    forEach(definedNames, function (i) {\n        if (body.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    forEach(scopeNames, function (i) {\n        if (body.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    body = [\"((function(){\", declares.join(\"\"), \"\\n\\treturn \", body, \"\\n})())\"].join(\"\");\n    try {\n        return eval(body);\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + body + \"\\n\" + e.message);\n    }\n};\n\nvar createDefined = (function () {\n\n    var _createDefined = function (action, defined, scope) {\n        if (isString(action)) {\n            var declares = [];\n            extd(defined).keys().forEach(function (i) {\n                if (action.indexOf(i) !== -1) {\n                    declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n                }\n            });\n\n            extd(scope).keys().forEach(function (i) {\n                if (action.indexOf(i) !== -1) {\n                    declares.push(\"var \" + i + \"= function(){var prop = scope.\" + i + \"; return __objToStr__.call(prop) === '[object Function]' ? prop.apply(void 0, arguments) : prop;};\");\n                }\n            });\n            if (declares.length) {\n                declares.unshift(\"var __objToStr__ = Object.prototype.toString;\");\n            }\n            action = [declares.join(\"\"), \"return \", action, \";\"].join(\"\");\n            action = new Function(\"defined\", \"scope\", action)(defined, scope);\n        }\n        var ret = action.hasOwnProperty(\"constructor\") && \"function\" === typeof action.constructor ? action.constructor : function (opts) {\n            opts = opts || {};\n            for (var i in opts) {\n                if (i in action) {\n                    this[i] = opts[i];\n                }\n            }\n        };\n        var proto = ret.prototype;\n        for (var i in action) {\n            proto[i] = action[i];\n        }\n        return ret;\n\n    };\n\n    return function (options, defined, scope) {\n        return _createDefined(options.properties, defined, scope);\n    };\n})();\n\nexports.createFunction = createFunction;\nexports.createDefined = createDefined;","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/compile/transpile.js":"var extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    indexOf = extd.indexOf,\n    merge = extd.merge,\n    isString = extd.isString,\n    modifiers = require(\"./common\").modifiers,\n    constraintMatcher = require(\"../constraintMatcher\"),\n    parser = require(\"../parser\");\n\nfunction definedToJs(options) {\n    /*jshint evil:true*/\n    options = isString(options) ? new Function(\"return \" + options + \";\")() : options;\n    var ret = [\"(function(){\"], value;\n\n    if (options.hasOwnProperty(\"constructor\") && \"function\" === typeof options.constructor) {\n        ret.push(\"var Defined = \" + options.constructor.toString() + \";\");\n    } else {\n        ret.push(\"var Defined = function(opts){ for(var i in opts){if(opts.hasOwnProperty(i)){this[i] = opts[i];}}};\");\n    }\n    ret.push(\"var proto = Defined.prototype;\");\n    for (var key in options) {\n        if (options.hasOwnProperty(key)) {\n            value = options[key];\n            ret.push(\"proto.\" + key + \" = \" + (extd.isFunction(value) ? value.toString() : extd.format(\"%j\", value)) + \";\");\n        }\n    }\n    ret.push(\"return Defined;\");\n    ret.push(\"}())\");\n    return ret.join(\"\");\n\n}\n\nfunction actionToJs(action, identifiers, defined, scope) {\n    var declares = [], usedVars = {};\n    forEach(identifiers, function (i) {\n        if (action.indexOf(i) !== -1) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= facts.\" + i + \";\");\n        }\n    });\n    extd(defined).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    extd(scope).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    extd(modifiers).forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            declares.push(\"var \" + i + \"= flow.\" + i + \";\");\n        }\n    });\n    var params = [\"facts\", 'flow'];\n    if (/next\\(.*\\)/.test(action)) {\n        params.push(\"next\");\n    }\n    action = declares.join(\"\") + action;\n    try {\n        return [\"function(\", params.join(\",\"), \"){\", action, \"}\"].join(\"\");\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + action + \"\\n\" + e.message);\n    }\n}\n\nfunction parseConstraintModifier(constraint, ret) {\n    if (constraint.length && extd.isString(constraint[0])) {\n        var modifier = constraint[0].match(\" *(from)\");\n        if (modifier) {\n            modifier = modifier[0];\n            switch (modifier) {\n            case \"from\":\n                ret.push(', \"', constraint.shift(), '\"');\n                break;\n            default:\n                throw new Error(\"Unrecognized modifier \" + modifier);\n            }\n        }\n    }\n}\n\nfunction parseConstraintHash(constraint, ret, identifiers) {\n    if (constraint.length && extd.isHash(constraint[0])) {\n        //ret of options\n        var refs = constraint.shift();\n        extd(refs).values().forEach(function (ident) {\n            if (indexOf(identifiers, ident) === -1) {\n                identifiers.push(ident);\n            }\n        });\n        ret.push(',' + extd.format('%j', [refs]));\n    }\n}\n\nfunction constraintsToJs(constraint, identifiers) {\n    constraint = constraint.slice(0);\n    var ret = [];\n    if (constraint[0] === \"or\") {\n        ret.push('[\"' + constraint.shift() + '\"');\n        ret.push(extd.map(constraint,function (c) {\n            return constraintsToJs(c, identifiers);\n        }).join(\",\") + \"]\");\n        return ret;\n    } else if (constraint[0] === \"not\" || constraint[0] === \"exists\") {\n        ret.push('\"', constraint.shift(), '\", ');\n    }\n    identifiers.push(constraint[1]);\n    ret.push(constraint[0], ', \"' + constraint[1].replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + '\"');\n    constraint.splice(0, 2);\n    if (constraint.length) {\n        //constraint\n        var c = constraint.shift();\n        if (extd.isString(c) && c) {\n            ret.push(',\"' + c.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\"), '\"');\n            forEach(constraintMatcher.getIdentifiers(parser.parseConstraint(c)), function (i) {\n                identifiers.push(i);\n            });\n        } else {\n            ret.push(',\"true\"');\n            constraint.unshift(c);\n        }\n    }\n    parseConstraintModifier(constraint, ret);\n    parseConstraintHash(constraint, ret, identifiers);\n    return '[' + ret.join(\"\") + ']';\n}\n\nexports.transpile = function (flowObj, options) {\n    options = options || {};\n    var ret = [];\n    ret.push(\"(function(){\");\n    ret.push(\"return function(options){\");\n    ret.push(\"options = options || {};\");\n    ret.push(\"var bind = function(scope, fn){return function(){return fn.apply(scope, arguments);};}, defined = {Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, scope = options.scope || {};\");\n    ret.push(\"var optDefined = options.defined || {}; for(var i in optDefined){defined[i] = optDefined[i];}\");\n    var defined = merge({Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, options.define || {});\n    if (typeof Buffer !== \"undefined\") {\n        defined.Buffer = Buffer;\n    }\n    var scope = merge({console: console}, options.scope);\n    ret.push([\"return nools.flow('\", options.name, \"', function(){\"].join(\"\"));\n    //add any defined classes in the parsed flowObj to defined\n    ret.push(extd(flowObj.define || []).map(function (defined) {\n        var name = defined.name;\n        defined[name] = {};\n        return [\"var\", name, \"= defined.\" + name, \"= this.addDefined('\" + name + \"',\", definedToJs(defined.properties) + \");\"].join(\" \");\n    }).value().join(\"\\n\"));\n    ret.push(extd(flowObj.scope || []).map(function (s) {\n        var name = s.name;\n        scope[name] = {};\n        return [\"var\", name, \"= scope.\" + name, \"= \", s.body, \";\"].join(\" \");\n    }).value().join(\"\\n\"));\n    ret.push(\"scope.console = console;\\n\");\n\n\n    ret.push(extd(flowObj.rules || []).map(function (rule) {\n        var identifiers = [], ret = [\"this.rule('\", rule.name.replace(/'/g, \"\\\\'\"), \"'\"], options = extd.merge(rule.options || {}, {scope: \"scope\"});\n        ret.push(\",\", extd.format(\"%j\", [options]).replace(/(:\"scope\")/, \":scope\"));\n        if (rule.constraints && !extd.isEmpty(rule.constraints)) {\n            ret.push(\", [\");\n            ret.push(extd(rule.constraints).map(function (c) {\n                return constraintsToJs(c, identifiers);\n            }).value().join(\",\"));\n            ret.push(\"]\");\n        }\n        ret.push(\",\", actionToJs(rule.action, identifiers, defined, scope));\n        ret.push(\");\");\n        return ret.join(\"\");\n    }).value().join(\"\"));\n    ret.push(\"});\");\n    ret.push(\"};\");\n    ret.push(\"}());\");\n    return ret.join(\"\");\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/flowContainer.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    instanceOf = extd.instanceOf,\n    forEach = extd.forEach,\n    declare = extd.declare,\n    InitialFact = require(\"./pattern\").InitialFact,\n    conflictStrategies = require(\"./conflict\"),\n    conflictResolution = conflictStrategies.strategy([\"salience\", \"activationRecency\"]),\n    rule = require(\"./rule\"),\n    Flow = require(\"./flow\");\n\nvar flows = {};\nvar FlowContainer = declare({\n\n    instance: {\n\n        constructor: function (name, cb) {\n            this.name = name;\n            this.cb = cb;\n            this.__rules = [];\n            this.__defined = {};\n            this.conflictResolutionStrategy = conflictResolution;\n            if (cb) {\n                cb.call(this, this);\n            }\n            if (!flows.hasOwnProperty(name)) {\n                flows[name] = this;\n            } else {\n                throw new Error(\"Flow with \" + name + \" already defined\");\n            }\n        },\n\n        conflictResolution: function (strategies) {\n            this.conflictResolutionStrategy = conflictStrategies.strategy(strategies);\n            return this;\n        },\n\n        getDefined: function (name) {\n            var ret = this.__defined[name.toLowerCase()];\n            if (!ret) {\n                throw new Error(name + \" flow class is not defined\");\n            }\n            return ret;\n        },\n\n        addDefined: function (name, cls) {\n            //normalize\n            this.__defined[name.toLowerCase()] = cls;\n            return cls;\n        },\n\n        rule: function () {\n            this.__rules = this.__rules.concat(rule.createRule.apply(rule, arguments));\n            return this;\n        },\n\n        getSession: function () {\n            var flow = new Flow(this.name, this.conflictResolutionStrategy);\n            forEach(this.__rules, function (rule) {\n                flow.rule(rule);\n            });\n            flow.assert(new InitialFact());\n            for (var i = 0, l = arguments.length; i < l; i++) {\n                flow.assert(arguments[i]);\n            }\n            return flow;\n        },\n\n        containsRule: function (name) {\n            return extd.some(this.__rules, function (rule) {\n                return rule.name === name;\n            });\n        }\n\n    },\n\n    \"static\": {\n        getFlow: function (name) {\n            return flows[name];\n        },\n\n        hasFlow: function (name) {\n            return extd.has(flows, name);\n        },\n\n        deleteFlow: function (name) {\n            if (instanceOf(name, FlowContainer)) {\n                name = name.name;\n            }\n            delete flows[name];\n            return FlowContainer;\n        },\n\n        deleteFlows: function () {\n            for (var name in flows) {\n                if (name in flows) {\n                    delete flows[name];\n                }\n            }\n            return FlowContainer;\n        },\n\n        create: function (name, cb) {\n            return new FlowContainer(name, cb);\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/conflict.js":"var map = require(\"./extended\").map;\n\nfunction salience(a, b) {\n    return a.rule.priority - b.rule.priority;\n}\n\nfunction bucketCounter(a, b) {\n    return a.counter - b.counter;\n}\n\nfunction factRecency(a, b) {\n    /*jshint noempty: false*/\n\n    var i = 0;\n    var aMatchRecency = a.match.recency,\n        bMatchRecency = b.match.recency, aLength = aMatchRecency.length - 1, bLength = bMatchRecency.length - 1;\n    while (aMatchRecency[i] === bMatchRecency[i] && i < aLength && i < bLength && i++) {\n    }\n    var ret = aMatchRecency[i] - bMatchRecency[i];\n    if (!ret) {\n        ret = aLength - bLength;\n    }\n    return ret;\n}\n\nfunction activationRecency(a, b) {\n    return a.recency - b.recency;\n}\n\nvar strategies = {\n    salience: salience,\n    bucketCounter: bucketCounter,\n    factRecency: factRecency,\n    activationRecency: activationRecency\n};\n\nexports.strategies = strategies;\nexports.strategy = function (strats) {\n    strats = map(strats, function (s) {\n        return strategies[s];\n    });\n    var stratsLength = strats.length;\n\n    return function (a, b) {\n        var i = -1, ret = 0;\n        var equal = (a === b) || (a.name === b.name && a.hashCode === b.hashCode);\n        if (!equal) {\n            while (++i < stratsLength && !ret) {\n                ret = strats[i](a, b);\n            }\n            ret = ret > 0 ? 1 : -1;\n        }\n        return ret;\n    };\n};","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/flow.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    bind = extd.bind,\n    declare = extd.declare,\n    nodes = require(\"./nodes\"),\n    EventEmitter = require(\"events\").EventEmitter,\n    wm = require(\"./workingMemory\"),\n    WorkingMemory = wm.WorkingMemory,\n    ExecutionStragegy = require(\"./executionStrategy\"),\n    AgendaTree = require(\"./agenda\");\n\nmodule.exports = declare(EventEmitter, {\n\n    instance: {\n\n        name: null,\n\n        executionStrategy: null,\n\n        constructor: function (name, conflictResolutionStrategy) {\n            this.env = null;\n            this.name = name;\n            this.__rules = {};\n            this.conflictResolutionStrategy = conflictResolutionStrategy;\n            this.workingMemory = new WorkingMemory();\n            this.agenda = new AgendaTree(this, conflictResolutionStrategy);\n            this.agenda.on(\"fire\", bind(this, \"emit\", \"fire\"));\n            this.agenda.on(\"focused\", bind(this, \"emit\", \"focused\"));\n            this.rootNode = new nodes.RootNode(this.workingMemory, this.agenda);\n            extd.bindAll(this, \"halt\", \"assert\", \"retract\", \"modify\", \"focus\",\n              \"emit\", \"getFacts\", \"getFact\");\n        },\n\n        getFacts: function (Type) {\n            var ret;\n            if (Type) {\n                ret = this.workingMemory.getFactsByType(Type);\n            } else {\n                ret = this.workingMemory.getFacts();\n            }\n            return ret;\n        },\n\n        getFact: function (Type) {\n            var ret;\n            if (Type) {\n                ret = this.workingMemory.getFactsByType(Type);\n            } else {\n                ret = this.workingMemory.getFacts();\n            }\n            return ret && ret[0];\n        },\n\n        focus: function (focused) {\n            this.agenda.setFocus(focused);\n            return this;\n        },\n\n        halt: function () {\n            this.executionStrategy.halt();\n            return this;\n        },\n\n        dispose: function () {\n            this.workingMemory.dispose();\n            this.agenda.dispose();\n            this.rootNode.dispose();\n        },\n\n        assert: function (fact) {\n            this.rootNode.assertFact(this.workingMemory.assertFact(fact));\n            this.emit(\"assert\", fact);\n            return fact;\n        },\n\n        // This method is called to remove an existing fact from working memory\n        retract: function (fact) {\n            //fact = this.workingMemory.getFact(fact);\n            this.rootNode.retractFact(this.workingMemory.retractFact(fact));\n            this.emit(\"retract\", fact);\n            return fact;\n        },\n\n        // This method is called to alter an existing fact.  It is essentially a\n        // retract followed by an assert.\n        modify: function (fact, cb) {\n            //fact = this.workingMemory.getFact(fact);\n            if (\"function\" === typeof cb) {\n                cb.call(fact, fact);\n            }\n            this.rootNode.modifyFact(this.workingMemory.modifyFact(fact));\n            this.emit(\"modify\", fact);\n            return fact;\n        },\n\n        print: function () {\n            this.rootNode.print();\n        },\n\n        containsRule: function (name) {\n            return this.rootNode.containsRule(name);\n        },\n\n        rule: function (rule) {\n            this.rootNode.assertRule(rule);\n        },\n\n        matchUntilHalt: function (cb) {\n            return (this.executionStrategy = new ExecutionStragegy(this, true)).execute().classic(cb).promise();\n        },\n\n        match: function (cb) {\n            return (this.executionStrategy = new ExecutionStragegy(this)).execute().classic(cb).promise();\n        }\n\n    }\n});","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/index.js":"\"use strict\";\nvar extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    some = extd.some,\n    declare = extd.declare,\n    pattern = require(\"../pattern.js\"),\n    ObjectPattern = pattern.ObjectPattern,\n    FromPattern = pattern.FromPattern,\n    FromNotPattern = pattern.FromNotPattern,\n    ExistsPattern = pattern.ExistsPattern,\n    FromExistsPattern = pattern.FromExistsPattern,\n    NotPattern = pattern.NotPattern,\n    CompositePattern = pattern.CompositePattern,\n    InitialFactPattern = pattern.InitialFactPattern,\n    constraints = require(\"../constraint\"),\n    HashConstraint = constraints.HashConstraint,\n    ReferenceConstraint = constraints.ReferenceConstraint,\n    AliasNode = require(\"./aliasNode\"),\n    EqualityNode = require(\"./equalityNode\"),\n    JoinNode = require(\"./joinNode\"),\n    BetaNode = require(\"./betaNode\"),\n    NotNode = require(\"./notNode\"),\n    FromNode = require(\"./fromNode\"),\n    FromNotNode = require(\"./fromNotNode\"),\n    ExistsNode = require(\"./existsNode\"),\n    ExistsFromNode = require(\"./existsFromNode\"),\n    LeftAdapterNode = require(\"./leftAdapterNode\"),\n    RightAdapterNode = require(\"./rightAdapterNode\"),\n    TypeNode = require(\"./typeNode\"),\n    TerminalNode = require(\"./terminalNode\"),\n    PropertyNode = require(\"./propertyNode\");\n\nfunction hasRefernceConstraints(pattern) {\n    return some(pattern.constraints || [], function (c) {\n        return c instanceof ReferenceConstraint;\n    });\n}\n\ndeclare({\n    instance: {\n        constructor: function (wm, agendaTree) {\n            this.terminalNodes = [];\n            this.joinNodes = [];\n            this.nodes = [];\n            this.constraints = [];\n            this.typeNodes = [];\n            this.__ruleCount = 0;\n            this.bucket = {\n                counter: 0,\n                recency: 0\n            };\n            this.agendaTree = agendaTree;\n            this.workingMemory = wm;\n        },\n\n        assertRule: function (rule) {\n            var terminalNode = new TerminalNode(this.bucket, this.__ruleCount++, rule, this.agendaTree);\n            this.__addToNetwork(rule, rule.pattern, terminalNode);\n            this.__mergeJoinNodes();\n            this.terminalNodes.push(terminalNode);\n        },\n\n        resetCounter: function () {\n            this.bucket.counter = 0;\n        },\n\n        incrementCounter: function () {\n            this.bucket.counter++;\n        },\n\n        assertFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].assert(fact);\n            }\n        },\n\n        retractFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].retract(fact);\n            }\n        },\n\n        modifyFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].modify(fact);\n            }\n        },\n\n\n        containsRule: function (name) {\n            return some(this.terminalNodes, function (n) {\n                return n.rule.name === name;\n            });\n        },\n\n        dispose: function () {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].dispose();\n            }\n        },\n\n        __mergeJoinNodes: function () {\n            var joinNodes = this.joinNodes;\n            for (var i = 0; i < joinNodes.length; i++) {\n                var j1 = joinNodes[i], j2 = joinNodes[i + 1];\n                if (j1 && j2 && (j1.constraint && j2.constraint && j1.constraint.equal(j2.constraint))) {\n                    j1.merge(j2);\n                    joinNodes.splice(i + 1, 1);\n                }\n            }\n        },\n\n        __checkEqual: function (node) {\n            var constraints = this.constraints, i = constraints.length - 1;\n            for (; i >= 0; i--) {\n                var n = constraints[i];\n                if (node.equal(n)) {\n                    return  n;\n                }\n            }\n            constraints.push(node);\n            return node;\n        },\n\n        __createTypeNode: function (rule, pattern) {\n            var ret = new TypeNode(pattern.get(\"constraints\")[0]);\n            var constraints = this.typeNodes, i = constraints.length - 1;\n            for (; i >= 0; i--) {\n                var n = constraints[i];\n                if (ret.equal(n)) {\n                    return  n;\n                }\n            }\n            constraints.push(ret);\n            return ret;\n        },\n\n        __createEqualityNode: function (rule, constraint) {\n            return this.__checkEqual(new EqualityNode(constraint)).addRule(rule);\n        },\n\n        __createPropertyNode: function (rule, constraint) {\n            return this.__checkEqual(new PropertyNode(constraint)).addRule(rule);\n        },\n\n        __createAliasNode: function (rule, pattern) {\n            return this.__checkEqual(new AliasNode(pattern)).addRule(rule);\n        },\n\n        __createAdapterNode: function (rule, side) {\n            return (side === \"left\" ? new LeftAdapterNode() : new RightAdapterNode()).addRule(rule);\n        },\n\n        __createJoinNode: function (rule, pattern, outNode, side) {\n            var joinNode;\n            if (pattern.rightPattern instanceof NotPattern) {\n                joinNode = new NotNode();\n            } else if (pattern.rightPattern instanceof FromExistsPattern) {\n                joinNode = new ExistsFromNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern.rightPattern instanceof ExistsPattern) {\n                joinNode = new ExistsNode();\n            } else if (pattern.rightPattern instanceof FromNotPattern) {\n                joinNode = new FromNotNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern.rightPattern instanceof FromPattern) {\n                joinNode = new FromNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern instanceof CompositePattern && !hasRefernceConstraints(pattern.leftPattern) && !hasRefernceConstraints(pattern.rightPattern)) {\n                joinNode = new BetaNode();\n                this.joinNodes.push(joinNode);\n            } else {\n                joinNode = new JoinNode();\n                this.joinNodes.push(joinNode);\n            }\n            joinNode[\"__rule__\"] = rule;\n            var parentNode = joinNode;\n            if (outNode instanceof BetaNode) {\n                var adapterNode = this.__createAdapterNode(rule, side);\n                parentNode.addOutNode(adapterNode, pattern);\n                parentNode = adapterNode;\n            }\n            parentNode.addOutNode(outNode, pattern);\n            return joinNode.addRule(rule);\n        },\n\n        __addToNetwork: function (rule, pattern, outNode, side) {\n            if (pattern instanceof ObjectPattern) {\n                if (!(pattern instanceof InitialFactPattern) && (!side || side === \"left\")) {\n                    this.__createBetaNode(rule, new CompositePattern(new InitialFactPattern(), pattern), outNode, side);\n                } else {\n                    this.__createAlphaNode(rule, pattern, outNode, side);\n                }\n            } else if (pattern instanceof CompositePattern) {\n                this.__createBetaNode(rule, pattern, outNode, side);\n            }\n        },\n\n        __createBetaNode: function (rule, pattern, outNode, side) {\n            var joinNode = this.__createJoinNode(rule, pattern, outNode, side);\n            this.__addToNetwork(rule, pattern.rightPattern, joinNode, \"right\");\n            this.__addToNetwork(rule, pattern.leftPattern, joinNode, \"left\");\n            outNode.addParentNode(joinNode);\n            return joinNode;\n        },\n\n\n        __createAlphaNode: function (rule, pattern, outNode, side) {\n            var typeNode, parentNode;\n            if (!(pattern instanceof FromPattern)) {\n\n                var constraints = pattern.get(\"constraints\");\n                typeNode = this.__createTypeNode(rule, pattern);\n                var aliasNode = this.__createAliasNode(rule, pattern);\n                typeNode.addOutNode(aliasNode, pattern);\n                aliasNode.addParentNode(typeNode);\n                parentNode = aliasNode;\n                var i = constraints.length - 1;\n                for (; i > 0; i--) {\n                    var constraint = constraints[i], node;\n                    if (constraint instanceof HashConstraint) {\n                        node = this.__createPropertyNode(rule, constraint);\n                    } else if (constraint instanceof ReferenceConstraint) {\n                        outNode.constraint.addConstraint(constraint);\n                        continue;\n                    } else {\n                        node = this.__createEqualityNode(rule, constraint);\n                    }\n                    parentNode.addOutNode(node, pattern);\n                    node.addParentNode(parentNode);\n                    parentNode = node;\n                }\n\n                if (outNode instanceof BetaNode) {\n                    var adapterNode = this.__createAdapterNode(rule, side);\n                    adapterNode.addParentNode(parentNode);\n                    parentNode.addOutNode(adapterNode, pattern);\n                    parentNode = adapterNode;\n                }\n                outNode.addParentNode(parentNode);\n                parentNode.addOutNode(outNode, pattern);\n                return typeNode;\n            }\n        },\n\n        print: function () {\n            forEach(this.terminalNodes, function (t) {\n                t.print(\"    \");\n            });\n        }\n    }\n}).as(exports, \"RootNode\");\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/aliasNode.js":"var AlphaNode = require(\"./alphaNode\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this._super(arguments);\n            this.alias = this.constraint.get(\"alias\");\n        },\n\n        toString: function () {\n            return \"AliasNode\" + this.__count;\n        },\n\n        assert: function (context) {\n            return this.__propagate(\"assert\", context.set(this.alias, context.fact.object));\n        },\n\n        modify: function (context) {\n            return this.__propagate(\"modify\", context.set(this.alias, context.fact.object));\n        },\n\n        retract: function (context) {\n            return this.__propagate(\"retract\", context.set(this.alias, context.fact.object));\n        },\n\n        equal: function (other) {\n            return other instanceof this._static && this.alias === other.alias;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/alphaNode.js":"\"use strict\";\nvar Node = require(\"./node\");\n\nNode.extend({\n    instance: {\n        constructor: function (constraint) {\n            this._super([]);\n            this.constraint = constraint;\n            this.constraintAssert = this.constraint.assert;\n        },\n\n        toString: function () {\n            return \"AlphaNode \" + this.__count;\n        },\n\n        equal: function (constraint) {\n            return this.constraint.equal(constraint.constraint);\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/node.js":"var extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    indexOf = extd.indexOf,\n    intersection = extd.intersection,\n    declare = extd.declare,\n    HashTable = extd.HashTable,\n    Context = require(\"../context\");\n\nvar count = 0;\ndeclare({\n    instance: {\n        constructor: function () {\n            this.nodes = new HashTable();\n            this.rules = [];\n            this.parentNodes = [];\n            this.__count = count++;\n            this.__entrySet = [];\n        },\n\n        addRule: function (rule) {\n            if (indexOf(this.rules, rule) === -1) {\n                this.rules.push(rule);\n            }\n            return this;\n        },\n\n        merge: function (that) {\n            that.nodes.forEach(function (entry) {\n                var patterns = entry.value, node = entry.key;\n                for (var i = 0, l = patterns.length; i < l; i++) {\n                    this.addOutNode(node, patterns[i]);\n                }\n                that.nodes.remove(node);\n            }, this);\n            var thatParentNodes = that.parentNodes;\n            for (var i = 0, l = that.parentNodes.l; i < l; i++) {\n                var parentNode = thatParentNodes[i];\n                this.addParentNode(parentNode);\n                parentNode.nodes.remove(that);\n            }\n            return this;\n        },\n\n        resolve: function (mr1, mr2) {\n            return mr1.hashCode === mr2.hashCode;\n        },\n\n        print: function (tab) {\n            console.log(tab + this.toString());\n            forEach(this.parentNodes, function (n) {\n                n.print(\"    \" + tab);\n            });\n        },\n\n        addOutNode: function (outNode, pattern) {\n            if (!this.nodes.contains(outNode)) {\n                this.nodes.put(outNode, []);\n            }\n            this.nodes.get(outNode).push(pattern);\n            this.__entrySet = this.nodes.entrySet();\n        },\n\n        addParentNode: function (n) {\n            if (indexOf(this.parentNodes, n) === -1) {\n                this.parentNodes.push(n);\n            }\n        },\n\n        shareable: function () {\n            return false;\n        },\n\n        __propagate: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode, paths, continuingPaths;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                paths = entry.value;\n\n                if ((continuingPaths = intersection(paths, context.paths)).length) {\n                    outNode[method](new Context(context.fact, continuingPaths, context.match));\n                }\n\n            }\n        },\n\n        dispose: function (assertable) {\n            this.propagateDispose(assertable);\n        },\n\n        retract: function (assertable) {\n            this.propagateRetract(assertable);\n        },\n\n        propagateDispose: function (assertable, outNodes) {\n            outNodes = outNodes || this.nodes;\n            var entrySet = this.__entrySet, i = entrySet.length - 1;\n            for (; i >= 0; i--) {\n                var entry = entrySet[i], outNode = entry.key;\n                outNode.dispose(assertable);\n            }\n        },\n\n        propagateAssert: function (assertable) {\n            this.__propagate(\"assert\", assertable);\n        },\n\n        propagateRetract: function (assertable) {\n            this.__propagate(\"retract\", assertable);\n        },\n\n        assert: function (assertable) {\n            this.propagateAssert(assertable);\n        },\n\n        modify: function (assertable) {\n            this.propagateModify(assertable);\n        },\n\n        propagateModify: function (assertable) {\n            this.__propagate(\"modify\", assertable);\n        }\n    }\n\n}).as(module);\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/context.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    isBoolean = extd.isBoolean,\n    declare = extd.declare,\n    indexOf = extd.indexOf,\n    pPush = Array.prototype.push;\n\nfunction createContextHash(paths, hashCode) {\n    var ret = \"\",\n        i = -1,\n        l = paths.length;\n    while (++i < l) {\n        ret += paths[i].id + \":\";\n    }\n    ret += hashCode;\n    return ret;\n}\n\nfunction merge(h1, h2, aliases) {\n    var i = -1, l = aliases.length, alias;\n    while (++i < l) {\n        alias = aliases[i];\n        h1[alias] = h2[alias];\n    }\n}\n\nfunction unionRecency(arr, arr1, arr2) {\n    pPush.apply(arr, arr1);\n    var i = -1, l = arr2.length, val, j = arr.length;\n    while (++i < l) {\n        val = arr2[i];\n        if (indexOf(arr, val) === -1) {\n            arr[j++] = val;\n        }\n    }\n}\n\nvar Match = declare({\n    instance: {\n\n        isMatch: true,\n        hashCode: \"\",\n        facts: null,\n        factIds: null,\n        factHash: null,\n        recency: null,\n        aliases: null,\n\n        constructor: function () {\n            this.facts = [];\n            this.factIds = [];\n            this.factHash = {};\n            this.recency = [];\n            this.aliases = [];\n        },\n\n        addFact: function (assertable) {\n            pPush.call(this.facts, assertable);\n            pPush.call(this.recency, assertable.recency);\n            pPush.call(this.factIds, assertable.id);\n            this.hashCode = this.factIds.join(\":\");\n            return this;\n        },\n\n        merge: function (mr) {\n            var ret = new Match();\n            ret.isMatch = mr.isMatch;\n            pPush.apply(ret.facts, this.facts);\n            pPush.apply(ret.facts, mr.facts);\n            pPush.apply(ret.aliases, this.aliases);\n            pPush.apply(ret.aliases, mr.aliases);\n            ret.hashCode = this.hashCode + \":\" + mr.hashCode;\n            merge(ret.factHash, this.factHash, this.aliases);\n            merge(ret.factHash, mr.factHash, mr.aliases);\n            unionRecency(ret.recency, this.recency, mr.recency);\n            return ret;\n        }\n    }\n});\n\nvar Context = declare({\n    instance: {\n        match: null,\n        factHash: null,\n        aliases: null,\n        fact: null,\n        hashCode: null,\n        paths: null,\n        pathsHash: null,\n\n        constructor: function (fact, paths, mr) {\n            this.fact = fact;\n            if (mr) {\n                this.match = mr;\n            } else {\n                this.match = new Match().addFact(fact);\n            }\n            this.factHash = this.match.factHash;\n            this.aliases = this.match.aliases;\n            this.hashCode = this.match.hashCode;\n            if (paths) {\n                this.paths = paths;\n                this.pathsHash = createContextHash(paths, this.hashCode);\n            } else {\n                this.pathsHash = this.hashCode;\n            }\n        },\n\n        \"set\": function (key, value) {\n            this.factHash[key] = value;\n            this.aliases.push(key);\n            return this;\n        },\n\n        isMatch: function (isMatch) {\n            if (isBoolean(isMatch)) {\n                this.match.isMatch = isMatch;\n            } else {\n                return this.match.isMatch;\n            }\n            return this;\n        },\n\n        mergeMatch: function (merge) {\n            var match = this.match = this.match.merge(merge);\n            this.factHash = match.factHash;\n            this.hashCode = match.hashCode;\n            this.aliases = match.aliases;\n            return this;\n        },\n\n        clone: function (fact, paths, match) {\n            return new Context(fact || this.fact, paths || this.path, match || this.match);\n        }\n    }\n}).as(module);\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/equalityNode.js":"var AlphaNode = require(\"./alphaNode\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this.memory = {};\n            this._super(arguments);\n            this.constraintAssert = this.constraint.assert;\n        },\n\n        assert: function (context) {\n            if ((this.memory[context.pathsHash] = this.constraintAssert(context.factHash))) {\n                this.__propagate(\"assert\", context);\n            }\n        },\n\n        modify: function (context) {\n            var memory = this.memory,\n                hashCode = context.pathsHash,\n                wasMatch = memory[hashCode];\n            if ((memory[hashCode] = this.constraintAssert(context.factHash))) {\n                this.__propagate(wasMatch ? \"modify\" : \"assert\", context);\n            } else if (wasMatch) {\n                this.__propagate(\"retract\", context);\n            }\n        },\n\n        retract: function (context) {\n            var hashCode = context.pathsHash,\n                memory = this.memory;\n            if (memory[hashCode]) {\n                this.__propagate(\"retract\", context);\n            }\n            delete memory[hashCode];\n        },\n\n        toString: function () {\n            return \"EqualityNode\" + this.__count;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/joinNode.js":"var BetaNode = require(\"./betaNode\"),\n    JoinReferenceNode = require(\"./joinReferenceNode\");\n\nBetaNode.extend({\n\n    instance: {\n        constructor: function () {\n            this._super(arguments);\n            this.constraint = new JoinReferenceNode(this.leftTuples, this.rightTuples);\n        },\n\n        nodeType: \"JoinNode\",\n\n        propagateFromLeft: function (context, rm) {\n            var mr;\n            if ((mr = this.constraint.match(context, rm)).isMatch) {\n                this.__propagate(\"assert\", this.__addToMemoryMatches(rm, context, context.clone(null, null, mr)));\n            }\n            return this;\n        },\n\n        propagateFromRight: function (context, lm) {\n            var mr;\n            if ((mr = this.constraint.match(lm, context)).isMatch) {\n                this.__propagate(\"assert\", this.__addToMemoryMatches(context, lm, context.clone(null, null, mr)));\n            }\n            return this;\n        },\n\n        propagateAssertModifyFromLeft: function (context, rightMatches, rm) {\n            var factId = rm.hashCode, mr;\n            if (factId in rightMatches) {\n                mr = this.constraint.match(context, rm);\n                var mrIsMatch = mr.isMatch;\n                if (!mrIsMatch) {\n                    this.__propagate(\"retract\", rightMatches[factId].clone());\n                } else {\n                    this.__propagate(\"modify\", this.__addToMemoryMatches(rm, context, context.clone(null, null, mr)));\n                }\n            } else {\n                this.propagateFromLeft(context, rm);\n            }\n        },\n\n        propagateAssertModifyFromRight: function (context, leftMatches, lm) {\n            var factId = lm.hashCode, mr;\n            if (factId in leftMatches) {\n                mr = this.constraint.match(lm, context);\n                var mrIsMatch = mr.isMatch;\n                if (!mrIsMatch) {\n                    this.__propagate(\"retract\", leftMatches[factId].clone());\n                } else {\n                    this.__propagate(\"modify\", this.__addToMemoryMatches(context, lm, context.clone(null, null, mr)));\n                }\n            } else {\n                this.propagateFromRight(context, lm);\n            }\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/betaNode.js":"var extd = require(\"../extended\"),\n    keys = extd.hash.keys,\n    Node = require(\"./node\"),\n    LeftMemory = require(\"./misc/leftMemory\"), RightMemory = require(\"./misc/rightMemory\");\n\nNode.extend({\n\n    instance: {\n\n        nodeType: \"BetaNode\",\n\n        constructor: function () {\n            this._super([]);\n            this.leftMemory = {};\n            this.rightMemory = {};\n            this.leftTuples = new LeftMemory();\n            this.rightTuples = new RightMemory();\n        },\n\n        __propagate: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                outNode[method](context);\n            }\n        },\n\n        dispose: function () {\n            this.leftMemory = {};\n            this.rightMemory = {};\n            this.leftTuples.clear();\n            this.rightTuples.clear();\n        },\n\n        disposeLeft: function (fact) {\n            this.leftMemory = {};\n            this.leftTuples.clear();\n            this.propagateDispose(fact);\n        },\n\n        disposeRight: function (fact) {\n            this.rightMemory = {};\n            this.rightTuples.clear();\n            this.propagateDispose(fact);\n        },\n\n        hashCode: function () {\n            return  this.nodeType + \" \" + this.__count;\n        },\n\n        toString: function () {\n            return this.nodeType + \" \" + this.__count;\n        },\n\n        retractLeft: function (context) {\n            context = this.removeFromLeftMemory(context).data;\n            var rightMatches = context.rightMatches,\n                hashCodes = keys(rightMatches),\n                i = -1,\n                l = hashCodes.length;\n            while (++i < l) {\n                this.__propagate(\"retract\", rightMatches[hashCodes[i]].clone());\n            }\n        },\n\n        retractRight: function (context) {\n            context = this.removeFromRightMemory(context).data;\n            var leftMatches = context.leftMatches,\n                hashCodes = keys(leftMatches),\n                i = -1,\n                l = hashCodes.length;\n            while (++i < l) {\n                this.__propagate(\"retract\", leftMatches[hashCodes[i]].clone());\n            }\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            var rm = this.rightTuples.getRightMemory(context), i = -1, l = rm.length;\n            while (++i < l) {\n                this.propagateFromLeft(context, rm[i].data);\n            }\n        },\n\n        assertRight: function (context) {\n            this.__addToRightMemory(context);\n            var lm = this.leftTuples.getLeftMemory(context), i = -1, l = lm.length;\n            while (++i < l) {\n                this.propagateFromRight(context, lm[i].data);\n            }\n        },\n\n        modifyLeft: function (context) {\n            var previousContext = this.removeFromLeftMemory(context).data;\n            this.__addToLeftMemory(context);\n            var rm = this.rightTuples.getRightMemory(context), l = rm.length, i = -1, rightMatches;\n            if (!l) {\n                this.propagateRetractModifyFromLeft(previousContext);\n            } else {\n                rightMatches = previousContext.rightMatches;\n                while (++i < l) {\n                    this.propagateAssertModifyFromLeft(context, rightMatches, rm[i].data);\n                }\n\n            }\n        },\n\n        modifyRight: function (context) {\n            var previousContext = this.removeFromRightMemory(context).data;\n            this.__addToRightMemory(context);\n            var lm = this.leftTuples.getLeftMemory(context);\n            if (!lm.length) {\n                this.propagateRetractModifyFromRight(previousContext);\n            } else {\n                var leftMatches = previousContext.leftMatches, i = -1, l = lm.length;\n                while (++i < l) {\n                    this.propagateAssertModifyFromRight(context, leftMatches, lm[i].data);\n                }\n            }\n        },\n\n        propagateFromLeft: function (context, rc) {\n            this.__propagate(\"assert\", this.__addToMemoryMatches(rc, context, context.clone(null, null, context.match.merge(rc.match))));\n        },\n\n        propagateFromRight: function (context, lc) {\n            this.__propagate(\"assert\", this.__addToMemoryMatches(context, lc, lc.clone(null, null, lc.match.merge(context.match))));\n        },\n\n        propagateRetractModifyFromLeft: function (context) {\n            var rightMatches = context.rightMatches,\n                hashCodes = keys(rightMatches),\n                l = hashCodes.length,\n                i = -1;\n            while (++i < l) {\n                this.__propagate(\"retract\", rightMatches[hashCodes[i]].clone());\n            }\n        },\n\n        propagateRetractModifyFromRight: function (context) {\n            var leftMatches = context.leftMatches,\n                hashCodes = keys(leftMatches),\n                l = hashCodes.length,\n                i = -1;\n            while (++i < l) {\n                this.__propagate(\"retract\", leftMatches[hashCodes[i]].clone());\n            }\n        },\n\n        propagateAssertModifyFromLeft: function (context, rightMatches, rm) {\n            var factId = rm.hashCode;\n            if (factId in rightMatches) {\n                this.__propagate(\"modify\", this.__addToMemoryMatches(rm, context, context.clone(null, null, context.match.merge(rm.match))));\n            } else {\n                this.propagateFromLeft(context, rm);\n            }\n        },\n\n        propagateAssertModifyFromRight: function (context, leftMatches, lm) {\n            var factId = lm.hashCode;\n            if (factId in leftMatches) {\n                this.__propagate(\"modify\", this.__addToMemoryMatches(context, lm, context.clone(null, null, lm.match.merge(context.match))));\n            } else {\n                this.propagateFromRight(context, lm);\n            }\n        },\n\n        removeFromRightMemory: function (context) {\n            var hashCode = context.hashCode, ret;\n            context = this.rightMemory[hashCode] || null;\n            var tuples = this.rightTuples;\n            if (context) {\n                var leftMemory = this.leftMemory;\n                ret = context.data;\n                var leftMatches = ret.leftMatches;\n                tuples.remove(context);\n                var hashCodes = keys(leftMatches), i = -1, l = hashCodes.length;\n                while (++i < l) {\n                    delete leftMemory[hashCodes[i]].data.rightMatches[hashCode];\n                }\n                delete this.rightMemory[hashCode];\n            }\n            return context;\n        },\n\n        removeFromLeftMemory: function (context) {\n            var hashCode = context.hashCode;\n            context = this.leftMemory[hashCode] || null;\n            if (context) {\n                var rightMemory = this.rightMemory;\n                var rightMatches = context.data.rightMatches;\n                this.leftTuples.remove(context);\n                var hashCodes = keys(rightMatches), i = -1, l = hashCodes.length;\n                while (++i < l) {\n                    delete rightMemory[hashCodes[i]].data.leftMatches[hashCode];\n                }\n                delete this.leftMemory[hashCode];\n            }\n            return context;\n        },\n\n        getRightMemoryMatches: function (context) {\n            var lm = this.leftMemory[context.hashCode], ret = {};\n            if (lm) {\n                ret = lm.rightMatches;\n            }\n            return ret;\n        },\n\n        __addToMemoryMatches: function (rightContext, leftContext, createdContext) {\n            var rightFactId = rightContext.hashCode,\n                rm = this.rightMemory[rightFactId],\n                lm, leftFactId = leftContext.hashCode;\n            if (rm) {\n                rm = rm.data;\n                if (leftFactId in rm.leftMatches) {\n                    throw new Error(\"Duplicate left fact entry\");\n                }\n                rm.leftMatches[leftFactId] = createdContext;\n            }\n            lm = this.leftMemory[leftFactId];\n            if (lm) {\n                lm = lm.data;\n                if (rightFactId in lm.rightMatches) {\n                    throw new Error(\"Duplicate right fact entry\");\n                }\n                lm.rightMatches[rightFactId] = createdContext;\n            }\n            return createdContext;\n        },\n\n        __addToRightMemory: function (context) {\n            var hashCode = context.hashCode, rm = this.rightMemory;\n            if (hashCode in rm) {\n                return false;\n            }\n            rm[hashCode] = this.rightTuples.push(context);\n            context.leftMatches = {};\n            return true;\n        },\n\n\n        __addToLeftMemory: function (context) {\n            var hashCode = context.hashCode, lm = this.leftMemory;\n            if (hashCode in lm) {\n                return false;\n            }\n            lm[hashCode] = this.leftTuples.push(context);\n            context.rightMatches = {};\n            return true;\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/leftMemory.js":"var Memory = require(\"./memory\");\n\nMemory.extend({\n\n    instance: {\n\n        getLeftMemory: function (tuple) {\n            return this.getMemory(tuple);\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/memory.js":"var extd = require(\"../../extended\"),\n    plucker = extd.plucker,\n    declare = extd.declare,\n    getMemory = require(\"./helpers\").getMemory,\n    Table = require(\"./table\"),\n    TupleEntry = require(\"./tupleEntry\");\n\n\nvar id = 0;\ndeclare({\n\n    instance: {\n        length: 0,\n\n        constructor: function () {\n            this.head = null;\n            this.tail = null;\n            this.indexes = [];\n            this.tables = new TupleEntry(null, new Table(), false);\n        },\n\n        push: function (data) {\n            var tail = this.tail, head = this.head, node = {data: data, tuples: [], hashCode: id++, prev: tail, next: null};\n            if (tail) {\n                this.tail.next = node;\n            }\n            this.tail = node;\n            if (!head) {\n                this.head = node;\n            }\n            this.length++;\n            this.__index(node);\n            this.tables.addNode(node);\n            return node;\n        },\n\n        remove: function (node) {\n            if (node.prev) {\n                node.prev.next = node.next;\n            } else {\n                this.head = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            } else {\n                this.tail = node.prev;\n            }\n            this.tables.removeNode(node);\n            this.__removeFromIndex(node);\n            this.length--;\n        },\n\n        forEach: function (cb) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                cb(head.data);\n            }\n        },\n\n        toArray: function () {\n            return this.tables.tuples.slice();\n        },\n\n        clear: function () {\n            this.head = this.tail = null;\n            this.length = 0;\n            this.clearIndexes();\n        },\n\n        clearIndexes: function () {\n            this.tables = {};\n            this.indexes.length = 0;\n        },\n\n        __index: function (node) {\n            var data = node.data,\n                factHash = data.factHash,\n                indexes = this.indexes,\n                entry = this.tables,\n                i = -1, l = indexes.length,\n                tuples, index, val, path, tables, currEntry, prevLookup;\n            while (++i < l) {\n                index = indexes[i];\n                val = index[2](factHash);\n                path = index[0];\n                tables = entry.tables;\n                if (!(tuples = (currEntry = tables[path] || (tables[path] = new Table())).get(val))) {\n                    tuples = new TupleEntry(val, currEntry, true);\n                    currEntry.set(val, tuples);\n                }\n                if (currEntry !== prevLookup) {\n                    node.tuples.push(tuples.addNode(node));\n                }\n                prevLookup = currEntry;\n                if (index[4] === \"eq\") {\n                    entry = tuples;\n                }\n            }\n        },\n\n        __removeFromIndex: function (node) {\n            var tuples = node.tuples, i = tuples.length;\n            while (--i >= 0) {\n                tuples[i].removeNode(node);\n            }\n            node.tuples.length = 0;\n        },\n\n        getMemory: function (tuple) {\n            var ret;\n            if (!this.length) {\n                ret = [];\n            } else {\n                ret = getMemory(this.tables, tuple.factHash, this.indexes);\n            }\n            return ret;\n        },\n\n        __createIndexTree: function () {\n            var table = this.tables.tables = {};\n            var indexes = this.indexes;\n            table[indexes[0][0]] = new Table();\n        },\n\n\n        addIndex: function (primary, lookup, op) {\n            this.indexes.push([primary, lookup, plucker(primary), plucker(lookup), op || \"eq\"]);\n            this.indexes.sort(function (a, b) {\n                var aOp = a[4], bOp = b[4];\n                return aOp === bOp ? 0 : aOp > bOp ? 1 : aOp === bOp ? 0 : -1;\n            });\n            this.__createIndexTree();\n\n        }\n\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/helpers.js":"exports.getMemory = (function () {\n\n    var pPush = Array.prototype.push, NPL = 0, EMPTY_ARRAY = [], NOT_POSSIBLES_HASH = {}, POSSIBLES_HASH = {}, PL = 0;\n\n    function mergePossibleTuples(ret, a, l) {\n        var val, j = 0, i = -1;\n        if (PL < l) {\n            while (PL && ++i < l) {\n                if (POSSIBLES_HASH[(val = a[i]).hashCode]) {\n                    ret[j++] = val;\n                    PL--;\n                }\n            }\n        } else {\n            pPush.apply(ret, a);\n        }\n        PL = 0;\n        POSSIBLES_HASH = {};\n    }\n\n\n    function mergeNotPossibleTuples(ret, a, l) {\n        var val, j = 0, i = -1;\n        if (NPL < l) {\n            while (++i < l) {\n                if (!NPL) {\n                    ret[j++] = a[i];\n                } else if (!NOT_POSSIBLES_HASH[(val = a[i]).hashCode]) {\n                    ret[j++] = val;\n                } else {\n                    NPL--;\n                }\n            }\n        }\n        NPL = 0;\n        NOT_POSSIBLES_HASH = {};\n    }\n\n    function mergeBothTuples(ret, a, l) {\n        if (PL === l) {\n            mergeNotPossibles(ret, a, l);\n        } else if (NPL < l) {\n            var val, j = 0, i = -1, hashCode;\n            while (++i < l) {\n                if (!NOT_POSSIBLES_HASH[(hashCode = (val = a[i]).hashCode)] && POSSIBLES_HASH[hashCode]) {\n                    ret[j++] = val;\n                }\n            }\n        }\n        NPL = 0;\n        NOT_POSSIBLES_HASH = {};\n        PL = 0;\n        POSSIBLES_HASH = {};\n    }\n\n    function mergePossiblesAndNotPossibles(a, l) {\n        var ret = EMPTY_ARRAY;\n        if (l) {\n            if (NPL || PL) {\n                ret = [];\n                if (!NPL) {\n                    mergePossibleTuples(ret, a, l);\n                } else if (!PL) {\n                    mergeNotPossibleTuples(ret, a, l);\n                } else {\n                    mergeBothTuples(ret, a, l);\n                }\n            } else {\n                ret = a;\n            }\n        }\n        return ret;\n    }\n\n    function getRangeTuples(op, currEntry, val) {\n        var ret;\n        if (op === \"gt\") {\n            ret = currEntry.findGT(val);\n        } else if (op === \"gte\") {\n            ret = currEntry.findGTE(val);\n        } else if (op === \"lt\") {\n            ret = currEntry.findLT(val);\n        } else if (op === \"lte\") {\n            ret = currEntry.findLTE(val);\n        }\n        return ret;\n    }\n\n    function mergeNotPossibles(tuples, tl) {\n        if (tl) {\n            var j = -1, hashCode;\n            while (++j < tl) {\n                hashCode = tuples[j].hashCode;\n                if (!NOT_POSSIBLES_HASH[hashCode]) {\n                    NOT_POSSIBLES_HASH[hashCode] = true;\n                    NPL++;\n                }\n            }\n        }\n    }\n\n    function mergePossibles(tuples, tl) {\n        if (tl) {\n            var j = -1, hashCode;\n            while (++j < tl) {\n                hashCode = tuples[j].hashCode;\n                if (!POSSIBLES_HASH[hashCode]) {\n                    POSSIBLES_HASH[hashCode] = true;\n                    PL++;\n                }\n            }\n        }\n    }\n\n    return function _getMemory(entry, factHash, indexes) {\n        var i = -1, l = indexes.length,\n            ret = entry.tuples,\n            rl = ret.length,\n            intersected = false,\n            tables = entry.tables,\n            index, val, op, nextEntry, currEntry, tuples, tl;\n        while (++i < l && rl) {\n            index = indexes[i];\n            val = index[3](factHash);\n            op = index[4];\n            currEntry = tables[index[0]];\n            if (op === \"eq\" || op === \"seq\") {\n                if ((nextEntry = currEntry.get(val))) {\n                    rl = (ret = (entry = nextEntry).tuples).length;\n                    tables = nextEntry.tables;\n                } else {\n                    rl = (ret = EMPTY_ARRAY).length;\n                }\n            } else if (op === \"neq\" || op === \"sneq\") {\n                if ((nextEntry = currEntry.get(val))) {\n                    tl = (tuples = nextEntry.tuples).length;\n                    mergeNotPossibles(tuples, tl);\n                }\n            } else if (!intersected) {\n                rl = (ret = getRangeTuples(op, currEntry, val)).length;\n                intersected = true;\n            } else if ((tl = (tuples = getRangeTuples(op, currEntry, val)).length)) {\n                mergePossibles(tuples, tl);\n            } else {\n                ret = tuples;\n                rl = tl;\n            }\n        }\n        return mergePossiblesAndNotPossibles(ret, rl);\n    };\n}());","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/table.js":"var extd = require(\"../../extended\"),\n    pPush = Array.prototype.push,\n    HashTable = extd.HashTable,\n    AVLTree = extd.AVLTree;\n\nfunction compare(a, b) {\n    /*jshint eqeqeq: false*/\n    a = a.key;\n    b = b.key;\n    var ret;\n    if (a == b) {\n        ret = 0;\n    } else if (a > b) {\n        ret = 1;\n    } else if (a < b) {\n        ret = -1;\n    } else {\n        ret = 1;\n    }\n    return ret;\n}\n\nfunction compareGT(v1, v2) {\n    return compare(v1, v2) === 1;\n}\nfunction compareGTE(v1, v2) {\n    return compare(v1, v2) !== -1;\n}\n\nfunction compareLT(v1, v2) {\n    return compare(v1, v2) === -1;\n}\nfunction compareLTE(v1, v2) {\n    return compare(v1, v2) !== 1;\n}\n\nvar STACK = [],\n    VALUE = {key: null};\nfunction traverseInOrder(tree, key, comparator) {\n    VALUE.key = key;\n    var ret = [];\n    var i = 0, current = tree.__root, v;\n    while (true) {\n        if (current) {\n            current = (STACK[i++] = current).left;\n        } else {\n            if (i > 0) {\n                v = (current = STACK[--i]).data;\n                if (comparator(v, VALUE)) {\n                    pPush.apply(ret, v.value.tuples);\n                    current = current.right;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    STACK.length = 0;\n    return ret;\n}\n\nfunction traverseReverseOrder(tree, key, comparator) {\n    VALUE.key = key;\n    var ret = [];\n    var i = 0, current = tree.__root, v;\n    while (true) {\n        if (current) {\n            current = (STACK[i++] = current).right;\n        } else {\n            if (i > 0) {\n                v = (current = STACK[--i]).data;\n                if (comparator(v, VALUE)) {\n                    pPush.apply(ret, v.value.tuples);\n                    current = current.left;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    STACK.length = 0;\n    return ret;\n}\n\nAVLTree.extend({\n    instance: {\n\n        constructor: function () {\n            this._super([\n                {\n                    compare: compare\n                }\n            ]);\n            this.gtCache = new HashTable();\n            this.gteCache = new HashTable();\n            this.ltCache = new HashTable();\n            this.lteCache = new HashTable();\n            this.hasGTCache = false;\n            this.hasGTECache = false;\n            this.hasLTCache = false;\n            this.hasLTECache = false;\n        },\n\n        clearCache: function () {\n            this.hasGTCache && this.gtCache.clear() && (this.hasGTCache = false);\n            this.hasGTECache && this.gteCache.clear() && (this.hasGTECache = false);\n            this.hasLTCache && this.ltCache.clear() && (this.hasLTCache = false);\n            this.hasLTECache && this.lteCache.clear() && (this.hasLTECache = false);\n        },\n\n        contains: function (key) {\n            return  this._super([\n                {key: key}\n            ]);\n        },\n\n        \"set\": function (key, value) {\n            this.insert({key: key, value: value});\n            this.clearCache();\n        },\n\n        \"get\": function (key) {\n            var ret = this.find({key: key});\n            return ret && ret.value;\n        },\n\n        \"remove\": function (key) {\n            this.clearCache();\n            return this._super([\n                {key: key}\n            ]);\n        },\n\n        findGT: function (key) {\n            var ret = this.gtCache.get(key);\n            if (!ret) {\n                this.hasGTCache = true;\n                this.gtCache.put(key, (ret = traverseReverseOrder(this, key, compareGT)));\n            }\n            return ret;\n        },\n\n        findGTE: function (key) {\n            var ret = this.gteCache.get(key);\n            if (!ret) {\n                this.hasGTECache = true;\n                this.gteCache.put(key, (ret = traverseReverseOrder(this, key, compareGTE)));\n            }\n            return ret;\n        },\n\n        findLT: function (key) {\n            var ret = this.ltCache.get(key);\n            if (!ret) {\n                this.hasLTCache = true;\n                this.ltCache.put(key, (ret = traverseInOrder(this, key, compareLT)));\n            }\n            return ret;\n        },\n\n        findLTE: function (key) {\n            var ret = this.lteCache.get(key);\n            if (!ret) {\n                this.hasLTECache = true;\n                this.lteCache.put(key, (ret = traverseInOrder(this, key, compareLTE)));\n            }\n            return ret;\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/tupleEntry.js":"var extd = require(\"../../extended\"),\n    indexOf = extd.indexOf;\n//    HashSet = require(\"./hashSet\");\n\n\nvar TUPLE_ID = 0;\nextd.declare({\n\n    instance: {\n        tuples: null,\n        tupleMap: null,\n        hashCode: null,\n        tables: null,\n        entry: null,\n        constructor: function (val, entry, canRemove) {\n            this.val = val;\n            this.canRemove = canRemove;\n            this.tuples = [];\n            this.tupleMap = {};\n            this.hashCode = TUPLE_ID++;\n            this.tables = {};\n            this.length = 0;\n            this.entry = entry;\n        },\n\n        addNode: function (node) {\n            this.tuples[this.length++] = node;\n            if (this.length > 1) {\n                this.entry.clearCache();\n            }\n            return this;\n        },\n\n        removeNode: function (node) {\n            var tuples = this.tuples, index = indexOf(tuples, node);\n            if (index !== -1) {\n                tuples.splice(index, 1);\n                this.length--;\n                this.entry.clearCache();\n            }\n            if (this.canRemove && !this.length) {\n                this.entry.remove(this.val);\n            }\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/rightMemory.js":"var Memory = require(\"./memory\");\n\nMemory.extend({\n\n    instance: {\n\n        getRightMemory: function (tuple) {\n            return this.getMemory(tuple);\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/joinReferenceNode.js":"var Node = require(\"./node\"),\n    constraints = require(\"../constraint\"),\n    ReferenceEqualityConstraint = constraints.ReferenceEqualityConstraint;\n\nvar DEFUALT_CONSTRAINT = {\n    isDefault: true,\n    assert: function () {\n        return true;\n    },\n\n    equal: function () {\n        return false;\n    }\n};\n\nvar inversions = {\n    \"gt\": \"lte\",\n    \"gte\": \"lte\",\n    \"lt\": \"gte\",\n    \"lte\": \"gte\",\n    \"eq\": \"eq\",\n    \"neq\": \"neq\"\n};\n\nfunction normalizeRightIndexConstraint(rightIndex, indexes, op) {\n    if (rightIndex === indexes[1]) {\n        op = inversions[op];\n    }\n    return op;\n}\n\nfunction normalizeLeftIndexConstraint(leftIndex, indexes, op) {\n    if (leftIndex === indexes[1]) {\n        op = inversions[op];\n    }\n    return op;\n}\n\nNode.extend({\n\n    instance: {\n\n        constraint: DEFUALT_CONSTRAINT,\n\n        constructor: function (leftMemory, rightMemory) {\n            this._super(arguments);\n            this.constraint = DEFUALT_CONSTRAINT;\n            this.constraintAssert = DEFUALT_CONSTRAINT.assert;\n            this.rightIndexes = [];\n            this.leftIndexes = [];\n            this.constraintLength = 0;\n            this.leftMemory = leftMemory;\n            this.rightMemory = rightMemory;\n        },\n\n        addConstraint: function (constraint) {\n            if (constraint instanceof ReferenceEqualityConstraint) {\n                var identifiers = constraint.getIndexableProperties();\n                var alias = constraint.get(\"alias\");\n                if (identifiers.length === 2 && alias) {\n                    var leftIndex, rightIndex, i = -1, indexes = [];\n                    while (++i < 2) {\n                        var index = identifiers[i];\n                        if (index.match(new RegExp(\"^\" + alias + \"(\\\\.?)\")) === null) {\n                            indexes.push(index);\n                            leftIndex = index;\n                        } else {\n                            indexes.push(index);\n                            rightIndex = index;\n                        }\n                    }\n                    if (leftIndex && rightIndex) {\n                        var leftOp = normalizeLeftIndexConstraint(leftIndex, indexes, constraint.op),\n                            rightOp = normalizeRightIndexConstraint(rightIndex, indexes, constraint.op);\n                        this.rightMemory.addIndex(rightIndex, leftIndex, rightOp);\n                        this.leftMemory.addIndex(leftIndex, rightIndex, leftOp);\n                    }\n                }\n            }\n            if (this.constraint.isDefault) {\n                this.constraint = constraint;\n                this.isDefault = false;\n            } else {\n                this.constraint = this.constraint.merge(constraint);\n            }\n            this.constraintAssert = this.constraint.assert;\n\n        },\n\n        equal: function (constraint) {\n            return this.constraint.equal(constraint.constraint);\n        },\n\n        isMatch: function (lc, rc) {\n            return this.constraintAssert(lc.factHash, rc.factHash);\n        },\n\n        match: function (lc, rc) {\n            var ret = {isMatch: false};\n            if (this.constraintAssert(lc.factHash, rc.factHash)) {\n                ret = lc.match.merge(rc.match);\n            }\n            return ret;\n        }\n\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/notNode.js":"var JoinNode = require(\"./joinNode\"),\n    LinkedList = require(\"../linkedList\"),\n    Context = require(\"../context\"),\n    InitialFact = require(\"../pattern\").InitialFact;\n\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"NotNode\",\n\n        constructor: function () {\n            this._super(arguments);\n            this.leftTupleMemory = {};\n            //use this ensure a unique match for and propagated context.\n            this.notMatch = new Context(new InitialFact()).match;\n        },\n\n        __cloneContext: function (context) {\n            return context.clone(null, null, context.match.merge(this.notMatch));\n        },\n\n\n        retractRight: function (context) {\n            var ctx = this.removeFromRightMemory(context),\n                rightContext = ctx.data,\n                blocking = rightContext.blocking;\n            if (blocking.length) {\n                //if we are blocking left contexts\n                var leftContext, thisConstraint = this.constraint, blockingNode = {next: blocking.head}, rc;\n                while ((blockingNode = blockingNode.next)) {\n                    leftContext = blockingNode.data;\n                    this.removeFromLeftBlockedMemory(leftContext);\n                    var rm = this.rightTuples.getRightMemory(leftContext), l = rm.length, i;\n                    i = -1;\n                    while (++i < l) {\n                        if (thisConstraint.isMatch(leftContext, rc = rm[i].data)) {\n                            this.blockedContext(leftContext, rc);\n                            leftContext = null;\n                            break;\n                        }\n                    }\n                    if (leftContext) {\n                        this.notBlockedContext(leftContext, true);\n                    }\n                }\n                blocking.clear();\n            }\n\n        },\n\n        blockedContext: function (leftContext, rightContext, propagate) {\n            leftContext.blocker = rightContext;\n            this.removeFromLeftMemory(leftContext);\n            this.addToLeftBlockedMemory(rightContext.blocking.push(leftContext));\n            propagate && this.__propagate(\"retract\", this.__cloneContext(leftContext));\n        },\n\n        notBlockedContext: function (leftContext, propagate) {\n            this.__addToLeftMemory(leftContext);\n            propagate && this.__propagate(\"assert\", this.__cloneContext(leftContext));\n        },\n\n        propagateFromLeft: function (leftContext) {\n            this.notBlockedContext(leftContext, true);\n        },\n\n        propagateFromRight: function (leftContext) {\n            this.notBlockedContext(leftContext, true);\n        },\n\n        blockFromAssertRight: function (leftContext, rightContext) {\n            this.blockedContext(leftContext, rightContext, true);\n        },\n\n        blockFromAssertLeft: function (leftContext, rightContext) {\n            this.blockedContext(leftContext, rightContext, false);\n        },\n\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                this.__propagate(\"retract\", this.__cloneContext(ctx));\n            } else {\n                if (!this.removeFromLeftBlockedMemory(context)) {\n                    throw new Error();\n                }\n            }\n        },\n\n        assertLeft: function (context) {\n            var values = this.rightTuples.getRightMemory(context),\n                thisConstraint = this.constraint, rc, i = -1, l = values.length;\n            while (++i < l) {\n                if (thisConstraint.isMatch(context, rc = values[i].data)) {\n                    this.blockFromAssertLeft(context, rc);\n                    context = null;\n                    i = l;\n                }\n            }\n            if (context) {\n                this.propagateFromLeft(context);\n            }\n        },\n\n        assertRight: function (context) {\n            this.__addToRightMemory(context);\n            context.blocking = new LinkedList();\n            var fl = this.leftTuples.getLeftMemory(context).slice(),\n                i = -1, l = fl.length,\n                leftContext, thisConstraint = this.constraint;\n            while (++i < l) {\n                leftContext = fl[i].data;\n                if (thisConstraint.isMatch(leftContext, context)) {\n                    this.blockFromAssertRight(leftContext, context);\n                }\n            }\n        },\n\n        addToLeftBlockedMemory: function (context) {\n            var data = context.data, hashCode = data.hashCode;\n            var ctx = this.leftMemory[hashCode];\n            this.leftTupleMemory[hashCode] = context;\n            if (ctx) {\n                this.leftTuples.remove(ctx);\n            }\n            return this;\n        },\n\n        removeFromLeftBlockedMemory: function (context) {\n            var ret = this.leftTupleMemory[context.hashCode] || null;\n            if (ret) {\n                delete this.leftTupleMemory[context.hashCode];\n                ret.data.blocker.blocking.remove(ret);\n            }\n            return ret;\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context),\n                leftContext,\n                thisConstraint = this.constraint,\n                rightTuples = this.rightTuples.getRightMemory(context),\n                l = rightTuples.length,\n                isBlocked = false,\n                i, rc, blocker;\n            if (!ctx) {\n                //blocked before\n                ctx = this.removeFromLeftBlockedMemory(context);\n                isBlocked = true;\n            }\n            if (ctx) {\n                leftContext = ctx.data;\n\n                if (leftContext && leftContext.blocker) {\n                    //we were blocked before so only check nodes previous to our blocker\n                    blocker = this.rightMemory[leftContext.blocker.hashCode];\n                    leftContext.blocker = null;\n                }\n                if (blocker) {\n                    if (thisConstraint.isMatch(context, rc = blocker.data)) {\n                        //we cant be proagated so retract previous\n                        if (!isBlocked) {\n                            //we were asserted before so retract\n                            this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                        }\n                        context.blocker = rc;\n                        this.addToLeftBlockedMemory(rc.blocking.push(context));\n                        context = null;\n                    }\n                }\n                if (context && l) {\n                    i = -1;\n                    //we were propogated before\n                    while (++i < l) {\n                        if (thisConstraint.isMatch(context, rc = rightTuples[i].data)) {\n                            //we cant be proagated so retract previous\n                            if (!isBlocked) {\n                                //we were asserted before so retract\n                                this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                            }\n                            this.addToLeftBlockedMemory(rc.blocking.push(context));\n                            context.blocker = rc;\n                            context = null;\n                            break;\n                        }\n                    }\n                }\n                if (context) {\n                    //we can still be propogated\n                    this.__addToLeftMemory(context);\n                    if (!isBlocked) {\n                        //we weren't blocked before so modify\n                        this.__propagate(\"modify\", this.__cloneContext(context));\n                    } else {\n                        //we were blocked before but aren't now\n                        this.__propagate(\"assert\", this.__cloneContext(context));\n                    }\n\n                }\n            } else {\n                throw new Error();\n            }\n\n        },\n\n        modifyRight: function (context) {\n            var ctx = this.removeFromRightMemory(context);\n            if (ctx) {\n                var rightContext = ctx.data,\n                    leftTuples = this.leftTuples.getLeftMemory(context).slice(),\n                    leftTuplesLength = leftTuples.length,\n                    leftContext,\n                    thisConstraint = this.constraint,\n                    i, node,\n                    blocking = rightContext.blocking;\n                this.__addToRightMemory(context);\n                context.blocking = new LinkedList();\n\n                var rc;\n                //check old blocked contexts\n                //check if the same contexts blocked before are still blocked\n                var blockingNode = {next: blocking.head};\n                while ((blockingNode = blockingNode.next)) {\n                    leftContext = blockingNode.data;\n                    leftContext.blocker = null;\n                    if (thisConstraint.isMatch(leftContext, context)) {\n                        leftContext.blocker = context;\n                        this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                        leftContext = null;\n                    } else {\n                        //we arent blocked anymore\n                        leftContext.blocker = null;\n                        node = ctx;\n                        while ((node = node.next)) {\n                            if (thisConstraint.isMatch(leftContext, rc = node.data)) {\n                                leftContext.blocker = rc;\n                                this.addToLeftBlockedMemory(rc.blocking.push(leftContext));\n                                leftContext = null;\n                                break;\n                            }\n                        }\n                        if (leftContext) {\n                            this.__addToLeftMemory(leftContext);\n                            this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                        }\n                    }\n                }\n                if (leftTuplesLength) {\n                    //check currently left tuples in memory\n                    i = -1;\n                    while (++i < leftTuplesLength) {\n                        leftContext = leftTuples[i].data;\n                        if (thisConstraint.isMatch(leftContext, context)) {\n                            this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                            this.removeFromLeftMemory(leftContext);\n                            this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                            leftContext.blocker = context;\n                        }\n                    }\n                }\n            } else {\n                throw new Error();\n            }\n\n\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/fromNode.js":"var JoinNode = require(\"./joinNode\"),\n    extd = require(\"../extended\"),\n    constraint = require(\"../constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    HashConstraint = constraint.HashConstraint,\n    ReferenceConstraint = constraint.ReferenceConstraint,\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    isEmpty = extd.isEmpty,\n    forEach = extd.forEach,\n    isArray = extd.isArray;\n\nvar DEFAULT_MATCH = {\n    isMatch: function () {\n        return false;\n    }\n};\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"FromNode\",\n\n        constructor: function (pattern, wm) {\n            this._super(arguments);\n            this.workingMemory = wm;\n            this.fromMemory = {};\n            this.pattern = pattern;\n            this.type = pattern.get(\"constraints\")[0].assert;\n            this.alias = pattern.get(\"alias\");\n            this.from = pattern.from.assert;\n            var eqConstraints = this.__equalityConstraints = [];\n            var vars = [];\n            forEach(this.constraints = this.pattern.get(\"constraints\").slice(1), function (c) {\n                if (c instanceof EqualityConstraint || c instanceof ReferenceConstraint) {\n                    eqConstraints.push(c.assert);\n                } else if (c instanceof HashConstraint) {\n                    vars = vars.concat(c.get(\"variables\"));\n                }\n            });\n            this.__variables = vars;\n        },\n\n        __createMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    this.__checkMatch(context, o[i], true);\n                }\n            } else if (isDefined(o)) {\n                this.__checkMatch(context, o, true);\n            }\n        },\n\n        __checkMatch: function (context, o, propogate) {\n            var newContext;\n            if ((newContext = this.__createMatch(context, o)).isMatch() && propogate) {\n                this.__propagate(\"assert\", newContext.clone());\n            }\n            return newContext;\n        },\n\n        __createMatch: function (lc, o) {\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o, true),\n                    createdContext,\n                    rc = new Context(createdFact, null, null)\n                        .set(this.alias, o),\n                    createdFactId = createdFact.id;\n                var fh = rc.factHash, lcFh = lc.factHash;\n                for (var key in lcFh) {\n                    fh[key] = lcFh[key];\n                }\n                var eqConstraints = this.__equalityConstraints, vars = this.__variables, i = -1, l = eqConstraints.length;\n                while (++i < l) {\n                    if (!eqConstraints[i](fh, fh)) {\n                        createdContext = DEFAULT_MATCH;\n                        break;\n                    }\n                }\n                var fm = this.fromMemory[createdFactId];\n                if (!fm) {\n                    fm = this.fromMemory[createdFactId] = {};\n                }\n                if (!createdContext) {\n                    var prop;\n                    i = -1;\n                    l = vars.length;\n                    while (++i < l) {\n                        prop = vars[i];\n                        fh[prop] = o[prop];\n                    }\n                    lc.fromMatches[createdFact.id] = createdContext = rc.clone(createdFact, null, lc.match.merge(rc.match));\n                }\n                fm[lc.hashCode] = [lc, createdContext];\n                return createdContext;\n            }\n            return DEFAULT_MATCH;\n        },\n\n        retractRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        },\n\n        removeFromFromMemory: function (context) {\n            var factId = context.fact.id;\n            var fm = this.fromMemory[factId];\n            if (fm) {\n                var entry;\n                for (var i in fm) {\n                    entry = fm[i];\n                    if (entry[1] === context) {\n                        delete fm[i];\n                        if (isEmpty(fm)) {\n                            delete this.fromMemory[factId];\n                        }\n                        break;\n                    }\n                }\n            }\n\n        },\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                var fromMatches = ctx.fromMatches;\n                for (var i in fromMatches) {\n                    this.removeFromFromMemory(fromMatches[i]);\n                    this.__propagate(\"retract\", fromMatches[i].clone());\n                }\n            }\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context), newContext, i, l, factId, fact;\n            if (ctx) {\n                this.__addToLeftMemory(context);\n\n                var leftContext = ctx.data,\n                    fromMatches = (context.fromMatches = {}),\n                    rightMatches = leftContext.fromMatches,\n                    o = this.from(context.factHash);\n\n                if (isArray(o)) {\n                    for (i = 0, l = o.length; i < l; i++) {\n                        newContext = this.__checkMatch(context, o[i], false);\n                        if (newContext.isMatch()) {\n                            factId = newContext.fact.id;\n                            if (factId in rightMatches) {\n                                this.__propagate(\"modify\", newContext.clone());\n                            } else {\n                                this.__propagate(\"assert\", newContext.clone());\n                            }\n                        }\n                    }\n                } else if (isDefined(o)) {\n                    newContext = this.__checkMatch(context, o, false);\n                    if (newContext.isMatch()) {\n                        factId = newContext.fact.id;\n                        if (factId in rightMatches) {\n                            this.__propagate(\"modify\", newContext.clone());\n                        } else {\n                            this.__propagate(\"assert\", newContext.clone());\n                        }\n                    }\n                }\n                for (i in rightMatches) {\n                    if (!(i in fromMatches)) {\n                        this.removeFromFromMemory(rightMatches[i]);\n                        this.__propagate(\"retract\", rightMatches[i].clone());\n                    }\n                }\n            } else {\n                this.assertLeft(context);\n            }\n            fact = context.fact;\n            factId = fact.id;\n            var fm = this.fromMemory[factId];\n            this.fromMemory[factId] = {};\n            if (fm) {\n                var lc, entry, cc, createdIsMatch, factObject = fact.object;\n                for (i in fm) {\n                    entry = fm[i];\n                    lc = entry[0];\n                    cc = entry[1];\n                    createdIsMatch = cc.isMatch();\n                    if (lc.hashCode !== context.hashCode) {\n                        newContext = this.__createMatch(lc, factObject, false);\n                        if (createdIsMatch) {\n                            this.__propagate(\"retract\", cc.clone());\n                        }\n                        if (newContext.isMatch()) {\n                            this.__propagate(createdIsMatch ? \"modify\" : \"assert\", newContext.clone());\n                        }\n\n                    }\n                }\n            }\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            context.fromMatches = {};\n            this.__createMatches(context);\n        },\n\n        assertRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/fromNotNode.js":"var JoinNode = require(\"./joinNode\"),\n    extd = require(\"../extended\"),\n    constraint = require(\"../constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    HashConstraint = constraint.HashConstraint,\n    ReferenceConstraint = constraint.ReferenceConstraint,\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    forEach = extd.forEach,\n    isArray = extd.isArray;\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"FromNotNode\",\n\n        constructor: function (pattern, workingMemory) {\n            this._super(arguments);\n            this.workingMemory = workingMemory;\n            this.pattern = pattern;\n            this.type = pattern.get(\"constraints\")[0].assert;\n            this.alias = pattern.get(\"alias\");\n            this.from = pattern.from.assert;\n            this.fromMemory = {};\n            var eqConstraints = this.__equalityConstraints = [];\n            var vars = [];\n            forEach(this.constraints = this.pattern.get(\"constraints\").slice(1), function (c) {\n                if (c instanceof EqualityConstraint || c instanceof ReferenceConstraint) {\n                    eqConstraints.push(c.assert);\n                } else if (c instanceof HashConstraint) {\n                    vars = vars.concat(c.get(\"variables\"));\n                }\n            });\n            this.__variables = vars;\n\n        },\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                if (!ctx.blocked) {\n                    this.__propagate(\"retract\", ctx.clone());\n                }\n            }\n        },\n\n        __modify: function (context, leftContext) {\n            var leftContextBlocked = leftContext.blocked;\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        break;\n                    }\n                }\n            } else if (isDefined(o)) {\n                context.blocked = this.__isMatch(context, o, true);\n            }\n            var newContextBlocked = context.blocked;\n            if (!newContextBlocked) {\n                if (leftContextBlocked) {\n                    this.__propagate(\"assert\", context.clone());\n                } else {\n                    this.__propagate(\"modify\", context.clone());\n                }\n            } else if (!leftContextBlocked) {\n                this.__propagate(\"retract\", leftContext.clone());\n            }\n\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                this.__addToLeftMemory(context);\n                this.__modify(context, ctx.data);\n            } else {\n                throw new Error();\n            }\n            var fm = this.fromMemory[context.fact.id];\n            this.fromMemory[context.fact.id] = {};\n            if (fm) {\n                for (var i in fm) {\n                    // update any contexts associated with this fact\n                    if (i !== context.hashCode) {\n                        var lc = fm[i];\n                        ctx = this.removeFromLeftMemory(lc);\n                        if (ctx) {\n                            lc = lc.clone();\n                            lc.blocked = false;\n                            this.__addToLeftMemory(lc);\n                            this.__modify(lc, ctx.data);\n                        }\n                    }\n                }\n            }\n        },\n\n        __findMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh), isMatch = false;\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        return;\n                    }\n                }\n                this.__propagate(\"assert\", context.clone());\n            } else if (isDefined(o) && !(context.blocked = this.__isMatch(context, o, true))) {\n                this.__propagate(\"assert\", context.clone());\n            }\n            return isMatch;\n        },\n\n        __isMatch: function (oc, o, add) {\n            var ret = false;\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o);\n                var context = new Context(createdFact, null)\n                    .mergeMatch(oc.match)\n                    .set(this.alias, o);\n                if (add) {\n                    var fm = this.fromMemory[createdFact.id];\n                    if (!fm) {\n                        fm = this.fromMemory[createdFact.id] = {};\n                    }\n                    fm[oc.hashCode] = oc;\n                }\n                var fh = context.factHash;\n                var eqConstraints = this.__equalityConstraints;\n                for (var i = 0, l = eqConstraints.length; i < l; i++) {\n                    if (eqConstraints[i](fh, fh)) {\n                        ret = true;\n                    } else {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            return ret;\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            this.__findMatches(context);\n        },\n\n        assertRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        },\n\n        retractRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/existsNode.js":"var NotNode = require(\"./notNode\"),\n    LinkedList = require(\"../linkedList\");\n\n\nNotNode.extend({\n    instance: {\n\n        nodeType: \"ExistsNode\",\n\n        blockedContext: function (leftContext, rightContext) {\n            leftContext.blocker = rightContext;\n            this.removeFromLeftMemory(leftContext);\n            this.addToLeftBlockedMemory(rightContext.blocking.push(leftContext));\n            this.__propagate(\"assert\", this.__cloneContext(leftContext));\n        },\n\n        notBlockedContext: function (leftContext, propagate) {\n            this.__addToLeftMemory(leftContext);\n            propagate && this.__propagate(\"retract\", this.__cloneContext(leftContext));\n        },\n\n        propagateFromLeft: function (leftContext) {\n            this.notBlockedContext(leftContext, false);\n        },\n\n\n        retractLeft: function (context) {\n            var ctx;\n            if (!this.removeFromLeftMemory(context)) {\n                if ((ctx = this.removeFromLeftBlockedMemory(context))) {\n                    this.__propagate(\"retract\", this.__cloneContext(ctx.data));\n                } else {\n                    throw new Error();\n                }\n            }\n        },\n       \n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context),\n                leftContext,\n                thisConstraint = this.constraint,\n                rightTuples = this.rightTuples,\n                l = rightTuples.length,\n                isBlocked = false,\n                node, rc, blocker;\n            if (!ctx) {\n                //blocked before\n                ctx = this.removeFromLeftBlockedMemory(context);\n                isBlocked = true;\n            }\n            if (ctx) {\n                leftContext = ctx.data;\n\n                if (leftContext && leftContext.blocker) {\n                    //we were blocked before so only check nodes previous to our blocker\n                    blocker = this.rightMemory[leftContext.blocker.hashCode];\n                }\n                if (blocker) {\n                    if (thisConstraint.isMatch(context, rc = blocker.data)) {\n                        //propogate as a modify or assert\n                        this.__propagate(!isBlocked ? \"assert\" : \"modify\", this.__cloneContext(leftContext));\n                        context.blocker = rc;\n                        this.addToLeftBlockedMemory(rc.blocking.push(context));\n                        context = null;\n                    }\n                    if (context) {\n                        node = {next: blocker.next};\n                    }\n                } else {\n                    node = {next: rightTuples.head};\n                }\n                if (context && l) {\n                    node = {next: rightTuples.head};\n                    //we were propagated before\n                    while ((node = node.next)) {\n                        if (thisConstraint.isMatch(context, rc = node.data)) {\n                            //we cant be proagated so retract previous\n\n                            //we were asserted before so retract\n                            this.__propagate(!isBlocked ? \"assert\" : \"modify\", this.__cloneContext(leftContext));\n\n                            this.addToLeftBlockedMemory(rc.blocking.push(context));\n                            context.blocker = rc;\n                            context = null;\n                            break;\n                        }\n                    }\n                }\n                if (context) {\n                    //we can still be propogated\n                    this.__addToLeftMemory(context);\n                    if (isBlocked) {\n                        //we were blocked so retract\n                        this.__propagate(\"retract\", this.__cloneContext(context));\n                    }\n\n                }\n            } else {\n                throw new Error();\n            }\n\n        },\n\n        modifyRight: function (context) {\n            var ctx = this.removeFromRightMemory(context);\n            if (ctx) {\n                var rightContext = ctx.data,\n                    leftTuples = this.leftTuples,\n                    leftTuplesLength = leftTuples.length,\n                    leftContext,\n                    thisConstraint = this.constraint,\n                    node,\n                    blocking = rightContext.blocking;\n                this.__addToRightMemory(context);\n                context.blocking = new LinkedList();\n                if (leftTuplesLength || blocking.length) {\n                    if (blocking.length) {\n                        var rc;\n                        //check old blocked contexts\n                        //check if the same contexts blocked before are still blocked\n                        var blockingNode = {next: blocking.head};\n                        while ((blockingNode = blockingNode.next)) {\n                            leftContext = blockingNode.data;\n                            leftContext.blocker = null;\n                            if (thisConstraint.isMatch(leftContext, context)) {\n                                leftContext.blocker = context;\n                                this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                                this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                leftContext = null;\n                            } else {\n                                //we arent blocked anymore\n                                leftContext.blocker = null;\n                                node = ctx;\n                                while ((node = node.next)) {\n                                    if (thisConstraint.isMatch(leftContext, rc = node.data)) {\n                                        leftContext.blocker = rc;\n                                        this.addToLeftBlockedMemory(rc.blocking.push(leftContext));\n                                        this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                        leftContext = null;\n                                        break;\n                                    }\n                                }\n                                if (leftContext) {\n                                    this.__addToLeftMemory(leftContext);\n                                }\n                            }\n                        }\n                    }\n\n                    if (leftTuplesLength) {\n                        //check currently left tuples in memory\n                        node = {next: leftTuples.head};\n                        while ((node = node.next)) {\n                            leftContext = node.data;\n                            if (thisConstraint.isMatch(leftContext, context)) {\n                                this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                this.removeFromLeftMemory(leftContext);\n                                this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                                leftContext.blocker = context;\n                            }\n                        }\n                    }\n\n\n                }\n            } else {\n                throw new Error();\n            }\n\n\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/existsFromNode.js":"var FromNotNode = require(\"./fromNotNode\"),\n    extd = require(\"../extended\"),\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    isArray = extd.isArray;\n\nFromNotNode.extend({\n    instance: {\n\n        nodeType: \"ExistsFromNode\",\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                if (ctx.blocked) {\n                    this.__propagate(\"retract\", ctx.clone());\n                }\n            }\n        },\n\n        __modify: function (context, leftContext) {\n            var leftContextBlocked = leftContext.blocked;\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        break;\n                    }\n                }\n            } else if (isDefined(o)) {\n                context.blocked = this.__isMatch(context, o, true);\n            }\n            var newContextBlocked = context.blocked;\n            if (newContextBlocked) {\n                if (leftContextBlocked) {\n                    this.__propagate(\"modify\", context.clone());\n                } else {\n                    this.__propagate(\"assert\", context.clone());\n                }\n            } else if (leftContextBlocked) {\n                this.__propagate(\"retract\", context.clone());\n            }\n\n        },\n\n        __findMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh), isMatch = false;\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        this.__propagate(\"assert\", context.clone());\n                        return;\n                    }\n                }\n            } else if (isDefined(o) && (this.__isMatch(context, o, true))) {\n                context.blocked = true;\n                this.__propagate(\"assert\", context.clone());\n            }\n            return isMatch;\n        },\n\n        __isMatch: function (oc, o, add) {\n            var ret = false;\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o);\n                var context = new Context(createdFact, null, null)\n                    .mergeMatch(oc.match)\n                    .set(this.alias, o);\n                if (add) {\n                    var fm = this.fromMemory[createdFact.id];\n                    if (!fm) {\n                        fm = this.fromMemory[createdFact.id] = {};\n                    }\n                    fm[oc.hashCode] = oc;\n                }\n                var fh = context.factHash;\n                var eqConstraints = this.__equalityConstraints;\n                for (var i = 0, l = eqConstraints.length; i < l; i++) {\n                    if (eqConstraints[i](fh)) {\n                        ret = true;\n                    } else {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            return ret;\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            this.__findMatches(context);\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/leftAdapterNode.js":"var Node = require(\"./adapterNode\");\n\nNode.extend({\n    instance: {\n        propagateAssert: function (context) {\n            this.__propagate(\"assertLeft\", context);\n        },\n\n        propagateRetract: function (context) {\n            this.__propagate(\"retractLeft\", context);\n        },\n\n        propagateResolve: function (context) {\n            this.__propagate(\"retractResolve\", context);\n        },\n\n        propagateModify: function (context) {\n            this.__propagate(\"modifyLeft\", context);\n        },\n\n        retractResolve: function (match) {\n            this.__propagate(\"retractResolve\", match);\n        },\n\n        dispose: function (context) {\n            this.propagateDispose(context);\n        },\n\n        toString: function () {\n            return \"LeftAdapterNode \" + this.__count;\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/adapterNode.js":"var Node = require(\"./node\"),\n    intersection = require(\"../extended\").intersection;\n\nNode.extend({\n    instance: {\n\n        __propagatePaths: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode, paths, continuingPaths;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                paths = entry.value;\n                if ((continuingPaths = intersection(paths, context.paths)).length) {\n                    outNode[method](context.clone(null, continuingPaths, null));\n                }\n            }\n        },\n\n        __propagateNoPaths: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length;\n            while (--i > -1) {\n                entrySet[i].key[method](context);\n            }\n        },\n\n        __propagate: function (method, context) {\n            if (context.paths) {\n                this.__propagatePaths(method, context);\n            } else {\n                this.__propagateNoPaths(method, context);\n            }\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/rightAdapterNode.js":"var Node = require(\"./adapterNode\");\n\nNode.extend({\n    instance: {\n\n        retractResolve: function (match) {\n            this.__propagate(\"retractResolve\", match);\n        },\n\n        dispose: function (context) {\n            this.propagateDispose(context);\n        },\n\n        propagateAssert: function (context) {\n            this.__propagate(\"assertRight\", context);\n        },\n\n        propagateRetract: function (context) {\n            this.__propagate(\"retractRight\", context);\n        },\n\n        propagateResolve: function (context) {\n            this.__propagate(\"retractResolve\", context);\n        },\n\n        propagateModify: function (context) {\n            this.__propagate(\"modifyRight\", context);\n        },\n\n        toString: function () {\n            return \"RightAdapterNode \" + this.__count;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/typeNode.js":"var AlphaNode = require(\"./alphaNode\"),\n    Context = require(\"../context\");\n\nAlphaNode.extend({\n    instance: {\n\n        assert: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"assert\", fact);\n            }\n        },\n\n        modify: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"modify\", fact);\n            }\n        },\n\n        retract: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"retract\", fact);\n            }\n        },\n\n        toString: function () {\n            return \"TypeNode\" + this.__count;\n        },\n\n        dispose: function () {\n            var es = this.__entrySet, i = es.length - 1;\n            for (; i >= 0; i--) {\n                var e = es[i], outNode = e.key, paths = e.value;\n                outNode.dispose({paths: paths});\n            }\n        },\n\n        __propagate: function (method, fact) {\n            var es = this.__entrySet, i = -1, l = es.length;\n            while (++i < l) {\n                var e = es[i], outNode = e.key, paths = e.value;\n                outNode[method](new Context(fact, paths));\n            }\n        }\n    }\n}).as(module);\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/terminalNode.js":"var Node = require(\"./node\"),\n    extd = require(\"../extended\"),\n    bind = extd.bind;\n\nNode.extend({\n    instance: {\n        constructor: function (bucket, index, rule, agenda) {\n            this._super([]);\n            this.resolve = bind(this, this.resolve);\n            this.rule = rule;\n            this.index = index;\n            this.name = this.rule.name;\n            this.agenda = agenda;\n            this.bucket = bucket;\n            agenda.register(this);\n        },\n\n        __assertModify: function (context) {\n            var match = context.match;\n            if (match.isMatch) {\n                var rule = this.rule, bucket = this.bucket;\n                this.agenda.insert(this, {\n                    rule: rule,\n                    hashCode: context.hashCode,\n                    index: this.index,\n                    name: rule.name,\n                    recency: bucket.recency++,\n                    match: match,\n                    counter: bucket.counter\n                });\n            }\n        },\n\n        assert: function (context) {\n            this.__assertModify(context);\n        },\n\n        modify: function (context) {\n            this.agenda.retract(this, context);\n            this.__assertModify(context);\n        },\n\n        retract: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        retractRight: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        retractLeft: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        assertLeft: function (context) {\n            this.__assertModify(context);\n        },\n\n        assertRight: function (context) {\n            this.__assertModify(context);\n        },\n\n        toString: function () {\n            return \"TerminalNode \" + this.rule.name;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/propertyNode.js":"var AlphaNode = require(\"./alphaNode\"),\n    Context = require(\"../context\"),\n    extd = require(\"../extended\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this._super(arguments);\n            this.alias = this.constraint.get(\"alias\");\n            this.varLength = (this.variables = extd(this.constraint.get(\"variables\")).toArray().value()).length;\n        },\n\n        assert: function (context) {\n            var c = new Context(context.fact, context.paths);\n            var variables = this.variables, o = context.fact.object, item;\n            c.set(this.alias, o);\n            for (var i = 0, l = this.varLength; i < l; i++) {\n                item = variables[i];\n                c.set(item[1], o[item[0]]);\n            }\n\n            this.__propagate(\"assert\", c);\n\n        },\n\n        retract: function (context) {\n            this.__propagate(\"retract\", new Context(context.fact, context.paths));\n        },\n\n        modify: function (context) {\n            var c = new Context(context.fact, context.paths);\n            var variables = this.variables, o = context.fact.object, item;\n            c.set(this.alias, o);\n            for (var i = 0, l = this.varLength; i < l; i++) {\n                item = variables[i];\n                c.set(item[1], o[item[0]]);\n            }\n            this.__propagate(\"modify\", c);\n        },\n\n\n        toString: function () {\n            return \"PropertyNode\" + this.__count;\n        }\n    }\n}).as(module);\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/workingMemory.js":"\"use strict\";\nvar declare = require(\"declare.js\"),\n    LinkedList = require(\"./linkedList\"),\n    InitialFact = require(\"./pattern\").InitialFact,\n    id = 0;\n\nvar Fact = declare({\n\n    instance: {\n        constructor: function (obj) {\n            this.object = obj;\n            this.recency = 0;\n            this.id = id++;\n        },\n\n        equals: function (fact) {\n            return fact === this.object;\n        },\n\n        hashCode: function () {\n            return this.id;\n        }\n    }\n\n});\n\ndeclare({\n\n    instance: {\n\n        constructor: function () {\n            this.recency = 0;\n            this.facts = new LinkedList();\n        },\n\n        dispose: function () {\n            this.facts.clear();\n        },\n\n        getFacts: function () {\n            var head = {next: this.facts.head}, ret = [], i = 0, val;\n            while ((head = head.next)) {\n                if (!((val = head.data.object)  instanceof InitialFact)) {\n                    ret[i++] = val;\n                }\n            }\n            return ret;\n        },\n\n        getFactsByType: function (Type) {\n            var head = {next: this.facts.head}, ret = [], i = 0;\n            while ((head = head.next)) {\n                var val = head.data.object;\n                if (!(val  instanceof InitialFact) && (val instanceof Type || val.constructor === Type)) {\n                    ret[i++] = val;\n                }\n            }\n            return ret;\n        },\n\n        getFactHandle: function (o) {\n            var head = {next: this.facts.head}, ret;\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(o)) {\n                    return existingFact;\n                }\n            }\n            if (!ret) {\n                ret = new Fact(o);\n                ret.recency = this.recency++;\n                //this.facts.push(ret);\n            }\n            return ret;\n        },\n\n        modifyFact: function (fact) {\n            var head = {next: this.facts.head};\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(fact)) {\n                    existingFact.recency = this.recency++;\n                    return existingFact;\n                }\n            }\n            //if we made it here we did not find the fact\n            throw new Error(\"the fact to modify does not exist\");\n        },\n\n        assertFact: function (fact) {\n            var ret = new Fact(fact);\n            ret.recency = this.recency++;\n            this.facts.push(ret);\n            return ret;\n        },\n\n        retractFact: function (fact) {\n            var facts = this.facts, head = {next: facts.head};\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(fact)) {\n                    facts.remove(head);\n                    return existingFact;\n                }\n            }\n            //if we made it here we did not find the fact\n            throw new Error(\"the fact to remove does not exist\");\n\n\n        }\n    }\n\n}).as(exports, \"WorkingMemory\");\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/executionStrategy.js":"var extd = require(\"./extended\"),\n    Promise = extd.Promise,\n    nextTick = require(\"./nextTick\"),\n    isPromiseLike = extd.isPromiseLike;\n\nPromise.extend({\n    instance: {\n\n        looping: false,\n\n        constructor: function (flow, matchUntilHalt) {\n            this._super([]);\n            this.flow = flow;\n            this.agenda = flow.agenda;\n            this.rootNode = flow.rootNode;\n            this.matchUntilHalt = !!(matchUntilHalt);\n            extd.bindAll(this, [\"onAlter\", \"callNext\"]);\n        },\n\n        halt: function () {\n            this.__halted = true;\n            if (!this.looping) {\n                this.callback();\n            }\n        },\n\n        onAlter: function () {\n            this.flowAltered = true;\n            if (!this.looping && this.matchUntilHalt && !this.__halted) {\n                this.callNext();\n            }\n        },\n\n        setup: function () {\n            var flow = this.flow;\n            this.rootNode.resetCounter();\n            flow.on(\"assert\", this.onAlter);\n            flow.on(\"modify\", this.onAlter);\n            flow.on(\"retract\", this.onAlter);\n        },\n\n        tearDown: function () {\n            var flow = this.flow;\n            flow.removeListener(\"assert\", this.onAlter);\n            flow.removeListener(\"modify\", this.onAlter);\n            flow.removeListener(\"retract\", this.onAlter);\n        },\n\n        __handleAsyncNext: function (next) {\n            var self = this, agenda = self.agenda;\n            return next.then(function () {\n                self.looping = false;\n                if (!agenda.isEmpty()) {\n                    if (self.flowAltered) {\n                        self.rootNode.incrementCounter();\n                        self.flowAltered = false;\n                    }\n                    if (!self.__halted) {\n                        self.callNext();\n                    } else {\n                        self.callback();\n                    }\n                } else if (!self.matchUntilHalt || self.__halted) {\n                    self.callback();\n                }\n                self = null;\n            }, this.errback);\n        },\n\n        __handleSyncNext: function (next) {\n            this.looping = false;\n            if (!this.agenda.isEmpty()) {\n                if (this.flowAltered) {\n                    this.rootNode.incrementCounter();\n                    this.flowAltered = false;\n                }\n            }\n            if (next && !this.__halted) {\n                nextTick(this.callNext);\n            } else if (!this.matchUntilHalt || this.__halted) {\n                this.callback();\n            }\n            return next;\n        },\n\n        callback: function () {\n            this.tearDown();\n            this._super(arguments);\n        },\n\n\n        callNext: function () {\n            this.looping = true;\n            var next = this.agenda.fireNext();\n            return isPromiseLike(next) ? this.__handleAsyncNext(next) : this.__handleSyncNext(next);\n        },\n\n        execute: function () {\n            this.setup();\n            this.callNext();\n            return this;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nextTick.js":"/*global setImmediate, window, MessageChannel*/\nvar extd = require(\"./extended\");\nvar nextTick;\nif (typeof setImmediate === \"function\") {\n    // In IE10, or use https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        nextTick = extd.bind(window, setImmediate);\n    } else {\n        nextTick = setImmediate;\n    }\n} else if (typeof process !== \"undefined\") {\n    // node\n    nextTick = process.nextTick;\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    // linked list of tasks (single, with head node)\n    var head = {}, tail = head;\n    channel.port1.onmessage = function () {\n        head = head.next;\n        var task = head.task;\n        delete head.task;\n        task();\n    };\n    nextTick = function (task) {\n        tail = tail.next = {task: task};\n        channel.port2.postMessage(0);\n    };\n} else {\n    // old browsers\n    nextTick = function (task) {\n        setTimeout(task, 0);\n    };\n}\n\nmodule.exports = nextTick;","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/agenda.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    declare = extd.declare,\n    AVLTree = extd.AVLTree,\n    LinkedList = extd.LinkedList,\n    isPromise = extd.isPromiseLike,\n    EventEmitter = require(\"events\").EventEmitter;\n\n\nvar FactHash = declare({\n    instance: {\n        constructor: function () {\n            this.memory = {};\n            this.memoryValues = new LinkedList();\n        },\n\n        clear: function () {\n            this.memoryValues.clear();\n            this.memory = {};\n        },\n\n\n        remove: function (v) {\n            var hashCode = v.hashCode,\n                memory = this.memory,\n                ret = memory[hashCode];\n            if (ret) {\n                this.memoryValues.remove(ret);\n                delete memory[hashCode];\n            }\n            return ret;\n        },\n\n        insert: function (insert) {\n            var hashCode = insert.hashCode;\n            if (hashCode in this.memory) {\n                throw new Error(\"Activation already in agenda \" + insert.rule.name + \" agenda\");\n            }\n            this.memoryValues.push((this.memory[hashCode] = insert));\n        }\n    }\n});\n\n\nvar DEFAULT_AGENDA_GROUP = \"main\";\nmodule.exports = declare(EventEmitter, {\n\n    instance: {\n        constructor: function (flow, conflictResolution) {\n            this.agendaGroups = {};\n            this.agendaGroupStack = [DEFAULT_AGENDA_GROUP];\n            this.rules = {};\n            this.flow = flow;\n            this.comparator = conflictResolution;\n            this.setFocus(DEFAULT_AGENDA_GROUP).addAgendaGroup(DEFAULT_AGENDA_GROUP);\n        },\n\n        addAgendaGroup: function (groupName) {\n            if (!extd.has(this.agendaGroups, groupName)) {\n                this.agendaGroups[groupName] = new AVLTree({compare: this.comparator});\n            }\n        },\n\n        getAgendaGroup: function (groupName) {\n            return this.agendaGroups[groupName || DEFAULT_AGENDA_GROUP];\n        },\n\n        setFocus: function (agendaGroup) {\n            if (agendaGroup !== this.getFocused() && this.agendaGroups[agendaGroup]) {\n                this.agendaGroupStack.push(agendaGroup);\n                this.emit(\"focused\", agendaGroup);\n            }\n            return this;\n        },\n\n        getFocused: function () {\n            var ags = this.agendaGroupStack;\n            return ags[ags.length - 1];\n        },\n\n        getFocusedAgenda: function () {\n            return this.agendaGroups[this.getFocused()];\n        },\n\n        register: function (node) {\n            var agendaGroup = node.rule.agendaGroup;\n            this.rules[node.name] = {tree: new AVLTree({compare: this.comparator}), factTable: new FactHash()};\n            if (agendaGroup) {\n                this.addAgendaGroup(agendaGroup);\n            }\n        },\n\n        isEmpty: function () {\n            var agendaGroupStack = this.agendaGroupStack, changed = false;\n            while (this.getFocusedAgenda().isEmpty() && this.getFocused() !== DEFAULT_AGENDA_GROUP) {\n                agendaGroupStack.pop();\n                changed = true;\n            }\n            if (changed) {\n                this.emit(\"focused\", this.getFocused());\n            }\n            return this.getFocusedAgenda().isEmpty();\n        },\n\n        fireNext: function () {\n            var agendaGroupStack = this.agendaGroupStack, ret = false;\n            while (this.getFocusedAgenda().isEmpty() && this.getFocused() !== DEFAULT_AGENDA_GROUP) {\n                agendaGroupStack.pop();\n            }\n            if (!this.getFocusedAgenda().isEmpty()) {\n                var activation = this.pop();\n                this.emit(\"fire\", activation.rule.name, activation.match.factHash);\n                var fired = activation.rule.fire(this.flow, activation.match);\n                if (isPromise(fired)) {\n                    ret = fired.then(function () {\n                        //return true if an activation fired\n                        return true;\n                    });\n                } else {\n                    ret = true;\n                }\n            }\n            //return false if activation not fired\n            return ret;\n        },\n\n        pop: function () {\n            var tree = this.getFocusedAgenda(), root = tree.__root;\n            while (root.right) {\n                root = root.right;\n            }\n            var v = root.data;\n            tree.remove(v);\n            var rule = this.rules[v.name];\n            rule.tree.remove(v);\n            rule.factTable.remove(v);\n            return v;\n        },\n\n        peek: function () {\n            var tree = this.getFocusedAgenda(), root = tree.__root;\n            while (root.right) {\n                root = root.right;\n            }\n            return root.data;\n        },\n\n        modify: function (node, context) {\n            this.retract(node, context);\n            this.insert(node, context);\n        },\n\n        retract: function (node, retract) {\n            var rule = this.rules[node.name];\n            retract.rule = node;\n            var activation = rule.factTable.remove(retract);\n            if (activation) {\n                this.getAgendaGroup(node.rule.agendaGroup).remove(activation);\n                rule.tree.remove(activation);\n            }\n        },\n\n        insert: function (node, insert) {\n            var rule = this.rules[node.name], nodeRule = node.rule, agendaGroup = nodeRule.agendaGroup;\n            rule.tree.insert(insert);\n            this.getAgendaGroup(agendaGroup).insert(insert);\n            if (nodeRule.autoFocus) {\n                this.setFocus(agendaGroup);\n            }\n\n            rule.factTable.insert(insert);\n        },\n\n        dispose: function () {\n            for (var i in this.agendaGroups) {\n                this.agendaGroups[i].clear();\n            }\n            var rules = this.rules;\n            for (i in rules) {\n                if (i in rules) {\n                    rules[i].tree.clear();\n                    rules[i].factTable.clear();\n\n                }\n            }\n            this.rules = {};\n        }\n    }\n\n});","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/Gruntfile.js":"/*global module:false*/\nmodule.exports = function (grunt) {\n    // Project configuration.\n    var path = require(\"path\"),\n        child = require(\"child_process\");\n    grunt.initConfig({\n        pkg: grunt.file.readJSON('package.json'),\n\n        exec: {\n            removeDocs: \"rm -rf docs/* && mkdir -p ./docs/examples/browser && cp -r ./examples/browser ./docs/examples && cp ./nools.min.js ./docs/nools.js\",\n            createDocs: 'node_modules/coddoc/bin/coddoc -f multi-html -d ./lib --dir ./docs'\n        },\n\n        jshint: {\n            src: [\"./index.js\", \"lib/**/*.js\", \"Gruntfile.js\"],\n            options: {\n                jshintrc: '.jshintrc',\n                ignores: [\"./lib/parser/constraint/parser.js\"]\n            }\n        },\n        it: {\n            all: {\n                src: 'test/**/*.test.js',\n                options: {\n                    timeout: 3000, // not fully supported yet\n                    reporter: 'dotmatrix'\n                }\n            }\n        },\n        watch: {\n            files: '<config:lint.files>',\n            tasks: 'lint it'\n        },\n        uglify: {\n            options: {\n                banner: '/*! <%= pkg.name %> - v<%= pkg.version %> - ' +\n                    '<%= grunt.template.today(\"yyyy-mm-dd\") %>\\n' +\n                    '<%= pkg.homepage ? \"* \" + pkg.homepage + \"\\\\n\" : \"\" %>' +\n                    '* Copyright (c) <%= grunt.template.today(\"yyyy\") %> <%= pkg.author %>;' +\n                    ' Licensed <%= pkg.license %> */\\n',\n                report: 'min'\n            },\n            min: {\n                files: {\n                    '<%= pkg.name %>.min.js': ['nools.js']\n                }\n            }\n        },\n\n        browserify: {\n            'nools': {\n                src: ['./browser/nools.js'],\n                dest: './nools.js'\n            }\n        },\n\n        benchmark: {\n            manners: {\n                files: \"./benchmark/manners/benchmark.js\"\n            },\n            sendMoreMoney: {\n                files: \"./benchmark/sendMoreMoney/benchmark.js\"\n            },\n            simple: {\n                files: \"./benchmark/simple/benchmark.js\"\n            },\n            waltzDb: {\n                files: \"./benchmark/waltzDb/benchmark.js\"\n            }\n        }\n    });\n\n    // Default task.\n    grunt.registerTask('default', ['jshint', \"compile-tests\", 'it', 'browserify:nools', 'uglify:min', 'exec']);\n    grunt.loadNpmTasks('grunt-it');\n    grunt.loadNpmTasks('grunt-contrib-jshint');\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    grunt.loadNpmTasks('grunt-browserify');\n    grunt.loadNpmTasks('grunt-exec');\n\n    grunt.registerTask(\"compile-tests\", \"compiles all nools files\", function () {\n        var files = grunt.file.expand(\"./test/rules/*.nools\"), count = files.length, done = this.async();\n\n        function counter(err) {\n            if (err) {\n                done(err);\n            } else {\n                count--;\n                if (!count) {\n                    done();\n                }\n            }\n        }\n\n        files.forEach(function (file) {\n            var base = path.basename(file, \".nools\"),\n                out = path.resolve(path.dirname(file), base + \"-compiled.js\");\n            child.exec(path.resolve(__dirname, \"./bin/nools\") + \" compile \" + file + \" -l ../../ -n \" + base + \"-compiled\", function (err, output) {\n                if (!err) {\n                    grunt.file.write(out, output.toString());\n                }\n                counter(err);\n            });\n        });\n    });\n\n    grunt.registerTask(\"benchmarks\", function () {\n\n    });\n\n    grunt.registerMultiTask('benchmark', 'execute it unit tests in a spawned process', function () {\n        var done = this.async();\n        require(this.data.files).classic(function (err) {\n            if (err) {\n                done(false);\n            } else {\n                done();\n            }\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/nools.js":";(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function () {\n    \"use strict\";\n    var nools = require(\"../\");\n\n    if (typeof Object.getPrototypeOf !== \"function\") {\n        Object.getPrototypeOf = \"\".__proto__ === String.prototype\n            ? function (object) {\n            return object.__proto__;\n        }\n            : function (object) {\n            // May break if the constructor has been tampered with\n            return object.constructor.prototype;\n        };\n    }\n\n    if (\"function\" === typeof this.define && this.define.amd) {\n        define([], function () {\n            return nools;\n        });\n    } else {\n        this.nools = nools;\n    }\n}).call(typeof window !== \"undefined\" ? window : this);\n\n},{\"../\":2}],2:[function(require,module,exports){\nmodule.exports = exports = require(\"./lib\");\n},{\"./lib\":15}],3:[function(require,module,exports){\n\"use strict\";\nvar extd = require(\"./extended\"),\n    declare = extd.declare,\n    AVLTree = extd.AVLTree,\n    LinkedList = extd.LinkedList,\n    isPromise = extd.isPromiseLike,\n    EventEmitter = require(\"events\").EventEmitter;\n\n\nvar FactHash = declare({\n    instance: {\n        constructor: function () {\n            this.memory = {};\n            this.memoryValues = new LinkedList();\n        },\n\n        clear: function () {\n            this.memoryValues.clear();\n            this.memory = {};\n        },\n\n\n        remove: function (v) {\n            var hashCode = v.hashCode,\n                memory = this.memory,\n                ret = memory[hashCode];\n            if (ret) {\n                this.memoryValues.remove(ret);\n                delete memory[hashCode];\n            }\n            return ret;\n        },\n\n        insert: function (insert) {\n            var hashCode = insert.hashCode;\n            if (hashCode in this.memory) {\n                throw new Error(\"Activation already in agenda \" + insert.rule.name + \" agenda\");\n            }\n            this.memoryValues.push((this.memory[hashCode] = insert));\n        }\n    }\n});\n\n\nvar DEFAULT_AGENDA_GROUP = \"main\";\nmodule.exports = declare(EventEmitter, {\n\n    instance: {\n        constructor: function (flow, conflictResolution) {\n            this.agendaGroups = {};\n            this.agendaGroupStack = [DEFAULT_AGENDA_GROUP];\n            this.rules = {};\n            this.flow = flow;\n            this.comparator = conflictResolution;\n            this.setFocus(DEFAULT_AGENDA_GROUP).addAgendaGroup(DEFAULT_AGENDA_GROUP);\n        },\n\n        addAgendaGroup: function (groupName) {\n            if (!extd.has(this.agendaGroups, groupName)) {\n                this.agendaGroups[groupName] = new AVLTree({compare: this.comparator});\n            }\n        },\n\n        getAgendaGroup: function (groupName) {\n            return this.agendaGroups[groupName || DEFAULT_AGENDA_GROUP];\n        },\n\n        setFocus: function (agendaGroup) {\n            if (agendaGroup !== this.getFocused() && this.agendaGroups[agendaGroup]) {\n                this.agendaGroupStack.push(agendaGroup);\n                this.emit(\"focused\", agendaGroup);\n            }\n            return this;\n        },\n\n        getFocused: function () {\n            var ags = this.agendaGroupStack;\n            return ags[ags.length - 1];\n        },\n\n        getFocusedAgenda: function () {\n            return this.agendaGroups[this.getFocused()];\n        },\n\n        register: function (node) {\n            var agendaGroup = node.rule.agendaGroup;\n            this.rules[node.name] = {tree: new AVLTree({compare: this.comparator}), factTable: new FactHash()};\n            if (agendaGroup) {\n                this.addAgendaGroup(agendaGroup);\n            }\n        },\n\n        isEmpty: function () {\n            var agendaGroupStack = this.agendaGroupStack, changed = false;\n            while (this.getFocusedAgenda().isEmpty() && this.getFocused() !== DEFAULT_AGENDA_GROUP) {\n                agendaGroupStack.pop();\n                changed = true;\n            }\n            if (changed) {\n                this.emit(\"focused\", this.getFocused());\n            }\n            return this.getFocusedAgenda().isEmpty();\n        },\n\n        fireNext: function () {\n            var agendaGroupStack = this.agendaGroupStack, ret = false;\n            while (this.getFocusedAgenda().isEmpty() && this.getFocused() !== DEFAULT_AGENDA_GROUP) {\n                agendaGroupStack.pop();\n            }\n            if (!this.getFocusedAgenda().isEmpty()) {\n                var activation = this.pop();\n                this.emit(\"fire\", activation.rule.name, activation.match.factHash);\n                var fired = activation.rule.fire(this.flow, activation.match);\n                if (isPromise(fired)) {\n                    ret = fired.then(function () {\n                        //return true if an activation fired\n                        return true;\n                    });\n                } else {\n                    ret = true;\n                }\n            }\n            //return false if activation not fired\n            return ret;\n        },\n\n        pop: function () {\n            var tree = this.getFocusedAgenda(), root = tree.__root;\n            while (root.right) {\n                root = root.right;\n            }\n            var v = root.data;\n            tree.remove(v);\n            var rule = this.rules[v.name];\n            rule.tree.remove(v);\n            rule.factTable.remove(v);\n            return v;\n        },\n\n        peek: function () {\n            var tree = this.getFocusedAgenda(), root = tree.__root;\n            while (root.right) {\n                root = root.right;\n            }\n            return root.data;\n        },\n\n        modify: function (node, context) {\n            this.retract(node, context);\n            this.insert(node, context);\n        },\n\n        retract: function (node, retract) {\n            var rule = this.rules[node.name];\n            retract.rule = node;\n            var activation = rule.factTable.remove(retract);\n            if (activation) {\n                this.getAgendaGroup(node.rule.agendaGroup).remove(activation);\n                rule.tree.remove(activation);\n            }\n        },\n\n        insert: function (node, insert) {\n            var rule = this.rules[node.name], nodeRule = node.rule, agendaGroup = nodeRule.agendaGroup;\n            rule.tree.insert(insert);\n            this.getAgendaGroup(agendaGroup).insert(insert);\n            if (nodeRule.autoFocus) {\n                this.setFocus(agendaGroup);\n            }\n\n            rule.factTable.insert(insert);\n        },\n\n        dispose: function () {\n            for (var i in this.agendaGroups) {\n                this.agendaGroups[i].clear();\n            }\n            var rules = this.rules;\n            for (i in rules) {\n                if (i in rules) {\n                    rules[i].tree.clear();\n                    rules[i].factTable.clear();\n\n                }\n            }\n            this.rules = {};\n        }\n    }\n\n});\n},{\"./extended\":12,\"events\":60}],4:[function(require,module,exports){\n/*jshint evil:true*/\n\"use strict\";\nvar extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    isString = extd.isString;\n\nexports.modifiers = [\"assert\", \"modify\", \"retract\", \"emit\", \"halt\", \"focus\", \"getFacts\"];\n\nvar createFunction = function (body, defined, scope, scopeNames, definedNames) {\n    var declares = [];\n    forEach(definedNames, function (i) {\n        if (body.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    forEach(scopeNames, function (i) {\n        if (body.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    body = [\"((function(){\", declares.join(\"\"), \"\\n\\treturn \", body, \"\\n})())\"].join(\"\");\n    try {\n        return eval(body);\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + body + \"\\n\" + e.message);\n    }\n};\n\nvar createDefined = (function () {\n\n    var _createDefined = function (action, defined, scope) {\n        if (isString(action)) {\n            var declares = [];\n            extd(defined).keys().forEach(function (i) {\n                if (action.indexOf(i) !== -1) {\n                    declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n                }\n            });\n\n            extd(scope).keys().forEach(function (i) {\n                if (action.indexOf(i) !== -1) {\n                    declares.push(\"var \" + i + \"= function(){var prop = scope.\" + i + \"; return __objToStr__.call(prop) === '[object Function]' ? prop.apply(void 0, arguments) : prop;};\");\n                }\n            });\n            if (declares.length) {\n                declares.unshift(\"var __objToStr__ = Object.prototype.toString;\");\n            }\n            action = [declares.join(\"\"), \"return \", action, \";\"].join(\"\");\n            action = new Function(\"defined\", \"scope\", action)(defined, scope);\n        }\n        var ret = action.hasOwnProperty(\"constructor\") && \"function\" === typeof action.constructor ? action.constructor : function (opts) {\n            opts = opts || {};\n            for (var i in opts) {\n                if (i in action) {\n                    this[i] = opts[i];\n                }\n            }\n        };\n        var proto = ret.prototype;\n        for (var i in action) {\n            proto[i] = action[i];\n        }\n        return ret;\n\n    };\n\n    return function (options, defined, scope) {\n        return _createDefined(options.properties, defined, scope);\n    };\n})();\n\nexports.createFunction = createFunction;\nexports.createDefined = createDefined;\n},{\"../extended\":12}],5:[function(require,module,exports){\nvar Buffer=require(\"__browserify_Buffer\").Buffer;/*jshint evil:true*/\n\"use strict\";\nvar extd = require(\"../extended\"),\n    parser = require(\"../parser\"),\n    constraintMatcher = require(\"../constraintMatcher.js\"),\n    indexOf = extd.indexOf,\n    forEach = extd.forEach,\n    removeDuplicates = extd.removeDuplicates,\n    map = extd.map,\n    obj = extd.hash,\n    keys = obj.keys,\n    merge = extd.merge,\n    rules = require(\"../rule\"),\n    common = require(\"./common\"),\n    modifiers = common.modifiers,\n    createDefined = common.createDefined,\n    createFunction = common.createFunction;\n\n\n/**\n * @private\n * Parses an action from a rule definition\n * @param {String} action the body of the action to execute\n * @param {Array} identifiers array of identifiers collected\n * @param {Object} defined an object of defined\n * @param scope\n * @return {Object}\n */\nvar parseAction = function (action, identifiers, defined, scope) {\n    var declares = [];\n    forEach(identifiers, function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= facts.\" + i + \";\");\n        }\n    });\n    extd(defined).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    extd(scope).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    extd(modifiers).forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"if(!\" + i + \"){ var \" + i + \"= flow.\" + i + \";}\");\n        }\n    });\n    var params = [\"facts\", 'flow'];\n    if (/next\\(.*\\)/.test(action)) {\n        params.push(\"next\");\n    }\n    action = declares.join(\"\") + action;\n    try {\n        return new Function(\"defined, scope\", \"return \" + new Function(params.join(\",\"), action).toString())(defined, scope);\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + action + \"\\n\" + e.message);\n    }\n};\n\nvar createRuleFromObject = (function () {\n    var __resolveRule = function (rule, identifiers, conditions, defined, name) {\n        var condition = [], definedClass = rule[0], alias = rule[1], constraint = rule[2], refs = rule[3];\n        if (extd.isHash(constraint)) {\n            refs = constraint;\n            constraint = null;\n        }\n        if (definedClass && !!(definedClass = defined[definedClass])) {\n            condition.push(definedClass);\n        } else {\n            throw new Error(\"Invalid class \" + rule[0] + \" for rule \" + name);\n        }\n        condition.push(alias, constraint, refs);\n        conditions.push(condition);\n        identifiers.push(alias);\n        if (constraint) {\n            forEach(constraintMatcher.getIdentifiers(parser.parseConstraint(constraint)), function (i) {\n                identifiers.push(i);\n            });\n        }\n        if (extd.isObject(refs)) {\n            for (var j in refs) {\n                var ident = refs[j];\n                if (indexOf(identifiers, ident) === -1) {\n                    identifiers.push(ident);\n                }\n            }\n        }\n    };\n\n    function parseRule(rule, conditions, identifiers, defined, name) {\n        if (rule.length) {\n            var r0 = rule[0];\n            if (r0 === \"not\" || r0 === \"exists\") {\n                var temp = [];\n                rule.shift();\n                __resolveRule(rule, identifiers, temp, defined, name);\n                var cond = temp[0];\n                cond.unshift(r0);\n                conditions.push(cond);\n            } else if (r0 === \"or\") {\n                var conds = [r0];\n                rule.shift();\n                forEach(rule, function (cond) {\n                    parseRule(cond, conds, identifiers, defined, name);\n                });\n                conditions.push(conds);\n            } else {\n                __resolveRule(rule, identifiers, conditions, defined, name);\n                identifiers = removeDuplicates(identifiers);\n            }\n        }\n\n    }\n\n    return function (obj, defined, scope) {\n        var name = obj.name;\n        if (extd.isEmpty(obj)) {\n            throw new Error(\"Rule is empty\");\n        }\n        var options = obj.options || {};\n        options.scope = scope;\n        var constraints = obj.constraints || [], l = constraints.length;\n        if (!l) {\n            constraints = [\"true\"];\n        }\n        var action = obj.action;\n        if (extd.isUndefined(action)) {\n            throw new Error(\"No action was defined for rule \" + name);\n        }\n        var conditions = [], identifiers = [];\n        forEach(constraints, function (rule) {\n            parseRule(rule, conditions, identifiers, defined, name);\n        });\n        return rules.createRule(name, options, conditions, parseAction(action, identifiers, defined, scope));\n    };\n})();\n\nexports.parse = function (src, file) {\n    //parse flow from file\n    return parser.parseRuleSet(src, file);\n\n};\nexports.compile = function (flowObj, options, cb, Container) {\n    if (extd.isFunction(options)) {\n        cb = options;\n        options = {};\n    } else {\n        options = options || {};\n    }\n    var name = flowObj.name || options.name;\n    //if !name throw an error\n    if (!name) {\n        throw new Error(\"Name must be present in JSON or options\");\n    }\n    var flow = new Container(name);\n    var defined = merge({Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, options.define || {});\n    if (typeof Buffer !== \"undefined\") {\n        defined.Buffer = Buffer;\n    }\n    var scope = merge({console: console}, options.scope);\n    //add the anything added to the scope as a property\n    forEach(flowObj.scope, function (s) {\n        scope[s.name] = true;\n    });\n    //add any defined classes in the parsed flowObj to defined\n    forEach(flowObj.define, function (d) {\n        defined[d.name] = createDefined(d, defined, scope);\n    });\n\n    //expose any defined classes to the flow.\n    extd(defined).forEach(function (cls, name) {\n        flow.addDefined(name, cls);\n    });\n\n    var scopeNames = extd(flowObj.scope).pluck(\"name\").union(extd(scope).keys().value()).value();\n    var definedNames = map(keys(defined), function (s) {\n        return s;\n    });\n    forEach(flowObj.scope, function (s) {\n        scope[s.name] = createFunction(s.body, defined, scope, scopeNames, definedNames);\n    });\n    var rules = flowObj.rules;\n    if (rules.length) {\n        forEach(rules, function (rule) {\n            flow.__rules = flow.__rules.concat(createRuleFromObject(rule, defined, scope));\n        });\n    }\n    if (cb) {\n        cb.call(flow, flow);\n    }\n    return flow;\n};\n\nexports.transpile = require(\"./transpile\").transpile;\n\n\n\n\n},{\"../constraintMatcher.js\":9,\"../extended\":12,\"../parser\":44,\"../rule\":49,\"./common\":4,\"./transpile\":6,\"__browserify_Buffer\":63}],6:[function(require,module,exports){\nvar Buffer=require(\"__browserify_Buffer\").Buffer;var extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    indexOf = extd.indexOf,\n    merge = extd.merge,\n    isString = extd.isString,\n    modifiers = require(\"./common\").modifiers,\n    constraintMatcher = require(\"../constraintMatcher\"),\n    parser = require(\"../parser\");\n\nfunction definedToJs(options) {\n    /*jshint evil:true*/\n    options = isString(options) ? new Function(\"return \" + options + \";\")() : options;\n    var ret = [\"(function(){\"], value;\n\n    if (options.hasOwnProperty(\"constructor\") && \"function\" === typeof options.constructor) {\n        ret.push(\"var Defined = \" + options.constructor.toString() + \";\");\n    } else {\n        ret.push(\"var Defined = function(opts){ for(var i in opts){if(opts.hasOwnProperty(i)){this[i] = opts[i];}}};\");\n    }\n    ret.push(\"var proto = Defined.prototype;\");\n    for (var key in options) {\n        if (options.hasOwnProperty(key)) {\n            value = options[key];\n            ret.push(\"proto.\" + key + \" = \" + (extd.isFunction(value) ? value.toString() : extd.format(\"%j\", value)) + \";\");\n        }\n    }\n    ret.push(\"return Defined;\");\n    ret.push(\"}())\");\n    return ret.join(\"\");\n\n}\n\nfunction actionToJs(action, identifiers, defined, scope) {\n    var declares = [], usedVars = {};\n    forEach(identifiers, function (i) {\n        if (action.indexOf(i) !== -1) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= facts.\" + i + \";\");\n        }\n    });\n    extd(defined).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    extd(scope).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    extd(modifiers).forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            declares.push(\"var \" + i + \"= flow.\" + i + \";\");\n        }\n    });\n    var params = [\"facts\", 'flow'];\n    if (/next\\(.*\\)/.test(action)) {\n        params.push(\"next\");\n    }\n    action = declares.join(\"\") + action;\n    try {\n        return [\"function(\", params.join(\",\"), \"){\", action, \"}\"].join(\"\");\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + action + \"\\n\" + e.message);\n    }\n}\n\nfunction parseConstraintModifier(constraint, ret) {\n    if (constraint.length && extd.isString(constraint[0])) {\n        var modifier = constraint[0].match(\" *(from)\");\n        if (modifier) {\n            modifier = modifier[0];\n            switch (modifier) {\n            case \"from\":\n                ret.push(', \"', constraint.shift(), '\"');\n                break;\n            default:\n                throw new Error(\"Unrecognized modifier \" + modifier);\n            }\n        }\n    }\n}\n\nfunction parseConstraintHash(constraint, ret, identifiers) {\n    if (constraint.length && extd.isHash(constraint[0])) {\n        //ret of options\n        var refs = constraint.shift();\n        extd(refs).values().forEach(function (ident) {\n            if (indexOf(identifiers, ident) === -1) {\n                identifiers.push(ident);\n            }\n        });\n        ret.push(',' + extd.format('%j', [refs]));\n    }\n}\n\nfunction constraintsToJs(constraint, identifiers) {\n    constraint = constraint.slice(0);\n    var ret = [];\n    if (constraint[0] === \"or\") {\n        ret.push('[\"' + constraint.shift() + '\"');\n        ret.push(extd.map(constraint,function (c) {\n            return constraintsToJs(c, identifiers);\n        }).join(\",\") + \"]\");\n        return ret;\n    } else if (constraint[0] === \"not\" || constraint[0] === \"exists\") {\n        ret.push('\"', constraint.shift(), '\", ');\n    }\n    identifiers.push(constraint[1]);\n    ret.push(constraint[0], ', \"' + constraint[1].replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + '\"');\n    constraint.splice(0, 2);\n    if (constraint.length) {\n        //constraint\n        var c = constraint.shift();\n        if (extd.isString(c) && c) {\n            ret.push(',\"' + c.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\"), '\"');\n            forEach(constraintMatcher.getIdentifiers(parser.parseConstraint(c)), function (i) {\n                identifiers.push(i);\n            });\n        } else {\n            ret.push(',\"true\"');\n            constraint.unshift(c);\n        }\n    }\n    parseConstraintModifier(constraint, ret);\n    parseConstraintHash(constraint, ret, identifiers);\n    return '[' + ret.join(\"\") + ']';\n}\n\nexports.transpile = function (flowObj, options) {\n    options = options || {};\n    var ret = [];\n    ret.push(\"(function(){\");\n    ret.push(\"return function(options){\");\n    ret.push(\"options = options || {};\");\n    ret.push(\"var bind = function(scope, fn){return function(){return fn.apply(scope, arguments);};}, defined = {Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, scope = options.scope || {};\");\n    ret.push(\"var optDefined = options.defined || {}; for(var i in optDefined){defined[i] = optDefined[i];}\");\n    var defined = merge({Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, options.define || {});\n    if (typeof Buffer !== \"undefined\") {\n        defined.Buffer = Buffer;\n    }\n    var scope = merge({console: console}, options.scope);\n    ret.push([\"return nools.flow('\", options.name, \"', function(){\"].join(\"\"));\n    //add any defined classes in the parsed flowObj to defined\n    ret.push(extd(flowObj.define || []).map(function (defined) {\n        var name = defined.name;\n        defined[name] = {};\n        return [\"var\", name, \"= defined.\" + name, \"= this.addDefined('\" + name + \"',\", definedToJs(defined.properties) + \");\"].join(\" \");\n    }).value().join(\"\\n\"));\n    ret.push(extd(flowObj.scope || []).map(function (s) {\n        var name = s.name;\n        scope[name] = {};\n        return [\"var\", name, \"= scope.\" + name, \"= \", s.body, \";\"].join(\" \");\n    }).value().join(\"\\n\"));\n    ret.push(\"scope.console = console;\\n\");\n\n\n    ret.push(extd(flowObj.rules || []).map(function (rule) {\n        var identifiers = [], ret = [\"this.rule('\", rule.name.replace(/'/g, \"\\\\'\"), \"'\"], options = extd.merge(rule.options || {}, {scope: \"scope\"});\n        ret.push(\",\", extd.format(\"%j\", [options]).replace(/(:\"scope\")/, \":scope\"));\n        if (rule.constraints && !extd.isEmpty(rule.constraints)) {\n            ret.push(\", [\");\n            ret.push(extd(rule.constraints).map(function (c) {\n                return constraintsToJs(c, identifiers);\n            }).value().join(\",\"));\n            ret.push(\"]\");\n        }\n        ret.push(\",\", actionToJs(rule.action, identifiers, defined, scope));\n        ret.push(\");\");\n        return ret.join(\"\");\n    }).value().join(\"\"));\n    ret.push(\"});\");\n    ret.push(\"};\");\n    ret.push(\"}());\");\n    return ret.join(\"\");\n};\n\n\n\n},{\"../constraintMatcher\":9,\"../extended\":12,\"../parser\":44,\"./common\":4,\"__browserify_Buffer\":63}],7:[function(require,module,exports){\nvar map = require(\"./extended\").map;\n\nfunction salience(a, b) {\n    return a.rule.priority - b.rule.priority;\n}\n\nfunction bucketCounter(a, b) {\n    return a.counter - b.counter;\n}\n\nfunction factRecency(a, b) {\n    /*jshint noempty: false*/\n\n    var i = 0;\n    var aMatchRecency = a.match.recency,\n        bMatchRecency = b.match.recency, aLength = aMatchRecency.length - 1, bLength = bMatchRecency.length - 1;\n    while (aMatchRecency[i] === bMatchRecency[i] && i < aLength && i < bLength && i++) {\n    }\n    var ret = aMatchRecency[i] - bMatchRecency[i];\n    if (!ret) {\n        ret = aLength - bLength;\n    }\n    return ret;\n}\n\nfunction activationRecency(a, b) {\n    return a.recency - b.recency;\n}\n\nvar strategies = {\n    salience: salience,\n    bucketCounter: bucketCounter,\n    factRecency: factRecency,\n    activationRecency: activationRecency\n};\n\nexports.strategies = strategies;\nexports.strategy = function (strats) {\n    strats = map(strats, function (s) {\n        return strategies[s];\n    });\n    var stratsLength = strats.length;\n\n    return function (a, b) {\n        var i = -1, ret = 0;\n        var equal = (a === b) || (a.name === b.name && a.hashCode === b.hashCode);\n        if (!equal) {\n            while (++i < stratsLength && !ret) {\n                ret = strats[i](a, b);\n            }\n            ret = ret > 0 ? 1 : -1;\n        }\n        return ret;\n    };\n};\n},{\"./extended\":12}],8:[function(require,module,exports){\n\"use strict\";\n\nvar extd = require(\"./extended\"),\n    deepEqual = extd.deepEqual,\n    merge = extd.merge,\n    instanceOf = extd.instanceOf,\n    filter = extd.filter,\n    declare = extd.declare,\n    constraintMatcher;\n\nvar id = 0;\nvar Constraint = declare({\n\n    type: null,\n\n    instance: {\n        constructor: function (constraint) {\n            if (!constraintMatcher) {\n                constraintMatcher = require(\"./constraintMatcher\");\n            }\n            this.id = id++;\n            this.constraint = constraint;\n            extd.bindAll(this, [\"assert\"]);\n        },\n        \"assert\": function () {\n            throw new Error(\"not implemented\");\n        },\n\n        getIndexableProperties: function () {\n            return [];\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n        getters: {\n            variables: function () {\n                return [this.get(\"alias\")];\n            }\n        }\n\n\n    }\n});\n\nConstraint.extend({\n    instance: {\n\n        type: \"object\",\n\n        constructor: function (type) {\n            this._super([type]);\n        },\n\n        \"assert\": function (param) {\n            return param instanceof this.constraint || param.constructor === this.constraint;\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.constraint === constraint.constraint;\n        }\n    }\n}).as(exports, \"ObjectConstraint\");\n\nvar EqualityConstraint = Constraint.extend({\n\n    instance: {\n\n        type: \"equality\",\n\n        constructor: function (constraint, options) {\n            this._super([constraint]);\n            options = options || {};\n            this.pattern = options.pattern;\n            this._matcher = constraintMatcher.getMatcher(constraint, options, true);\n        },\n\n        \"assert\": function (values) {\n            return this._matcher(values);\n        }\n    }\n}).as(exports, \"EqualityConstraint\");\n\nEqualityConstraint.extend({instance: {type: \"inequality\"}}).as(exports, \"InequalityConstraint\");\nEqualityConstraint.extend({instance: {type: \"comparison\"}}).as(exports, \"ComparisonConstraint\");\n\nConstraint.extend({\n\n    instance: {\n\n        type: \"equality\",\n\n        constructor: function () {\n            this._super([\n                [true]\n            ]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\");\n        },\n\n\n        \"assert\": function () {\n            return true;\n        }\n    }\n}).as(exports, \"TrueConstraint\");\n\nvar ReferenceConstraint = Constraint.extend({\n\n    instance: {\n\n        type: \"reference\",\n\n        constructor: function (constraint, options) {\n            this.cache = {};\n            this._super([constraint]);\n            options = options || {};\n            this.values = [];\n            this.pattern = options.pattern;\n            this._options = options;\n            this._matcher = constraintMatcher.getMatcher(constraint, options, false);\n        },\n\n        \"assert\": function (fact, fh) {\n            try {\n                return this._matcher(fact, fh);\n            } catch (e) {\n                throw new Error(\"Error with evaluating pattern \" + this.pattern + \" \" + e.message);\n            }\n\n        },\n\n        merge: function (that) {\n            var ret = this;\n            if (that instanceof ReferenceConstraint) {\n                ret = new this._static([this.constraint, that.constraint, \"and\"], merge({}, this._options, this._options));\n                ret._alias = this._alias || that._alias;\n                ret.vars = this.vars.concat(that.vars);\n            }\n            return ret;\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n\n        getters: {\n            variables: function () {\n                return this.vars;\n            },\n\n            alias: function () {\n                return this._alias;\n            }\n        },\n\n        setters: {\n            alias: function (alias) {\n                this._alias = alias;\n                this.vars = filter(constraintMatcher.getIdentifiers(this.constraint), function (v) {\n                    return v !== alias;\n                });\n            }\n        }\n    }\n\n}).as(exports, \"ReferenceConstraint\");\n\n\nReferenceConstraint.extend({\n    instance: {\n        type: \"reference_equality\",\n        op: \"eq\",\n        getIndexableProperties: function () {\n            return constraintMatcher.getIndexableProperties(this.constraint);\n        }\n    }\n}).as(exports, \"ReferenceEqualityConstraint\")\n    .extend({instance: {type: \"reference_inequality\", op: \"neq\"}}).as(exports, \"ReferenceInequalityConstraint\")\n    .extend({instance: {type: \"reference_gt\", op: \"gt\"}}).as(exports, \"ReferenceGTConstraint\")\n    .extend({instance: {type: \"reference_gte\", op: \"gte\"}}).as(exports, \"ReferenceGTEConstraint\")\n    .extend({instance: {type: \"reference_lt\", op: \"lt\"}}).as(exports, \"ReferenceLTConstraint\")\n    .extend({instance: {type: \"reference_lte\", op: \"lte\"}}).as(exports, \"ReferenceLTEConstraint\");\n\n\nConstraint.extend({\n    instance: {\n\n        type: \"hash\",\n\n        constructor: function (hash) {\n            this._super([hash]);\n        },\n\n        equal: function (constraint) {\n            return extd.instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n        \"assert\": function () {\n            return true;\n        },\n\n        getters: {\n            variables: function () {\n                return this.constraint;\n            }\n        }\n\n    }\n}).as(exports, \"HashConstraint\");\n\nConstraint.extend({\n    instance: {\n        constructor: function (constraints, options) {\n            this.type = \"from\";\n            this.constraints = constraintMatcher.getSourceMatcher(constraints, (options || {}), true);\n            extd.bindAll(this, [\"assert\"]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && deepEqual(this.constraints, constraint.constraints);\n        },\n\n        \"assert\": function (fact, fh) {\n            return this.constraints(fact, fh);\n        },\n\n        getters: {\n            variables: function () {\n                return this.constraint;\n            }\n        }\n\n    }\n}).as(exports, \"FromConstraint\");\n\nConstraint.extend({\n    instance: {\n        constructor: function (func, options) {\n            this.type = \"custom\";\n            this.fn = func;\n            this.options = options;\n            extd.bindAll(this, [\"assert\"]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.fn === constraint.constraint;\n        },\n\n        \"assert\": function (fact, fh) {\n            return this.fn(fact, fh);\n        }\n    }\n}).as(exports, \"CustomConstraint\");\n\n\n\n},{\"./constraintMatcher\":9,\"./extended\":12}],9:[function(require,module,exports){\n\"use strict\";\n\nvar extd = require(\"./extended\"),\n    isArray = extd.isArray,\n    forEach = extd.forEach,\n    some = extd.some,\n    indexOf = extd.indexOf,\n    isNumber = extd.isNumber,\n    removeDups = extd.removeDuplicates,\n    atoms = require(\"./constraint\");\n\nfunction getProps(val) {\n    return extd(val).map(function mapper(val) {\n        return isArray(val) ? isArray(val[0]) ? getProps(val).value() : val.reverse().join(\".\") : val;\n    }).flatten().filter(function (v) {\n        return !!v;\n    });\n}\n\nvar definedFuncs = {\n    indexOf: extd.indexOf,\n    now: function () {\n        return new Date();\n    },\n\n    Date: function (y, m, d, h, min, s, ms) {\n        var date = new Date();\n        if (isNumber(y)) {\n            date.setYear(y);\n        }\n        if (isNumber(m)) {\n            date.setMonth(m);\n        }\n        if (isNumber(d)) {\n            date.setDate(d);\n        }\n        if (isNumber(h)) {\n            date.setHours(h);\n        }\n        if (isNumber(min)) {\n            date.setMinutes(min);\n        }\n        if (isNumber(s)) {\n            date.setSeconds(s);\n        }\n        if (isNumber(ms)) {\n            date.setMilliseconds(ms);\n        }\n        return date;\n    },\n\n    lengthOf: function (arr, length) {\n        return arr.length === length;\n    },\n\n    isTrue: function (val) {\n        return val === true;\n    },\n\n    isFalse: function (val) {\n        return val === false;\n    },\n\n    isNotNull: function (actual) {\n        return actual !== null;\n    },\n\n    dateCmp: function (dt1, dt2) {\n        return extd.compare(dt1, dt2);\n    }\n\n};\n\nforEach([\"years\", \"days\", \"months\", \"hours\", \"minutes\", \"seconds\"], function (k) {\n    definedFuncs[k + \"FromNow\"] = extd[k + \"FromNow\"];\n    definedFuncs[k + \"Ago\"] = extd[k + \"Ago\"];\n});\n\n\nforEach([\"isArray\", \"isNumber\", \"isHash\", \"isObject\", \"isDate\", \"isBoolean\", \"isString\", \"isRegExp\", \"isNull\", \"isEmpty\",\n    \"isUndefined\", \"isDefined\", \"isUndefinedOrNull\", \"isPromiseLike\", \"isFunction\", \"deepEqual\"], function (k) {\n    var m = extd[k];\n    definedFuncs[k] = function () {\n        return m.apply(extd, arguments);\n    };\n});\n\n\nvar lang = {\n\n    equal: function (c1, c2) {\n        var ret = false;\n        if (c1 === c2) {\n            ret = true;\n        } else {\n            if (c1[2] === c2[2]) {\n                if (indexOf([\"string\", \"number\", \"boolean\", \"regexp\", \"identifier\", \"null\"], c1[2]) !== -1) {\n                    ret = c1[0] === c2[0];\n                } else if (c1[2] === \"unary\" || c1[2] === \"logicalNot\") {\n                    ret = this.equal(c1[0], c2[0]);\n                } else {\n                    ret = this.equal(c1[0], c2[0]) && this.equal(c1[1], c2[1]);\n                }\n            }\n        }\n        return ret;\n    },\n\n    __getProperties: function (rule) {\n        var ret = [];\n        if (rule) {\n            var rule2 = rule[2];\n            if (!rule2) {\n                return ret;\n            }\n            if (rule2 !== \"prop\" &&\n                rule2 !== \"identifier\" &&\n                rule2 !== \"string\" &&\n                rule2 !== \"number\" &&\n                rule2 !== \"boolean\" &&\n                rule2 !== \"regexp\" &&\n                rule2 !== \"unary\" &&\n                rule2 !== \"unary\") {\n                ret[0] = this.__getProperties(rule[0]);\n                ret[1] = this.__getProperties(rule[1]);\n            } else if (rule2 === \"identifier\") {\n                //at the bottom\n                ret = [rule[0]];\n            } else {\n                ret = lang.__getProperties(rule[1]).concat(lang.__getProperties(rule[0]));\n            }\n        }\n        return ret;\n    },\n\n    getIndexableProperties: function (rule) {\n        if (rule[2] === \"composite\") {\n            return this.getIndexableProperties(rule[0]);\n        } else if (/^(\\w+(\\['[^']*'])*) *([!=]==?|[<>]=?) (\\w+(\\['[^']*'])*)$/.test(this.parse(rule))) {\n            return getProps(this.__getProperties(rule)).flatten().value();\n        } else {\n            return [];\n        }\n    },\n\n    getIdentifiers: function (rule) {\n        var ret = [];\n        var rule2 = rule[2];\n\n        if (rule2 === \"identifier\") {\n            //its an identifier so stop\n            return [rule[0]];\n        } else if (rule2 === \"function\") {\n            ret = ret.concat(this.getIdentifiers(rule[0])).concat(this.getIdentifiers(rule[1]));\n        } else if (rule2 !== \"string\" &&\n            rule2 !== \"number\" &&\n            rule2 !== \"boolean\" &&\n            rule2 !== \"regexp\" &&\n            rule2 !== \"unary\" &&\n            rule2 !== \"unary\") {\n            //its an expression so keep going\n            if (rule2 === \"prop\") {\n                ret = ret.concat(this.getIdentifiers(rule[0]));\n                if (rule[1]) {\n                    var propChain = rule[1];\n                    //go through the member variables and collect any identifiers that may be in functions\n                    while (isArray(propChain)) {\n                        if (propChain[2] === \"function\") {\n                            ret = ret.concat(this.getIdentifiers(propChain[1]));\n                            break;\n                        } else {\n                            propChain = propChain[1];\n                        }\n                    }\n                }\n\n            } else {\n                if (rule[0]) {\n                    ret = ret.concat(this.getIdentifiers(rule[0]));\n                }\n                if (rule[1]) {\n                    ret = ret.concat(this.getIdentifiers(rule[1]));\n                }\n            }\n        }\n        //remove dups and return\n        return removeDups(ret);\n    },\n\n    toConstraints: function (rule, options) {\n        var ret = [],\n            alias = options.alias,\n            scope = options.scope || {};\n\n        var rule2 = rule[2];\n\n\n        if (rule2 === \"and\") {\n            ret = ret.concat(this.toConstraints(rule[0], options)).concat(this.toConstraints(rule[1], options));\n        } else if (\n            rule2 === \"composite\" ||\n            rule2 === \"or\" ||\n            rule2 === \"lt\" ||\n            rule2 === \"gt\" ||\n            rule2 === \"lte\" ||\n            rule2 === \"gte\" ||\n            rule2 === \"like\" ||\n            rule2 === \"notLike\" ||\n            rule2 === \"eq\" ||\n            rule2 === \"neq\" ||\n            rule2 === \"seq\" ||\n            rule2 === \"sneq\" ||\n            rule2 === \"in\" ||\n            rule2 === \"notIn\" ||\n            rule2 === \"prop\" ||\n            rule2 === \"propLookup\" ||\n            rule2 === \"function\" ||\n            rule2 === \"logicalNot\") {\n            var isReference = some(this.getIdentifiers(rule), function (i) {\n                return i !== alias && !(i in definedFuncs) && !(i in scope);\n            });\n            switch (rule2) {\n            case \"eq\":\n                ret.push(new atoms[isReference ? \"ReferenceEqualityConstraint\" : \"EqualityConstraint\"](rule, options));\n                break;\n            case \"seq\":\n                ret.push(new atoms[isReference ? \"ReferenceEqualityConstraint\" : \"EqualityConstraint\"](rule, options));\n                break;\n            case \"neq\":\n                ret.push(new atoms[isReference ? \"ReferenceInequalityConstraint\" : \"InequalityConstraint\"](rule, options));\n                break;\n            case \"sneq\":\n                ret.push(new atoms[isReference ? \"ReferenceInequalityConstraint\" : \"InequalityConstraint\"](rule, options));\n                break;\n            case \"gt\":\n                ret.push(new atoms[isReference ? \"ReferenceGTConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"gte\":\n                ret.push(new atoms[isReference ? \"ReferenceGTEConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"lt\":\n                ret.push(new atoms[isReference ? \"ReferenceLTConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"lte\":\n                ret.push(new atoms[isReference ? \"ReferenceLTEConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            default:\n                ret.push(new atoms[isReference ? \"ReferenceConstraint\" : \"ComparisonConstraint\"](rule, options));\n            }\n\n        }\n        return ret;\n    },\n\n\n    parse: function (rule) {\n        return this[rule[2]](rule[0], rule[1]);\n    },\n\n    composite: function (lhs) {\n        return this.parse(lhs);\n    },\n\n    and: function (lhs, rhs) {\n        return [\"(\", this.parse(lhs), \"&&\", this.parse(rhs), \")\"].join(\" \");\n    },\n\n    or: function (lhs, rhs) {\n        return [\"(\", this.parse(lhs), \"||\", this.parse(rhs), \")\"].join(\" \");\n    },\n\n    prop: function (name, prop) {\n        if (prop[2] === \"function\") {\n            return [this.parse(name), this.parse(prop)].join(\".\");\n        } else {\n            return [this.parse(name), \"['\", this.parse(prop), \"']\"].join(\"\");\n        }\n    },\n\n    propLookup: function (name, prop) {\n        if (prop[2] === \"function\") {\n            return [this.parse(name), this.parse(prop)].join(\".\");\n        } else {\n            return [this.parse(name), \"[\", this.parse(prop), \"]\"].join(\"\");\n        }\n    },\n\n    unary: function (lhs) {\n        return -1 * this.parse(lhs);\n    },\n\n    plus: function (lhs, rhs) {\n        return [this.parse(lhs), \"+\", this.parse(rhs)].join(\" \");\n    },\n    minus: function (lhs, rhs) {\n        return [this.parse(lhs), \"-\", this.parse(rhs)].join(\" \");\n    },\n\n    mult: function (lhs, rhs) {\n        return [this.parse(lhs), \"*\", this.parse(rhs)].join(\" \");\n    },\n\n    div: function (lhs, rhs) {\n        return [this.parse(lhs), \"/\", this.parse(rhs)].join(\" \");\n    },\n\n    mod: function (lhs, rhs) {\n        return [this.parse(lhs), \"%\", this.parse(rhs)].join(\" \");\n    },\n\n    lt: function (lhs, rhs) {\n        return [this.parse(lhs), \"<\", this.parse(rhs)].join(\" \");\n    },\n    gt: function (lhs, rhs) {\n        return [this.parse(lhs), \">\", this.parse(rhs)].join(\" \");\n    },\n    lte: function (lhs, rhs) {\n        return [this.parse(lhs), \"<=\", this.parse(rhs)].join(\" \");\n    },\n    gte: function (lhs, rhs) {\n        return [this.parse(lhs), \">=\", this.parse(rhs)].join(\" \");\n    },\n    like: function (lhs, rhs) {\n        return [this.parse(rhs), \".test(\", this.parse(lhs), \")\"].join(\"\");\n    },\n    notLike: function (lhs, rhs) {\n        return [\"!\", this.parse(rhs), \".test(\", this.parse(lhs), \")\"].join(\"\");\n    },\n    eq: function (lhs, rhs) {\n        return [this.parse(lhs), \"==\", this.parse(rhs)].join(\" \");\n    },\n\n    seq: function (lhs, rhs) {\n        return [this.parse(lhs), \"===\", this.parse(rhs)].join(\" \");\n    },\n\n    neq: function (lhs, rhs) {\n        return [this.parse(lhs), \"!=\", this.parse(rhs)].join(\" \");\n    },\n\n    sneq: function (lhs, rhs) {\n        return [this.parse(lhs), \"!==\", this.parse(rhs)].join(\" \");\n    },\n\n    \"in\": function (lhs, rhs) {\n        return [\"(indexOf(\", this.parse(rhs), \",\", this.parse(lhs), \")) != -1\"].join(\"\");\n    },\n\n    \"notIn\": function (lhs, rhs) {\n        return [\"(indexOf(\", this.parse(rhs), \",\", this.parse(lhs), \")) == -1\"].join(\"\");\n    },\n\n    \"arguments\": function (lhs, rhs) {\n        var ret = [];\n        if (lhs) {\n            ret.push(this.parse(lhs));\n        }\n        if (rhs) {\n            ret.push(this.parse(rhs));\n        }\n        return ret.join(\",\");\n    },\n\n    \"array\": function (lhs) {\n        var args = [];\n        if (lhs) {\n            args = this.parse(lhs);\n            if (isArray(args)) {\n                return args;\n            } else {\n                return [\"[\", args, \"]\"].join(\"\");\n            }\n        }\n        return [\"[\", args.join(\",\"), \"]\"].join(\"\");\n    },\n\n    \"function\": function (lhs, rhs) {\n        var args = this.parse(rhs);\n        return [this.parse(lhs), \"(\", args, \")\"].join(\"\");\n    },\n\n    \"string\": function (lhs) {\n        return \"'\" + lhs + \"'\";\n    },\n\n    \"number\": function (lhs) {\n        return lhs;\n    },\n\n    \"boolean\": function (lhs) {\n        return lhs;\n    },\n\n    regexp: function (lhs) {\n        return lhs;\n    },\n\n    identifier: function (lhs) {\n        return lhs;\n    },\n\n    \"null\": function () {\n        return \"null\";\n    },\n\n    logicalNot: function (lhs) {\n        return [\"!(\", this.parse(lhs), \")\"].join(\"\");\n    }\n};\n\nvar matcherCount = 0;\nvar toJs = exports.toJs = function (rule, scope, alias, equality, wrap) {\n    /*jshint evil:true*/\n    var js = lang.parse(rule);\n    scope = scope || {};\n    var vars = lang.getIdentifiers(rule);\n    var closureVars = [\"var indexOf = definedFuncs.indexOf; var hasOwnProperty = Object.prototype.hasOwnProperty;\"], funcVars = [];\n    extd(vars).filter(function (v) {\n        var ret = [\"var \", v, \" = \"];\n        if (definedFuncs.hasOwnProperty(v)) {\n            ret.push(\"definedFuncs['\", v, \"']\");\n        } else if (scope.hasOwnProperty(v)) {\n            ret.push(\"scope['\", v, \"']\");\n        } else {\n            return true;\n        }\n        ret.push(\";\");\n        closureVars.push(ret.join(\"\"));\n        return false;\n    }).forEach(function (v) {\n        var ret = [\"var \", v, \" = \"];\n        if (equality || v !== alias) {\n            ret.push(\"fact.\" + v);\n        } else if (v === alias) {\n            ret.push(\"hash.\", v, \"\");\n        }\n        ret.push(\";\");\n        funcVars.push(ret.join(\"\"));\n    });\n    var closureBody = closureVars.join(\"\") + \"return function matcher\" + (matcherCount++) + (!equality ? \"(fact, hash){\" : \"(fact){\") + funcVars.join(\"\") + \" return \" + (wrap ? wrap(js) : js) + \";}\";\n    var f = new Function(\"definedFuncs, scope\", closureBody)(definedFuncs, scope);\n    //console.log(f.toString());\n    return f;\n};\n\nexports.getMatcher = function (rule, options, equality) {\n    options = options || {};\n    return toJs(rule, options.scope, options.alias, equality, function (src) {\n        return \"!!(\" + src + \")\";\n    });\n};\n\nexports.getSourceMatcher = function (rule, options, equality) {\n    options = options || {};\n    return toJs(rule, options.scope, options.alias, equality, function (src) {\n        return src;\n    });\n};\n\nexports.toConstraints = function (constraint, options) {\n    if (typeof constraint === 'function') {\n        return [new atoms.CustomConstraint(constraint, options)];\n    }\n    //constraint.split(\"&&\")\n    return lang.toConstraints(constraint, options);\n};\n\nexports.equal = function (c1, c2) {\n    return lang.equal(c1, c2);\n};\n\nexports.getIdentifiers = function (constraint) {\n    return lang.getIdentifiers(constraint);\n};\n\nexports.getIndexableProperties = function (constraint) {\n    return lang.getIndexableProperties(constraint);\n};\n},{\"./constraint\":8,\"./extended\":12}],10:[function(require,module,exports){\n\"use strict\";\nvar extd = require(\"./extended\"),\n    isBoolean = extd.isBoolean,\n    declare = extd.declare,\n    indexOf = extd.indexOf,\n    pPush = Array.prototype.push;\n\nfunction createContextHash(paths, hashCode) {\n    var ret = \"\",\n        i = -1,\n        l = paths.length;\n    while (++i < l) {\n        ret += paths[i].id + \":\";\n    }\n    ret += hashCode;\n    return ret;\n}\n\nfunction merge(h1, h2, aliases) {\n    var i = -1, l = aliases.length, alias;\n    while (++i < l) {\n        alias = aliases[i];\n        h1[alias] = h2[alias];\n    }\n}\n\nfunction unionRecency(arr, arr1, arr2) {\n    pPush.apply(arr, arr1);\n    var i = -1, l = arr2.length, val, j = arr.length;\n    while (++i < l) {\n        val = arr2[i];\n        if (indexOf(arr, val) === -1) {\n            arr[j++] = val;\n        }\n    }\n}\n\nvar Match = declare({\n    instance: {\n\n        isMatch: true,\n        hashCode: \"\",\n        facts: null,\n        factIds: null,\n        factHash: null,\n        recency: null,\n        aliases: null,\n\n        constructor: function () {\n            this.facts = [];\n            this.factIds = [];\n            this.factHash = {};\n            this.recency = [];\n            this.aliases = [];\n        },\n\n        addFact: function (assertable) {\n            pPush.call(this.facts, assertable);\n            pPush.call(this.recency, assertable.recency);\n            pPush.call(this.factIds, assertable.id);\n            this.hashCode = this.factIds.join(\":\");\n            return this;\n        },\n\n        merge: function (mr) {\n            var ret = new Match();\n            ret.isMatch = mr.isMatch;\n            pPush.apply(ret.facts, this.facts);\n            pPush.apply(ret.facts, mr.facts);\n            pPush.apply(ret.aliases, this.aliases);\n            pPush.apply(ret.aliases, mr.aliases);\n            ret.hashCode = this.hashCode + \":\" + mr.hashCode;\n            merge(ret.factHash, this.factHash, this.aliases);\n            merge(ret.factHash, mr.factHash, mr.aliases);\n            unionRecency(ret.recency, this.recency, mr.recency);\n            return ret;\n        }\n    }\n});\n\nvar Context = declare({\n    instance: {\n        match: null,\n        factHash: null,\n        aliases: null,\n        fact: null,\n        hashCode: null,\n        paths: null,\n        pathsHash: null,\n\n        constructor: function (fact, paths, mr) {\n            this.fact = fact;\n            if (mr) {\n                this.match = mr;\n            } else {\n                this.match = new Match().addFact(fact);\n            }\n            this.factHash = this.match.factHash;\n            this.aliases = this.match.aliases;\n            this.hashCode = this.match.hashCode;\n            if (paths) {\n                this.paths = paths;\n                this.pathsHash = createContextHash(paths, this.hashCode);\n            } else {\n                this.pathsHash = this.hashCode;\n            }\n        },\n\n        \"set\": function (key, value) {\n            this.factHash[key] = value;\n            this.aliases.push(key);\n            return this;\n        },\n\n        isMatch: function (isMatch) {\n            if (isBoolean(isMatch)) {\n                this.match.isMatch = isMatch;\n            } else {\n                return this.match.isMatch;\n            }\n            return this;\n        },\n\n        mergeMatch: function (merge) {\n            var match = this.match = this.match.merge(merge);\n            this.factHash = match.factHash;\n            this.hashCode = match.hashCode;\n            this.aliases = match.aliases;\n            return this;\n        },\n\n        clone: function (fact, paths, match) {\n            return new Context(fact || this.fact, paths || this.path, match || this.match);\n        }\n    }\n}).as(module);\n\n\n\n},{\"./extended\":12}],11:[function(require,module,exports){\nvar extd = require(\"./extended\"),\n    Promise = extd.Promise,\n    nextTick = require(\"./nextTick\"),\n    isPromiseLike = extd.isPromiseLike;\n\nPromise.extend({\n    instance: {\n\n        looping: false,\n\n        constructor: function (flow, matchUntilHalt) {\n            this._super([]);\n            this.flow = flow;\n            this.agenda = flow.agenda;\n            this.rootNode = flow.rootNode;\n            this.matchUntilHalt = !!(matchUntilHalt);\n            extd.bindAll(this, [\"onAlter\", \"callNext\"]);\n        },\n\n        halt: function () {\n            this.__halted = true;\n            if (!this.looping) {\n                this.callback();\n            }\n        },\n\n        onAlter: function () {\n            this.flowAltered = true;\n            if (!this.looping && this.matchUntilHalt && !this.__halted) {\n                this.callNext();\n            }\n        },\n\n        setup: function () {\n            var flow = this.flow;\n            this.rootNode.resetCounter();\n            flow.on(\"assert\", this.onAlter);\n            flow.on(\"modify\", this.onAlter);\n            flow.on(\"retract\", this.onAlter);\n        },\n\n        tearDown: function () {\n            var flow = this.flow;\n            flow.removeListener(\"assert\", this.onAlter);\n            flow.removeListener(\"modify\", this.onAlter);\n            flow.removeListener(\"retract\", this.onAlter);\n        },\n\n        __handleAsyncNext: function (next) {\n            var self = this, agenda = self.agenda;\n            return next.then(function () {\n                self.looping = false;\n                if (!agenda.isEmpty()) {\n                    if (self.flowAltered) {\n                        self.rootNode.incrementCounter();\n                        self.flowAltered = false;\n                    }\n                    if (!self.__halted) {\n                        self.callNext();\n                    } else {\n                        self.callback();\n                    }\n                } else if (!self.matchUntilHalt || self.__halted) {\n                    self.callback();\n                }\n                self = null;\n            }, this.errback);\n        },\n\n        __handleSyncNext: function (next) {\n            this.looping = false;\n            if (!this.agenda.isEmpty()) {\n                if (this.flowAltered) {\n                    this.rootNode.incrementCounter();\n                    this.flowAltered = false;\n                }\n            }\n            if (next && !this.__halted) {\n                nextTick(this.callNext);\n            } else if (!this.matchUntilHalt || this.__halted) {\n                this.callback();\n            }\n            return next;\n        },\n\n        callback: function () {\n            this.tearDown();\n            this._super(arguments);\n        },\n\n\n        callNext: function () {\n            this.looping = true;\n            var next = this.agenda.fireNext();\n            return isPromiseLike(next) ? this.__handleAsyncNext(next) : this.__handleSyncNext(next);\n        },\n\n        execute: function () {\n            this.setup();\n            this.callNext();\n            return this;\n        }\n    }\n}).as(module);\n},{\"./extended\":12,\"./nextTick\":17}],12:[function(require,module,exports){\nvar arr = require(\"array-extended\"),\n    unique = arr.unique,\n    indexOf = arr.indexOf,\n    map = arr.map,\n    pSlice = Array.prototype.slice,\n    pSplice = Array.prototype.splice;\n\nfunction plucked(prop) {\n    var exec = prop.match(/(\\w+)\\(\\)$/);\n    if (exec) {\n        prop = exec[1];\n        return function (item) {\n            return item[prop]();\n        };\n    } else {\n        return function (item) {\n            return item[prop];\n        };\n    }\n}\n\nfunction plucker(prop) {\n    prop = prop.split(\".\");\n    if (prop.length === 1) {\n        return plucked(prop[0]);\n    } else {\n        var pluckers = map(prop, function (prop) {\n            return plucked(prop);\n        });\n        var l = pluckers.length;\n        return function (item) {\n            var i = -1, res = item;\n            while (++i < l) {\n                res = pluckers[i](res);\n            }\n            return res;\n        };\n    }\n}\n\nfunction intersection(a, b) {\n    a = pSlice.call(a);\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) === -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction inPlaceIntersection(a, b) {\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) === -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction inPlaceDifference(a, b) {\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) !== -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction diffArr(arr1, arr2) {\n    var ret = [], i = -1, j, l2 = arr2.length, l1 = arr1.length, a, found;\n    if (l2 > l1) {\n        ret = arr1.slice();\n        while (++i < l2) {\n            a = arr2[i];\n            j = -1;\n            l1 = ret.length;\n            while (++j < l1) {\n                if (ret[j] === a) {\n                    ret.splice(j, 1);\n                    break;\n                }\n            }\n        }\n    } else {\n        while (++i < l1) {\n            a = arr1[i];\n            j = -1;\n            found = false;\n            while (++j < l2) {\n                if (arr2[j] === a) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ret.push(a);\n            }\n        }\n    }\n    return ret;\n}\n\nfunction diffHash(h1, h2) {\n    var ret = {};\n    for (var i in h1) {\n        if (!hasOwnProperty.call(h2, i)) {\n            ret[i] = h1[i];\n        }\n    }\n    return ret;\n}\n\n\nfunction union(arr1, arr2) {\n    return unique(arr1.concat(arr2));\n}\n\nmodule.exports = require(\"extended\")()\n    .register(require(\"date-extended\"))\n    .register(arr)\n    .register(require(\"object-extended\"))\n    .register(require(\"string-extended\"))\n    .register(require(\"promise-extended\"))\n    .register(require(\"function-extended\"))\n    .register(require(\"is-extended\"))\n    .register(\"intersection\", intersection)\n    .register(\"inPlaceIntersection\", inPlaceIntersection)\n    .register(\"inPlaceDifference\", inPlaceDifference)\n    .register(\"diffArr\", diffArr)\n    .register(\"diffHash\", diffHash)\n    .register(\"unionArr\", union)\n    .register(\"plucker\", plucker)\n    .register(\"HashTable\", require(\"ht\"))\n    .register(\"declare\", require(\"declare.js\"))\n    .register(require(\"leafy\"))\n    .register(\"LinkedList\", require(\"./linkedList\"));\n\n\n},{\"./linkedList\":16,\"array-extended\":52,\"date-extended\":53,\"declare.js\":55,\"extended\":56,\"function-extended\":59,\"ht\":65,\"is-extended\":66,\"leafy\":67,\"object-extended\":68,\"promise-extended\":69,\"string-extended\":70}],13:[function(require,module,exports){\n\"use strict\";\nvar extd = require(\"./extended\"),\n    bind = extd.bind,\n    declare = extd.declare,\n    nodes = require(\"./nodes\"),\n    EventEmitter = require(\"events\").EventEmitter,\n    wm = require(\"./workingMemory\"),\n    WorkingMemory = wm.WorkingMemory,\n    ExecutionStragegy = require(\"./executionStrategy\"),\n    AgendaTree = require(\"./agenda\");\n\nmodule.exports = declare(EventEmitter, {\n\n    instance: {\n\n        name: null,\n\n        executionStrategy: null,\n\n        constructor: function (name, conflictResolutionStrategy) {\n            this.env = null;\n            this.name = name;\n            this.__rules = {};\n            this.conflictResolutionStrategy = conflictResolutionStrategy;\n            this.workingMemory = new WorkingMemory();\n            this.agenda = new AgendaTree(this, conflictResolutionStrategy);\n            this.agenda.on(\"fire\", bind(this, \"emit\", \"fire\"));\n            this.agenda.on(\"focused\", bind(this, \"emit\", \"focused\"));\n            this.rootNode = new nodes.RootNode(this.workingMemory, this.agenda);\n            extd.bindAll(this, \"halt\", \"assert\", \"retract\", \"modify\", \"focus\",\n              \"emit\", \"getFacts\", \"getFact\");\n        },\n\n        getFacts: function (Type) {\n            var ret;\n            if (Type) {\n                ret = this.workingMemory.getFactsByType(Type);\n            } else {\n                ret = this.workingMemory.getFacts();\n            }\n            return ret;\n        },\n\n        getFact: function (Type) {\n            var ret;\n            if (Type) {\n                ret = this.workingMemory.getFactsByType(Type);\n            } else {\n                ret = this.workingMemory.getFacts();\n            }\n            return ret && ret[0];\n        },\n\n        focus: function (focused) {\n            this.agenda.setFocus(focused);\n            return this;\n        },\n\n        halt: function () {\n            this.executionStrategy.halt();\n            return this;\n        },\n\n        dispose: function () {\n            this.workingMemory.dispose();\n            this.agenda.dispose();\n            this.rootNode.dispose();\n        },\n\n        assert: function (fact) {\n            this.rootNode.assertFact(this.workingMemory.assertFact(fact));\n            this.emit(\"assert\", fact);\n            return fact;\n        },\n\n        // This method is called to remove an existing fact from working memory\n        retract: function (fact) {\n            //fact = this.workingMemory.getFact(fact);\n            this.rootNode.retractFact(this.workingMemory.retractFact(fact));\n            this.emit(\"retract\", fact);\n            return fact;\n        },\n\n        // This method is called to alter an existing fact.  It is essentially a\n        // retract followed by an assert.\n        modify: function (fact, cb) {\n            //fact = this.workingMemory.getFact(fact);\n            if (\"function\" === typeof cb) {\n                cb.call(fact, fact);\n            }\n            this.rootNode.modifyFact(this.workingMemory.modifyFact(fact));\n            this.emit(\"modify\", fact);\n            return fact;\n        },\n\n        print: function () {\n            this.rootNode.print();\n        },\n\n        containsRule: function (name) {\n            return this.rootNode.containsRule(name);\n        },\n\n        rule: function (rule) {\n            this.rootNode.assertRule(rule);\n        },\n\n        matchUntilHalt: function (cb) {\n            return (this.executionStrategy = new ExecutionStragegy(this, true)).execute().classic(cb).promise();\n        },\n\n        match: function (cb) {\n            return (this.executionStrategy = new ExecutionStragegy(this)).execute().classic(cb).promise();\n        }\n\n    }\n});\n},{\"./agenda\":3,\"./executionStrategy\":11,\"./extended\":12,\"./nodes\":27,\"./workingMemory\":50,\"events\":60}],14:[function(require,module,exports){\n\"use strict\";\nvar extd = require(\"./extended\"),\n    instanceOf = extd.instanceOf,\n    forEach = extd.forEach,\n    declare = extd.declare,\n    InitialFact = require(\"./pattern\").InitialFact,\n    conflictStrategies = require(\"./conflict\"),\n    conflictResolution = conflictStrategies.strategy([\"salience\", \"activationRecency\"]),\n    rule = require(\"./rule\"),\n    Flow = require(\"./flow\");\n\nvar flows = {};\nvar FlowContainer = declare({\n\n    instance: {\n\n        constructor: function (name, cb) {\n            this.name = name;\n            this.cb = cb;\n            this.__rules = [];\n            this.__defined = {};\n            this.conflictResolutionStrategy = conflictResolution;\n            if (cb) {\n                cb.call(this, this);\n            }\n            if (!flows.hasOwnProperty(name)) {\n                flows[name] = this;\n            } else {\n                throw new Error(\"Flow with \" + name + \" already defined\");\n            }\n        },\n\n        conflictResolution: function (strategies) {\n            this.conflictResolutionStrategy = conflictStrategies.strategy(strategies);\n            return this;\n        },\n\n        getDefined: function (name) {\n            var ret = this.__defined[name.toLowerCase()];\n            if (!ret) {\n                throw new Error(name + \" flow class is not defined\");\n            }\n            return ret;\n        },\n\n        addDefined: function (name, cls) {\n            //normalize\n            this.__defined[name.toLowerCase()] = cls;\n            return cls;\n        },\n\n        rule: function () {\n            this.__rules = this.__rules.concat(rule.createRule.apply(rule, arguments));\n            return this;\n        },\n\n        getSession: function () {\n            var flow = new Flow(this.name, this.conflictResolutionStrategy);\n            forEach(this.__rules, function (rule) {\n                flow.rule(rule);\n            });\n            flow.assert(new InitialFact());\n            for (var i = 0, l = arguments.length; i < l; i++) {\n                flow.assert(arguments[i]);\n            }\n            return flow;\n        },\n\n        containsRule: function (name) {\n            return extd.some(this.__rules, function (rule) {\n                return rule.name === name;\n            });\n        }\n\n    },\n\n    \"static\": {\n        getFlow: function (name) {\n            return flows[name];\n        },\n\n        hasFlow: function (name) {\n            return extd.has(flows, name);\n        },\n\n        deleteFlow: function (name) {\n            if (instanceOf(name, FlowContainer)) {\n                name = name.name;\n            }\n            delete flows[name];\n            return FlowContainer;\n        },\n\n        deleteFlows: function () {\n            for (var name in flows) {\n                if (name in flows) {\n                    delete flows[name];\n                }\n            }\n            return FlowContainer;\n        },\n\n        create: function (name, cb) {\n            return new FlowContainer(name, cb);\n        }\n    }\n\n}).as(module);\n},{\"./conflict\":7,\"./extended\":12,\"./flow\":13,\"./pattern\":48,\"./rule\":49}],15:[function(require,module,exports){\n/**\n *\n * @projectName nools\n * @github https://github.com/C2FO/nools\n * @includeDoc [Examples] ../docs-md/examples.md\n * @includeDoc [Change Log] ../history.md\n * @header [../readme.md]\n */\n\n\"use strict\";\nvar extd = require(\"./extended\"),\n    fs = require(\"fs\"),\n    path = require(\"path\"),\n    compile = require(\"./compile\"),\n    FlowContainer = require(\"./flowContainer\");\n\nfunction isNoolsFile(file) {\n    return (/\\.nools$/).test(file);\n}\n\nfunction parse(source) {\n    var ret;\n    if (isNoolsFile(source)) {\n        ret = compile.parse(fs.readFileSync(source, \"utf8\"), source);\n    } else {\n        ret = compile.parse(source);\n    }\n    return ret;\n}\n\nexports.Flow = FlowContainer;\n\nexports.getFlow = FlowContainer.getFlow;\nexports.hasFlow = FlowContainer.hasFlow;\n\nexports.deleteFlow = function (name) {\n    FlowContainer.deleteFlow(name);\n    return this;\n};\n\nexports.deleteFlows = function () {\n    FlowContainer.deleteFlows();\n    return this;\n};\n\nexports.flow = FlowContainer.create;\n\nexports.compile = function (file, options, cb) {\n    if (extd.isFunction(options)) {\n        cb = options;\n        options = {};\n    } else {\n        options = options || {};\n    }\n    if (extd.isString(file)) {\n        options.name = options.name || (isNoolsFile(file) ? path.basename(file, path.extname(file)) : null);\n        file = parse(file);\n    }\n    if (!options.name) {\n        throw new Error(\"Name required when compiling nools source\");\n    }\n    return  compile.compile(file, options, cb, FlowContainer);\n};\n\nexports.transpile = function (file, options) {\n    options = options || {};\n    if (extd.isString(file)) {\n        options.name = options.name || (isNoolsFile(file) ? path.basename(file, path.extname(file)) : null);\n        file = parse(file);\n    }\n    return compile.transpile(file, options);\n};\n\nexports.parse = parse;\n},{\"./compile\":5,\"./extended\":12,\"./flowContainer\":14,\"fs\":61,\"path\":62}],16:[function(require,module,exports){\nvar declare = require(\"declare.js\");\ndeclare({\n\n    instance: {\n        constructor: function () {\n            this.head = null;\n            this.tail = null;\n            this.length = null;\n        },\n\n        push: function (data) {\n            var tail = this.tail, head = this.head, node = {data: data, prev: tail, next: null};\n            if (tail) {\n                this.tail.next = node;\n            }\n            this.tail = node;\n            if (!head) {\n                this.head = node;\n            }\n            this.length++;\n            return node;\n        },\n\n        remove: function (node) {\n            if (node.prev) {\n                node.prev.next = node.next;\n            } else {\n                this.head = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            } else {\n                this.tail = node.prev;\n            }\n            //node.data = node.prev = node.next = null;\n            this.length--;\n        },\n\n        forEach: function (cb) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                cb(head.data);\n            }\n        },\n\n        toArray: function () {\n            var head = {next: this.head}, ret = [];\n            while ((head = head.next)) {\n                ret.push(head);\n            }\n            return ret;\n        },\n\n        removeByData: function (data) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                if (head.data === data) {\n                    this.remove(head);\n                    break;\n                }\n            }\n        },\n\n        getByData: function (data) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                if (head.data === data) {\n                    return head;\n                }\n            }\n        },\n\n        clear: function () {\n            this.head = this.tail = null;\n            this.length = 0;\n        }\n\n    }\n\n}).as(module);\n\n},{\"declare.js\":55}],17:[function(require,module,exports){\nvar process=require(\"__browserify_process\");/*global setImmediate, window, MessageChannel*/\nvar extd = require(\"./extended\");\nvar nextTick;\nif (typeof setImmediate === \"function\") {\n    // In IE10, or use https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        nextTick = extd.bind(window, setImmediate);\n    } else {\n        nextTick = setImmediate;\n    }\n} else if (typeof process !== \"undefined\") {\n    // node\n    nextTick = process.nextTick;\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    // linked list of tasks (single, with head node)\n    var head = {}, tail = head;\n    channel.port1.onmessage = function () {\n        head = head.next;\n        var task = head.task;\n        delete head.task;\n        task();\n    };\n    nextTick = function (task) {\n        tail = tail.next = {task: task};\n        channel.port2.postMessage(0);\n    };\n} else {\n    // old browsers\n    nextTick = function (task) {\n        setTimeout(task, 0);\n    };\n}\n\nmodule.exports = nextTick;\n},{\"./extended\":12,\"__browserify_process\":64}],18:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    intersection = require(\"../extended\").intersection;\n\nNode.extend({\n    instance: {\n\n        __propagatePaths: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode, paths, continuingPaths;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                paths = entry.value;\n                if ((continuingPaths = intersection(paths, context.paths)).length) {\n                    outNode[method](context.clone(null, continuingPaths, null));\n                }\n            }\n        },\n\n        __propagateNoPaths: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length;\n            while (--i > -1) {\n                entrySet[i].key[method](context);\n            }\n        },\n\n        __propagate: function (method, context) {\n            if (context.paths) {\n                this.__propagatePaths(method, context);\n            } else {\n                this.__propagateNoPaths(method, context);\n            }\n        }\n    }\n}).as(module);\n},{\"../extended\":12,\"./node\":37}],19:[function(require,module,exports){\nvar AlphaNode = require(\"./alphaNode\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this._super(arguments);\n            this.alias = this.constraint.get(\"alias\");\n        },\n\n        toString: function () {\n            return \"AliasNode\" + this.__count;\n        },\n\n        assert: function (context) {\n            return this.__propagate(\"assert\", context.set(this.alias, context.fact.object));\n        },\n\n        modify: function (context) {\n            return this.__propagate(\"modify\", context.set(this.alias, context.fact.object));\n        },\n\n        retract: function (context) {\n            return this.__propagate(\"retract\", context.set(this.alias, context.fact.object));\n        },\n\n        equal: function (other) {\n            return other instanceof this._static && this.alias === other.alias;\n        }\n    }\n}).as(module);\n},{\"./alphaNode\":20}],20:[function(require,module,exports){\n\"use strict\";\nvar Node = require(\"./node\");\n\nNode.extend({\n    instance: {\n        constructor: function (constraint) {\n            this._super([]);\n            this.constraint = constraint;\n            this.constraintAssert = this.constraint.assert;\n        },\n\n        toString: function () {\n            return \"AlphaNode \" + this.__count;\n        },\n\n        equal: function (constraint) {\n            return this.constraint.equal(constraint.constraint);\n        }\n    }\n}).as(module);\n},{\"./node\":37}],21:[function(require,module,exports){\nvar extd = require(\"../extended\"),\n    keys = extd.hash.keys,\n    Node = require(\"./node\"),\n    LeftMemory = require(\"./misc/leftMemory\"), RightMemory = require(\"./misc/rightMemory\");\n\nNode.extend({\n\n    instance: {\n\n        nodeType: \"BetaNode\",\n\n        constructor: function () {\n            this._super([]);\n            this.leftMemory = {};\n            this.rightMemory = {};\n            this.leftTuples = new LeftMemory();\n            this.rightTuples = new RightMemory();\n        },\n\n        __propagate: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                outNode[method](context);\n            }\n        },\n\n        dispose: function () {\n            this.leftMemory = {};\n            this.rightMemory = {};\n            this.leftTuples.clear();\n            this.rightTuples.clear();\n        },\n\n        disposeLeft: function (fact) {\n            this.leftMemory = {};\n            this.leftTuples.clear();\n            this.propagateDispose(fact);\n        },\n\n        disposeRight: function (fact) {\n            this.rightMemory = {};\n            this.rightTuples.clear();\n            this.propagateDispose(fact);\n        },\n\n        hashCode: function () {\n            return  this.nodeType + \" \" + this.__count;\n        },\n\n        toString: function () {\n            return this.nodeType + \" \" + this.__count;\n        },\n\n        retractLeft: function (context) {\n            context = this.removeFromLeftMemory(context).data;\n            var rightMatches = context.rightMatches,\n                hashCodes = keys(rightMatches),\n                i = -1,\n                l = hashCodes.length;\n            while (++i < l) {\n                this.__propagate(\"retract\", rightMatches[hashCodes[i]].clone());\n            }\n        },\n\n        retractRight: function (context) {\n            context = this.removeFromRightMemory(context).data;\n            var leftMatches = context.leftMatches,\n                hashCodes = keys(leftMatches),\n                i = -1,\n                l = hashCodes.length;\n            while (++i < l) {\n                this.__propagate(\"retract\", leftMatches[hashCodes[i]].clone());\n            }\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            var rm = this.rightTuples.getRightMemory(context), i = -1, l = rm.length;\n            while (++i < l) {\n                this.propagateFromLeft(context, rm[i].data);\n            }\n        },\n\n        assertRight: function (context) {\n            this.__addToRightMemory(context);\n            var lm = this.leftTuples.getLeftMemory(context), i = -1, l = lm.length;\n            while (++i < l) {\n                this.propagateFromRight(context, lm[i].data);\n            }\n        },\n\n        modifyLeft: function (context) {\n            var previousContext = this.removeFromLeftMemory(context).data;\n            this.__addToLeftMemory(context);\n            var rm = this.rightTuples.getRightMemory(context), l = rm.length, i = -1, rightMatches;\n            if (!l) {\n                this.propagateRetractModifyFromLeft(previousContext);\n            } else {\n                rightMatches = previousContext.rightMatches;\n                while (++i < l) {\n                    this.propagateAssertModifyFromLeft(context, rightMatches, rm[i].data);\n                }\n\n            }\n        },\n\n        modifyRight: function (context) {\n            var previousContext = this.removeFromRightMemory(context).data;\n            this.__addToRightMemory(context);\n            var lm = this.leftTuples.getLeftMemory(context);\n            if (!lm.length) {\n                this.propagateRetractModifyFromRight(previousContext);\n            } else {\n                var leftMatches = previousContext.leftMatches, i = -1, l = lm.length;\n                while (++i < l) {\n                    this.propagateAssertModifyFromRight(context, leftMatches, lm[i].data);\n                }\n            }\n        },\n\n        propagateFromLeft: function (context, rc) {\n            this.__propagate(\"assert\", this.__addToMemoryMatches(rc, context, context.clone(null, null, context.match.merge(rc.match))));\n        },\n\n        propagateFromRight: function (context, lc) {\n            this.__propagate(\"assert\", this.__addToMemoryMatches(context, lc, lc.clone(null, null, lc.match.merge(context.match))));\n        },\n\n        propagateRetractModifyFromLeft: function (context) {\n            var rightMatches = context.rightMatches,\n                hashCodes = keys(rightMatches),\n                l = hashCodes.length,\n                i = -1;\n            while (++i < l) {\n                this.__propagate(\"retract\", rightMatches[hashCodes[i]].clone());\n            }\n        },\n\n        propagateRetractModifyFromRight: function (context) {\n            var leftMatches = context.leftMatches,\n                hashCodes = keys(leftMatches),\n                l = hashCodes.length,\n                i = -1;\n            while (++i < l) {\n                this.__propagate(\"retract\", leftMatches[hashCodes[i]].clone());\n            }\n        },\n\n        propagateAssertModifyFromLeft: function (context, rightMatches, rm) {\n            var factId = rm.hashCode;\n            if (factId in rightMatches) {\n                this.__propagate(\"modify\", this.__addToMemoryMatches(rm, context, context.clone(null, null, context.match.merge(rm.match))));\n            } else {\n                this.propagateFromLeft(context, rm);\n            }\n        },\n\n        propagateAssertModifyFromRight: function (context, leftMatches, lm) {\n            var factId = lm.hashCode;\n            if (factId in leftMatches) {\n                this.__propagate(\"modify\", this.__addToMemoryMatches(context, lm, context.clone(null, null, lm.match.merge(context.match))));\n            } else {\n                this.propagateFromRight(context, lm);\n            }\n        },\n\n        removeFromRightMemory: function (context) {\n            var hashCode = context.hashCode, ret;\n            context = this.rightMemory[hashCode] || null;\n            var tuples = this.rightTuples;\n            if (context) {\n                var leftMemory = this.leftMemory;\n                ret = context.data;\n                var leftMatches = ret.leftMatches;\n                tuples.remove(context);\n                var hashCodes = keys(leftMatches), i = -1, l = hashCodes.length;\n                while (++i < l) {\n                    delete leftMemory[hashCodes[i]].data.rightMatches[hashCode];\n                }\n                delete this.rightMemory[hashCode];\n            }\n            return context;\n        },\n\n        removeFromLeftMemory: function (context) {\n            var hashCode = context.hashCode;\n            context = this.leftMemory[hashCode] || null;\n            if (context) {\n                var rightMemory = this.rightMemory;\n                var rightMatches = context.data.rightMatches;\n                this.leftTuples.remove(context);\n                var hashCodes = keys(rightMatches), i = -1, l = hashCodes.length;\n                while (++i < l) {\n                    delete rightMemory[hashCodes[i]].data.leftMatches[hashCode];\n                }\n                delete this.leftMemory[hashCode];\n            }\n            return context;\n        },\n\n        getRightMemoryMatches: function (context) {\n            var lm = this.leftMemory[context.hashCode], ret = {};\n            if (lm) {\n                ret = lm.rightMatches;\n            }\n            return ret;\n        },\n\n        __addToMemoryMatches: function (rightContext, leftContext, createdContext) {\n            var rightFactId = rightContext.hashCode,\n                rm = this.rightMemory[rightFactId],\n                lm, leftFactId = leftContext.hashCode;\n            if (rm) {\n                rm = rm.data;\n                if (leftFactId in rm.leftMatches) {\n                    throw new Error(\"Duplicate left fact entry\");\n                }\n                rm.leftMatches[leftFactId] = createdContext;\n            }\n            lm = this.leftMemory[leftFactId];\n            if (lm) {\n                lm = lm.data;\n                if (rightFactId in lm.rightMatches) {\n                    throw new Error(\"Duplicate right fact entry\");\n                }\n                lm.rightMatches[rightFactId] = createdContext;\n            }\n            return createdContext;\n        },\n\n        __addToRightMemory: function (context) {\n            var hashCode = context.hashCode, rm = this.rightMemory;\n            if (hashCode in rm) {\n                return false;\n            }\n            rm[hashCode] = this.rightTuples.push(context);\n            context.leftMatches = {};\n            return true;\n        },\n\n\n        __addToLeftMemory: function (context) {\n            var hashCode = context.hashCode, lm = this.leftMemory;\n            if (hashCode in lm) {\n                return false;\n            }\n            lm[hashCode] = this.leftTuples.push(context);\n            context.rightMatches = {};\n            return true;\n        }\n    }\n\n}).as(module);\n},{\"../extended\":12,\"./misc/leftMemory\":32,\"./misc/rightMemory\":34,\"./node\":37}],22:[function(require,module,exports){\nvar AlphaNode = require(\"./alphaNode\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this.memory = {};\n            this._super(arguments);\n            this.constraintAssert = this.constraint.assert;\n        },\n\n        assert: function (context) {\n            if ((this.memory[context.pathsHash] = this.constraintAssert(context.factHash))) {\n                this.__propagate(\"assert\", context);\n            }\n        },\n\n        modify: function (context) {\n            var memory = this.memory,\n                hashCode = context.pathsHash,\n                wasMatch = memory[hashCode];\n            if ((memory[hashCode] = this.constraintAssert(context.factHash))) {\n                this.__propagate(wasMatch ? \"modify\" : \"assert\", context);\n            } else if (wasMatch) {\n                this.__propagate(\"retract\", context);\n            }\n        },\n\n        retract: function (context) {\n            var hashCode = context.pathsHash,\n                memory = this.memory;\n            if (memory[hashCode]) {\n                this.__propagate(\"retract\", context);\n            }\n            delete memory[hashCode];\n        },\n\n        toString: function () {\n            return \"EqualityNode\" + this.__count;\n        }\n    }\n}).as(module);\n},{\"./alphaNode\":20}],23:[function(require,module,exports){\nvar FromNotNode = require(\"./fromNotNode\"),\n    extd = require(\"../extended\"),\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    isArray = extd.isArray;\n\nFromNotNode.extend({\n    instance: {\n\n        nodeType: \"ExistsFromNode\",\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                if (ctx.blocked) {\n                    this.__propagate(\"retract\", ctx.clone());\n                }\n            }\n        },\n\n        __modify: function (context, leftContext) {\n            var leftContextBlocked = leftContext.blocked;\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        break;\n                    }\n                }\n            } else if (isDefined(o)) {\n                context.blocked = this.__isMatch(context, o, true);\n            }\n            var newContextBlocked = context.blocked;\n            if (newContextBlocked) {\n                if (leftContextBlocked) {\n                    this.__propagate(\"modify\", context.clone());\n                } else {\n                    this.__propagate(\"assert\", context.clone());\n                }\n            } else if (leftContextBlocked) {\n                this.__propagate(\"retract\", context.clone());\n            }\n\n        },\n\n        __findMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh), isMatch = false;\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        this.__propagate(\"assert\", context.clone());\n                        return;\n                    }\n                }\n            } else if (isDefined(o) && (this.__isMatch(context, o, true))) {\n                context.blocked = true;\n                this.__propagate(\"assert\", context.clone());\n            }\n            return isMatch;\n        },\n\n        __isMatch: function (oc, o, add) {\n            var ret = false;\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o);\n                var context = new Context(createdFact, null, null)\n                    .mergeMatch(oc.match)\n                    .set(this.alias, o);\n                if (add) {\n                    var fm = this.fromMemory[createdFact.id];\n                    if (!fm) {\n                        fm = this.fromMemory[createdFact.id] = {};\n                    }\n                    fm[oc.hashCode] = oc;\n                }\n                var fh = context.factHash;\n                var eqConstraints = this.__equalityConstraints;\n                for (var i = 0, l = eqConstraints.length; i < l; i++) {\n                    if (eqConstraints[i](fh)) {\n                        ret = true;\n                    } else {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            return ret;\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            this.__findMatches(context);\n        }\n\n    }\n}).as(module);\n},{\"../context\":10,\"../extended\":12,\"./fromNotNode\":26}],24:[function(require,module,exports){\nvar NotNode = require(\"./notNode\"),\n    LinkedList = require(\"../linkedList\");\n\n\nNotNode.extend({\n    instance: {\n\n        nodeType: \"ExistsNode\",\n\n        blockedContext: function (leftContext, rightContext) {\n            leftContext.blocker = rightContext;\n            this.removeFromLeftMemory(leftContext);\n            this.addToLeftBlockedMemory(rightContext.blocking.push(leftContext));\n            this.__propagate(\"assert\", this.__cloneContext(leftContext));\n        },\n\n        notBlockedContext: function (leftContext, propagate) {\n            this.__addToLeftMemory(leftContext);\n            propagate && this.__propagate(\"retract\", this.__cloneContext(leftContext));\n        },\n\n        propagateFromLeft: function (leftContext) {\n            this.notBlockedContext(leftContext, false);\n        },\n\n\n        retractLeft: function (context) {\n            var ctx;\n            if (!this.removeFromLeftMemory(context)) {\n                if ((ctx = this.removeFromLeftBlockedMemory(context))) {\n                    this.__propagate(\"retract\", this.__cloneContext(ctx.data));\n                } else {\n                    throw new Error();\n                }\n            }\n        },\n       \n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context),\n                leftContext,\n                thisConstraint = this.constraint,\n                rightTuples = this.rightTuples,\n                l = rightTuples.length,\n                isBlocked = false,\n                node, rc, blocker;\n            if (!ctx) {\n                //blocked before\n                ctx = this.removeFromLeftBlockedMemory(context);\n                isBlocked = true;\n            }\n            if (ctx) {\n                leftContext = ctx.data;\n\n                if (leftContext && leftContext.blocker) {\n                    //we were blocked before so only check nodes previous to our blocker\n                    blocker = this.rightMemory[leftContext.blocker.hashCode];\n                }\n                if (blocker) {\n                    if (thisConstraint.isMatch(context, rc = blocker.data)) {\n                        //propogate as a modify or assert\n                        this.__propagate(!isBlocked ? \"assert\" : \"modify\", this.__cloneContext(leftContext));\n                        context.blocker = rc;\n                        this.addToLeftBlockedMemory(rc.blocking.push(context));\n                        context = null;\n                    }\n                    if (context) {\n                        node = {next: blocker.next};\n                    }\n                } else {\n                    node = {next: rightTuples.head};\n                }\n                if (context && l) {\n                    node = {next: rightTuples.head};\n                    //we were propagated before\n                    while ((node = node.next)) {\n                        if (thisConstraint.isMatch(context, rc = node.data)) {\n                            //we cant be proagated so retract previous\n\n                            //we were asserted before so retract\n                            this.__propagate(!isBlocked ? \"assert\" : \"modify\", this.__cloneContext(leftContext));\n\n                            this.addToLeftBlockedMemory(rc.blocking.push(context));\n                            context.blocker = rc;\n                            context = null;\n                            break;\n                        }\n                    }\n                }\n                if (context) {\n                    //we can still be propogated\n                    this.__addToLeftMemory(context);\n                    if (isBlocked) {\n                        //we were blocked so retract\n                        this.__propagate(\"retract\", this.__cloneContext(context));\n                    }\n\n                }\n            } else {\n                throw new Error();\n            }\n\n        },\n\n        modifyRight: function (context) {\n            var ctx = this.removeFromRightMemory(context);\n            if (ctx) {\n                var rightContext = ctx.data,\n                    leftTuples = this.leftTuples,\n                    leftTuplesLength = leftTuples.length,\n                    leftContext,\n                    thisConstraint = this.constraint,\n                    node,\n                    blocking = rightContext.blocking;\n                this.__addToRightMemory(context);\n                context.blocking = new LinkedList();\n                if (leftTuplesLength || blocking.length) {\n                    if (blocking.length) {\n                        var rc;\n                        //check old blocked contexts\n                        //check if the same contexts blocked before are still blocked\n                        var blockingNode = {next: blocking.head};\n                        while ((blockingNode = blockingNode.next)) {\n                            leftContext = blockingNode.data;\n                            leftContext.blocker = null;\n                            if (thisConstraint.isMatch(leftContext, context)) {\n                                leftContext.blocker = context;\n                                this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                                this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                leftContext = null;\n                            } else {\n                                //we arent blocked anymore\n                                leftContext.blocker = null;\n                                node = ctx;\n                                while ((node = node.next)) {\n                                    if (thisConstraint.isMatch(leftContext, rc = node.data)) {\n                                        leftContext.blocker = rc;\n                                        this.addToLeftBlockedMemory(rc.blocking.push(leftContext));\n                                        this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                        leftContext = null;\n                                        break;\n                                    }\n                                }\n                                if (leftContext) {\n                                    this.__addToLeftMemory(leftContext);\n                                }\n                            }\n                        }\n                    }\n\n                    if (leftTuplesLength) {\n                        //check currently left tuples in memory\n                        node = {next: leftTuples.head};\n                        while ((node = node.next)) {\n                            leftContext = node.data;\n                            if (thisConstraint.isMatch(leftContext, context)) {\n                                this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                this.removeFromLeftMemory(leftContext);\n                                this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                                leftContext.blocker = context;\n                            }\n                        }\n                    }\n\n\n                }\n            } else {\n                throw new Error();\n            }\n\n\n        }\n    }\n}).as(module);\n},{\"../linkedList\":16,\"./notNode\":38}],25:[function(require,module,exports){\nvar JoinNode = require(\"./joinNode\"),\n    extd = require(\"../extended\"),\n    constraint = require(\"../constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    HashConstraint = constraint.HashConstraint,\n    ReferenceConstraint = constraint.ReferenceConstraint,\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    isEmpty = extd.isEmpty,\n    forEach = extd.forEach,\n    isArray = extd.isArray;\n\nvar DEFAULT_MATCH = {\n    isMatch: function () {\n        return false;\n    }\n};\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"FromNode\",\n\n        constructor: function (pattern, wm) {\n            this._super(arguments);\n            this.workingMemory = wm;\n            this.fromMemory = {};\n            this.pattern = pattern;\n            this.type = pattern.get(\"constraints\")[0].assert;\n            this.alias = pattern.get(\"alias\");\n            this.from = pattern.from.assert;\n            var eqConstraints = this.__equalityConstraints = [];\n            var vars = [];\n            forEach(this.constraints = this.pattern.get(\"constraints\").slice(1), function (c) {\n                if (c instanceof EqualityConstraint || c instanceof ReferenceConstraint) {\n                    eqConstraints.push(c.assert);\n                } else if (c instanceof HashConstraint) {\n                    vars = vars.concat(c.get(\"variables\"));\n                }\n            });\n            this.__variables = vars;\n        },\n\n        __createMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    this.__checkMatch(context, o[i], true);\n                }\n            } else if (isDefined(o)) {\n                this.__checkMatch(context, o, true);\n            }\n        },\n\n        __checkMatch: function (context, o, propogate) {\n            var newContext;\n            if ((newContext = this.__createMatch(context, o)).isMatch() && propogate) {\n                this.__propagate(\"assert\", newContext.clone());\n            }\n            return newContext;\n        },\n\n        __createMatch: function (lc, o) {\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o, true),\n                    createdContext,\n                    rc = new Context(createdFact, null, null)\n                        .set(this.alias, o),\n                    createdFactId = createdFact.id;\n                var fh = rc.factHash, lcFh = lc.factHash;\n                for (var key in lcFh) {\n                    fh[key] = lcFh[key];\n                }\n                var eqConstraints = this.__equalityConstraints, vars = this.__variables, i = -1, l = eqConstraints.length;\n                while (++i < l) {\n                    if (!eqConstraints[i](fh, fh)) {\n                        createdContext = DEFAULT_MATCH;\n                        break;\n                    }\n                }\n                var fm = this.fromMemory[createdFactId];\n                if (!fm) {\n                    fm = this.fromMemory[createdFactId] = {};\n                }\n                if (!createdContext) {\n                    var prop;\n                    i = -1;\n                    l = vars.length;\n                    while (++i < l) {\n                        prop = vars[i];\n                        fh[prop] = o[prop];\n                    }\n                    lc.fromMatches[createdFact.id] = createdContext = rc.clone(createdFact, null, lc.match.merge(rc.match));\n                }\n                fm[lc.hashCode] = [lc, createdContext];\n                return createdContext;\n            }\n            return DEFAULT_MATCH;\n        },\n\n        retractRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        },\n\n        removeFromFromMemory: function (context) {\n            var factId = context.fact.id;\n            var fm = this.fromMemory[factId];\n            if (fm) {\n                var entry;\n                for (var i in fm) {\n                    entry = fm[i];\n                    if (entry[1] === context) {\n                        delete fm[i];\n                        if (isEmpty(fm)) {\n                            delete this.fromMemory[factId];\n                        }\n                        break;\n                    }\n                }\n            }\n\n        },\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                var fromMatches = ctx.fromMatches;\n                for (var i in fromMatches) {\n                    this.removeFromFromMemory(fromMatches[i]);\n                    this.__propagate(\"retract\", fromMatches[i].clone());\n                }\n            }\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context), newContext, i, l, factId, fact;\n            if (ctx) {\n                this.__addToLeftMemory(context);\n\n                var leftContext = ctx.data,\n                    fromMatches = (context.fromMatches = {}),\n                    rightMatches = leftContext.fromMatches,\n                    o = this.from(context.factHash);\n\n                if (isArray(o)) {\n                    for (i = 0, l = o.length; i < l; i++) {\n                        newContext = this.__checkMatch(context, o[i], false);\n                        if (newContext.isMatch()) {\n                            factId = newContext.fact.id;\n                            if (factId in rightMatches) {\n                                this.__propagate(\"modify\", newContext.clone());\n                            } else {\n                                this.__propagate(\"assert\", newContext.clone());\n                            }\n                        }\n                    }\n                } else if (isDefined(o)) {\n                    newContext = this.__checkMatch(context, o, false);\n                    if (newContext.isMatch()) {\n                        factId = newContext.fact.id;\n                        if (factId in rightMatches) {\n                            this.__propagate(\"modify\", newContext.clone());\n                        } else {\n                            this.__propagate(\"assert\", newContext.clone());\n                        }\n                    }\n                }\n                for (i in rightMatches) {\n                    if (!(i in fromMatches)) {\n                        this.removeFromFromMemory(rightMatches[i]);\n                        this.__propagate(\"retract\", rightMatches[i].clone());\n                    }\n                }\n            } else {\n                this.assertLeft(context);\n            }\n            fact = context.fact;\n            factId = fact.id;\n            var fm = this.fromMemory[factId];\n            this.fromMemory[factId] = {};\n            if (fm) {\n                var lc, entry, cc, createdIsMatch, factObject = fact.object;\n                for (i in fm) {\n                    entry = fm[i];\n                    lc = entry[0];\n                    cc = entry[1];\n                    createdIsMatch = cc.isMatch();\n                    if (lc.hashCode !== context.hashCode) {\n                        newContext = this.__createMatch(lc, factObject, false);\n                        if (createdIsMatch) {\n                            this.__propagate(\"retract\", cc.clone());\n                        }\n                        if (newContext.isMatch()) {\n                            this.__propagate(createdIsMatch ? \"modify\" : \"assert\", newContext.clone());\n                        }\n\n                    }\n                }\n            }\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            context.fromMatches = {};\n            this.__createMatches(context);\n        },\n\n        assertRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        }\n\n    }\n}).as(module);\n},{\"../constraint\":8,\"../context\":10,\"../extended\":12,\"./joinNode\":28}],26:[function(require,module,exports){\nvar JoinNode = require(\"./joinNode\"),\n    extd = require(\"../extended\"),\n    constraint = require(\"../constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    HashConstraint = constraint.HashConstraint,\n    ReferenceConstraint = constraint.ReferenceConstraint,\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    forEach = extd.forEach,\n    isArray = extd.isArray;\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"FromNotNode\",\n\n        constructor: function (pattern, workingMemory) {\n            this._super(arguments);\n            this.workingMemory = workingMemory;\n            this.pattern = pattern;\n            this.type = pattern.get(\"constraints\")[0].assert;\n            this.alias = pattern.get(\"alias\");\n            this.from = pattern.from.assert;\n            this.fromMemory = {};\n            var eqConstraints = this.__equalityConstraints = [];\n            var vars = [];\n            forEach(this.constraints = this.pattern.get(\"constraints\").slice(1), function (c) {\n                if (c instanceof EqualityConstraint || c instanceof ReferenceConstraint) {\n                    eqConstraints.push(c.assert);\n                } else if (c instanceof HashConstraint) {\n                    vars = vars.concat(c.get(\"variables\"));\n                }\n            });\n            this.__variables = vars;\n\n        },\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                if (!ctx.blocked) {\n                    this.__propagate(\"retract\", ctx.clone());\n                }\n            }\n        },\n\n        __modify: function (context, leftContext) {\n            var leftContextBlocked = leftContext.blocked;\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        break;\n                    }\n                }\n            } else if (isDefined(o)) {\n                context.blocked = this.__isMatch(context, o, true);\n            }\n            var newContextBlocked = context.blocked;\n            if (!newContextBlocked) {\n                if (leftContextBlocked) {\n                    this.__propagate(\"assert\", context.clone());\n                } else {\n                    this.__propagate(\"modify\", context.clone());\n                }\n            } else if (!leftContextBlocked) {\n                this.__propagate(\"retract\", leftContext.clone());\n            }\n\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                this.__addToLeftMemory(context);\n                this.__modify(context, ctx.data);\n            } else {\n                throw new Error();\n            }\n            var fm = this.fromMemory[context.fact.id];\n            this.fromMemory[context.fact.id] = {};\n            if (fm) {\n                for (var i in fm) {\n                    // update any contexts associated with this fact\n                    if (i !== context.hashCode) {\n                        var lc = fm[i];\n                        ctx = this.removeFromLeftMemory(lc);\n                        if (ctx) {\n                            lc = lc.clone();\n                            lc.blocked = false;\n                            this.__addToLeftMemory(lc);\n                            this.__modify(lc, ctx.data);\n                        }\n                    }\n                }\n            }\n        },\n\n        __findMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh), isMatch = false;\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        return;\n                    }\n                }\n                this.__propagate(\"assert\", context.clone());\n            } else if (isDefined(o) && !(context.blocked = this.__isMatch(context, o, true))) {\n                this.__propagate(\"assert\", context.clone());\n            }\n            return isMatch;\n        },\n\n        __isMatch: function (oc, o, add) {\n            var ret = false;\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o);\n                var context = new Context(createdFact, null)\n                    .mergeMatch(oc.match)\n                    .set(this.alias, o);\n                if (add) {\n                    var fm = this.fromMemory[createdFact.id];\n                    if (!fm) {\n                        fm = this.fromMemory[createdFact.id] = {};\n                    }\n                    fm[oc.hashCode] = oc;\n                }\n                var fh = context.factHash;\n                var eqConstraints = this.__equalityConstraints;\n                for (var i = 0, l = eqConstraints.length; i < l; i++) {\n                    if (eqConstraints[i](fh, fh)) {\n                        ret = true;\n                    } else {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            return ret;\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            this.__findMatches(context);\n        },\n\n        assertRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        },\n\n        retractRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        }\n\n    }\n}).as(module);\n},{\"../constraint\":8,\"../context\":10,\"../extended\":12,\"./joinNode\":28}],27:[function(require,module,exports){\n\"use strict\";\nvar extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    some = extd.some,\n    declare = extd.declare,\n    pattern = require(\"../pattern.js\"),\n    ObjectPattern = pattern.ObjectPattern,\n    FromPattern = pattern.FromPattern,\n    FromNotPattern = pattern.FromNotPattern,\n    ExistsPattern = pattern.ExistsPattern,\n    FromExistsPattern = pattern.FromExistsPattern,\n    NotPattern = pattern.NotPattern,\n    CompositePattern = pattern.CompositePattern,\n    InitialFactPattern = pattern.InitialFactPattern,\n    constraints = require(\"../constraint\"),\n    HashConstraint = constraints.HashConstraint,\n    ReferenceConstraint = constraints.ReferenceConstraint,\n    AliasNode = require(\"./aliasNode\"),\n    EqualityNode = require(\"./equalityNode\"),\n    JoinNode = require(\"./joinNode\"),\n    BetaNode = require(\"./betaNode\"),\n    NotNode = require(\"./notNode\"),\n    FromNode = require(\"./fromNode\"),\n    FromNotNode = require(\"./fromNotNode\"),\n    ExistsNode = require(\"./existsNode\"),\n    ExistsFromNode = require(\"./existsFromNode\"),\n    LeftAdapterNode = require(\"./leftAdapterNode\"),\n    RightAdapterNode = require(\"./rightAdapterNode\"),\n    TypeNode = require(\"./typeNode\"),\n    TerminalNode = require(\"./terminalNode\"),\n    PropertyNode = require(\"./propertyNode\");\n\nfunction hasRefernceConstraints(pattern) {\n    return some(pattern.constraints || [], function (c) {\n        return c instanceof ReferenceConstraint;\n    });\n}\n\ndeclare({\n    instance: {\n        constructor: function (wm, agendaTree) {\n            this.terminalNodes = [];\n            this.joinNodes = [];\n            this.nodes = [];\n            this.constraints = [];\n            this.typeNodes = [];\n            this.__ruleCount = 0;\n            this.bucket = {\n                counter: 0,\n                recency: 0\n            };\n            this.agendaTree = agendaTree;\n            this.workingMemory = wm;\n        },\n\n        assertRule: function (rule) {\n            var terminalNode = new TerminalNode(this.bucket, this.__ruleCount++, rule, this.agendaTree);\n            this.__addToNetwork(rule, rule.pattern, terminalNode);\n            this.__mergeJoinNodes();\n            this.terminalNodes.push(terminalNode);\n        },\n\n        resetCounter: function () {\n            this.bucket.counter = 0;\n        },\n\n        incrementCounter: function () {\n            this.bucket.counter++;\n        },\n\n        assertFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].assert(fact);\n            }\n        },\n\n        retractFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].retract(fact);\n            }\n        },\n\n        modifyFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].modify(fact);\n            }\n        },\n\n\n        containsRule: function (name) {\n            return some(this.terminalNodes, function (n) {\n                return n.rule.name === name;\n            });\n        },\n\n        dispose: function () {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].dispose();\n            }\n        },\n\n        __mergeJoinNodes: function () {\n            var joinNodes = this.joinNodes;\n            for (var i = 0; i < joinNodes.length; i++) {\n                var j1 = joinNodes[i], j2 = joinNodes[i + 1];\n                if (j1 && j2 && (j1.constraint && j2.constraint && j1.constraint.equal(j2.constraint))) {\n                    j1.merge(j2);\n                    joinNodes.splice(i + 1, 1);\n                }\n            }\n        },\n\n        __checkEqual: function (node) {\n            var constraints = this.constraints, i = constraints.length - 1;\n            for (; i >= 0; i--) {\n                var n = constraints[i];\n                if (node.equal(n)) {\n                    return  n;\n                }\n            }\n            constraints.push(node);\n            return node;\n        },\n\n        __createTypeNode: function (rule, pattern) {\n            var ret = new TypeNode(pattern.get(\"constraints\")[0]);\n            var constraints = this.typeNodes, i = constraints.length - 1;\n            for (; i >= 0; i--) {\n                var n = constraints[i];\n                if (ret.equal(n)) {\n                    return  n;\n                }\n            }\n            constraints.push(ret);\n            return ret;\n        },\n\n        __createEqualityNode: function (rule, constraint) {\n            return this.__checkEqual(new EqualityNode(constraint)).addRule(rule);\n        },\n\n        __createPropertyNode: function (rule, constraint) {\n            return this.__checkEqual(new PropertyNode(constraint)).addRule(rule);\n        },\n\n        __createAliasNode: function (rule, pattern) {\n            return this.__checkEqual(new AliasNode(pattern)).addRule(rule);\n        },\n\n        __createAdapterNode: function (rule, side) {\n            return (side === \"left\" ? new LeftAdapterNode() : new RightAdapterNode()).addRule(rule);\n        },\n\n        __createJoinNode: function (rule, pattern, outNode, side) {\n            var joinNode;\n            if (pattern.rightPattern instanceof NotPattern) {\n                joinNode = new NotNode();\n            } else if (pattern.rightPattern instanceof FromExistsPattern) {\n                joinNode = new ExistsFromNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern.rightPattern instanceof ExistsPattern) {\n                joinNode = new ExistsNode();\n            } else if (pattern.rightPattern instanceof FromNotPattern) {\n                joinNode = new FromNotNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern.rightPattern instanceof FromPattern) {\n                joinNode = new FromNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern instanceof CompositePattern && !hasRefernceConstraints(pattern.leftPattern) && !hasRefernceConstraints(pattern.rightPattern)) {\n                joinNode = new BetaNode();\n                this.joinNodes.push(joinNode);\n            } else {\n                joinNode = new JoinNode();\n                this.joinNodes.push(joinNode);\n            }\n            joinNode[\"__rule__\"] = rule;\n            var parentNode = joinNode;\n            if (outNode instanceof BetaNode) {\n                var adapterNode = this.__createAdapterNode(rule, side);\n                parentNode.addOutNode(adapterNode, pattern);\n                parentNode = adapterNode;\n            }\n            parentNode.addOutNode(outNode, pattern);\n            return joinNode.addRule(rule);\n        },\n\n        __addToNetwork: function (rule, pattern, outNode, side) {\n            if (pattern instanceof ObjectPattern) {\n                if (!(pattern instanceof InitialFactPattern) && (!side || side === \"left\")) {\n                    this.__createBetaNode(rule, new CompositePattern(new InitialFactPattern(), pattern), outNode, side);\n                } else {\n                    this.__createAlphaNode(rule, pattern, outNode, side);\n                }\n            } else if (pattern instanceof CompositePattern) {\n                this.__createBetaNode(rule, pattern, outNode, side);\n            }\n        },\n\n        __createBetaNode: function (rule, pattern, outNode, side) {\n            var joinNode = this.__createJoinNode(rule, pattern, outNode, side);\n            this.__addToNetwork(rule, pattern.rightPattern, joinNode, \"right\");\n            this.__addToNetwork(rule, pattern.leftPattern, joinNode, \"left\");\n            outNode.addParentNode(joinNode);\n            return joinNode;\n        },\n\n\n        __createAlphaNode: function (rule, pattern, outNode, side) {\n            var typeNode, parentNode;\n            if (!(pattern instanceof FromPattern)) {\n\n                var constraints = pattern.get(\"constraints\");\n                typeNode = this.__createTypeNode(rule, pattern);\n                var aliasNode = this.__createAliasNode(rule, pattern);\n                typeNode.addOutNode(aliasNode, pattern);\n                aliasNode.addParentNode(typeNode);\n                parentNode = aliasNode;\n                var i = constraints.length - 1;\n                for (; i > 0; i--) {\n                    var constraint = constraints[i], node;\n                    if (constraint instanceof HashConstraint) {\n                        node = this.__createPropertyNode(rule, constraint);\n                    } else if (constraint instanceof ReferenceConstraint) {\n                        outNode.constraint.addConstraint(constraint);\n                        continue;\n                    } else {\n                        node = this.__createEqualityNode(rule, constraint);\n                    }\n                    parentNode.addOutNode(node, pattern);\n                    node.addParentNode(parentNode);\n                    parentNode = node;\n                }\n\n                if (outNode instanceof BetaNode) {\n                    var adapterNode = this.__createAdapterNode(rule, side);\n                    adapterNode.addParentNode(parentNode);\n                    parentNode.addOutNode(adapterNode, pattern);\n                    parentNode = adapterNode;\n                }\n                outNode.addParentNode(parentNode);\n                parentNode.addOutNode(outNode, pattern);\n                return typeNode;\n            }\n        },\n\n        print: function () {\n            forEach(this.terminalNodes, function (t) {\n                t.print(\"    \");\n            });\n        }\n    }\n}).as(exports, \"RootNode\");\n\n\n\n\n\n\n},{\"../constraint\":8,\"../extended\":12,\"../pattern.js\":48,\"./aliasNode\":19,\"./betaNode\":21,\"./equalityNode\":22,\"./existsFromNode\":23,\"./existsNode\":24,\"./fromNode\":25,\"./fromNotNode\":26,\"./joinNode\":28,\"./leftAdapterNode\":30,\"./notNode\":38,\"./propertyNode\":39,\"./rightAdapterNode\":40,\"./terminalNode\":41,\"./typeNode\":42}],28:[function(require,module,exports){\nvar BetaNode = require(\"./betaNode\"),\n    JoinReferenceNode = require(\"./joinReferenceNode\");\n\nBetaNode.extend({\n\n    instance: {\n        constructor: function () {\n            this._super(arguments);\n            this.constraint = new JoinReferenceNode(this.leftTuples, this.rightTuples);\n        },\n\n        nodeType: \"JoinNode\",\n\n        propagateFromLeft: function (context, rm) {\n            var mr;\n            if ((mr = this.constraint.match(context, rm)).isMatch) {\n                this.__propagate(\"assert\", this.__addToMemoryMatches(rm, context, context.clone(null, null, mr)));\n            }\n            return this;\n        },\n\n        propagateFromRight: function (context, lm) {\n            var mr;\n            if ((mr = this.constraint.match(lm, context)).isMatch) {\n                this.__propagate(\"assert\", this.__addToMemoryMatches(context, lm, context.clone(null, null, mr)));\n            }\n            return this;\n        },\n\n        propagateAssertModifyFromLeft: function (context, rightMatches, rm) {\n            var factId = rm.hashCode, mr;\n            if (factId in rightMatches) {\n                mr = this.constraint.match(context, rm);\n                var mrIsMatch = mr.isMatch;\n                if (!mrIsMatch) {\n                    this.__propagate(\"retract\", rightMatches[factId].clone());\n                } else {\n                    this.__propagate(\"modify\", this.__addToMemoryMatches(rm, context, context.clone(null, null, mr)));\n                }\n            } else {\n                this.propagateFromLeft(context, rm);\n            }\n        },\n\n        propagateAssertModifyFromRight: function (context, leftMatches, lm) {\n            var factId = lm.hashCode, mr;\n            if (factId in leftMatches) {\n                mr = this.constraint.match(lm, context);\n                var mrIsMatch = mr.isMatch;\n                if (!mrIsMatch) {\n                    this.__propagate(\"retract\", leftMatches[factId].clone());\n                } else {\n                    this.__propagate(\"modify\", this.__addToMemoryMatches(context, lm, context.clone(null, null, mr)));\n                }\n            } else {\n                this.propagateFromRight(context, lm);\n            }\n        }\n    }\n\n}).as(module);\n},{\"./betaNode\":21,\"./joinReferenceNode\":29}],29:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    constraints = require(\"../constraint\"),\n    ReferenceEqualityConstraint = constraints.ReferenceEqualityConstraint;\n\nvar DEFUALT_CONSTRAINT = {\n    isDefault: true,\n    assert: function () {\n        return true;\n    },\n\n    equal: function () {\n        return false;\n    }\n};\n\nvar inversions = {\n    \"gt\": \"lte\",\n    \"gte\": \"lte\",\n    \"lt\": \"gte\",\n    \"lte\": \"gte\",\n    \"eq\": \"eq\",\n    \"neq\": \"neq\"\n};\n\nfunction normalizeRightIndexConstraint(rightIndex, indexes, op) {\n    if (rightIndex === indexes[1]) {\n        op = inversions[op];\n    }\n    return op;\n}\n\nfunction normalizeLeftIndexConstraint(leftIndex, indexes, op) {\n    if (leftIndex === indexes[1]) {\n        op = inversions[op];\n    }\n    return op;\n}\n\nNode.extend({\n\n    instance: {\n\n        constraint: DEFUALT_CONSTRAINT,\n\n        constructor: function (leftMemory, rightMemory) {\n            this._super(arguments);\n            this.constraint = DEFUALT_CONSTRAINT;\n            this.constraintAssert = DEFUALT_CONSTRAINT.assert;\n            this.rightIndexes = [];\n            this.leftIndexes = [];\n            this.constraintLength = 0;\n            this.leftMemory = leftMemory;\n            this.rightMemory = rightMemory;\n        },\n\n        addConstraint: function (constraint) {\n            if (constraint instanceof ReferenceEqualityConstraint) {\n                var identifiers = constraint.getIndexableProperties();\n                var alias = constraint.get(\"alias\");\n                if (identifiers.length === 2 && alias) {\n                    var leftIndex, rightIndex, i = -1, indexes = [];\n                    while (++i < 2) {\n                        var index = identifiers[i];\n                        if (index.match(new RegExp(\"^\" + alias + \"(\\\\.?)\")) === null) {\n                            indexes.push(index);\n                            leftIndex = index;\n                        } else {\n                            indexes.push(index);\n                            rightIndex = index;\n                        }\n                    }\n                    if (leftIndex && rightIndex) {\n                        var leftOp = normalizeLeftIndexConstraint(leftIndex, indexes, constraint.op),\n                            rightOp = normalizeRightIndexConstraint(rightIndex, indexes, constraint.op);\n                        this.rightMemory.addIndex(rightIndex, leftIndex, rightOp);\n                        this.leftMemory.addIndex(leftIndex, rightIndex, leftOp);\n                    }\n                }\n            }\n            if (this.constraint.isDefault) {\n                this.constraint = constraint;\n                this.isDefault = false;\n            } else {\n                this.constraint = this.constraint.merge(constraint);\n            }\n            this.constraintAssert = this.constraint.assert;\n\n        },\n\n        equal: function (constraint) {\n            return this.constraint.equal(constraint.constraint);\n        },\n\n        isMatch: function (lc, rc) {\n            return this.constraintAssert(lc.factHash, rc.factHash);\n        },\n\n        match: function (lc, rc) {\n            var ret = {isMatch: false};\n            if (this.constraintAssert(lc.factHash, rc.factHash)) {\n                ret = lc.match.merge(rc.match);\n            }\n            return ret;\n        }\n\n    }\n\n}).as(module);\n},{\"../constraint\":8,\"./node\":37}],30:[function(require,module,exports){\nvar Node = require(\"./adapterNode\");\n\nNode.extend({\n    instance: {\n        propagateAssert: function (context) {\n            this.__propagate(\"assertLeft\", context);\n        },\n\n        propagateRetract: function (context) {\n            this.__propagate(\"retractLeft\", context);\n        },\n\n        propagateResolve: function (context) {\n            this.__propagate(\"retractResolve\", context);\n        },\n\n        propagateModify: function (context) {\n            this.__propagate(\"modifyLeft\", context);\n        },\n\n        retractResolve: function (match) {\n            this.__propagate(\"retractResolve\", match);\n        },\n\n        dispose: function (context) {\n            this.propagateDispose(context);\n        },\n\n        toString: function () {\n            return \"LeftAdapterNode \" + this.__count;\n        }\n    }\n\n}).as(module);\n},{\"./adapterNode\":18}],31:[function(require,module,exports){\nexports.getMemory = (function () {\n\n    var pPush = Array.prototype.push, NPL = 0, EMPTY_ARRAY = [], NOT_POSSIBLES_HASH = {}, POSSIBLES_HASH = {}, PL = 0;\n\n    function mergePossibleTuples(ret, a, l) {\n        var val, j = 0, i = -1;\n        if (PL < l) {\n            while (PL && ++i < l) {\n                if (POSSIBLES_HASH[(val = a[i]).hashCode]) {\n                    ret[j++] = val;\n                    PL--;\n                }\n            }\n        } else {\n            pPush.apply(ret, a);\n        }\n        PL = 0;\n        POSSIBLES_HASH = {};\n    }\n\n\n    function mergeNotPossibleTuples(ret, a, l) {\n        var val, j = 0, i = -1;\n        if (NPL < l) {\n            while (++i < l) {\n                if (!NPL) {\n                    ret[j++] = a[i];\n                } else if (!NOT_POSSIBLES_HASH[(val = a[i]).hashCode]) {\n                    ret[j++] = val;\n                } else {\n                    NPL--;\n                }\n            }\n        }\n        NPL = 0;\n        NOT_POSSIBLES_HASH = {};\n    }\n\n    function mergeBothTuples(ret, a, l) {\n        if (PL === l) {\n            mergeNotPossibles(ret, a, l);\n        } else if (NPL < l) {\n            var val, j = 0, i = -1, hashCode;\n            while (++i < l) {\n                if (!NOT_POSSIBLES_HASH[(hashCode = (val = a[i]).hashCode)] && POSSIBLES_HASH[hashCode]) {\n                    ret[j++] = val;\n                }\n            }\n        }\n        NPL = 0;\n        NOT_POSSIBLES_HASH = {};\n        PL = 0;\n        POSSIBLES_HASH = {};\n    }\n\n    function mergePossiblesAndNotPossibles(a, l) {\n        var ret = EMPTY_ARRAY;\n        if (l) {\n            if (NPL || PL) {\n                ret = [];\n                if (!NPL) {\n                    mergePossibleTuples(ret, a, l);\n                } else if (!PL) {\n                    mergeNotPossibleTuples(ret, a, l);\n                } else {\n                    mergeBothTuples(ret, a, l);\n                }\n            } else {\n                ret = a;\n            }\n        }\n        return ret;\n    }\n\n    function getRangeTuples(op, currEntry, val) {\n        var ret;\n        if (op === \"gt\") {\n            ret = currEntry.findGT(val);\n        } else if (op === \"gte\") {\n            ret = currEntry.findGTE(val);\n        } else if (op === \"lt\") {\n            ret = currEntry.findLT(val);\n        } else if (op === \"lte\") {\n            ret = currEntry.findLTE(val);\n        }\n        return ret;\n    }\n\n    function mergeNotPossibles(tuples, tl) {\n        if (tl) {\n            var j = -1, hashCode;\n            while (++j < tl) {\n                hashCode = tuples[j].hashCode;\n                if (!NOT_POSSIBLES_HASH[hashCode]) {\n                    NOT_POSSIBLES_HASH[hashCode] = true;\n                    NPL++;\n                }\n            }\n        }\n    }\n\n    function mergePossibles(tuples, tl) {\n        if (tl) {\n            var j = -1, hashCode;\n            while (++j < tl) {\n                hashCode = tuples[j].hashCode;\n                if (!POSSIBLES_HASH[hashCode]) {\n                    POSSIBLES_HASH[hashCode] = true;\n                    PL++;\n                }\n            }\n        }\n    }\n\n    return function _getMemory(entry, factHash, indexes) {\n        var i = -1, l = indexes.length,\n            ret = entry.tuples,\n            rl = ret.length,\n            intersected = false,\n            tables = entry.tables,\n            index, val, op, nextEntry, currEntry, tuples, tl;\n        while (++i < l && rl) {\n            index = indexes[i];\n            val = index[3](factHash);\n            op = index[4];\n            currEntry = tables[index[0]];\n            if (op === \"eq\" || op === \"seq\") {\n                if ((nextEntry = currEntry.get(val))) {\n                    rl = (ret = (entry = nextEntry).tuples).length;\n                    tables = nextEntry.tables;\n                } else {\n                    rl = (ret = EMPTY_ARRAY).length;\n                }\n            } else if (op === \"neq\" || op === \"sneq\") {\n                if ((nextEntry = currEntry.get(val))) {\n                    tl = (tuples = nextEntry.tuples).length;\n                    mergeNotPossibles(tuples, tl);\n                }\n            } else if (!intersected) {\n                rl = (ret = getRangeTuples(op, currEntry, val)).length;\n                intersected = true;\n            } else if ((tl = (tuples = getRangeTuples(op, currEntry, val)).length)) {\n                mergePossibles(tuples, tl);\n            } else {\n                ret = tuples;\n                rl = tl;\n            }\n        }\n        return mergePossiblesAndNotPossibles(ret, rl);\n    };\n}());\n},{}],32:[function(require,module,exports){\nvar Memory = require(\"./memory\");\n\nMemory.extend({\n\n    instance: {\n\n        getLeftMemory: function (tuple) {\n            return this.getMemory(tuple);\n        }\n    }\n\n}).as(module);\n},{\"./memory\":33}],33:[function(require,module,exports){\nvar extd = require(\"../../extended\"),\n    plucker = extd.plucker,\n    declare = extd.declare,\n    getMemory = require(\"./helpers\").getMemory,\n    Table = require(\"./table\"),\n    TupleEntry = require(\"./tupleEntry\");\n\n\nvar id = 0;\ndeclare({\n\n    instance: {\n        length: 0,\n\n        constructor: function () {\n            this.head = null;\n            this.tail = null;\n            this.indexes = [];\n            this.tables = new TupleEntry(null, new Table(), false);\n        },\n\n        push: function (data) {\n            var tail = this.tail, head = this.head, node = {data: data, tuples: [], hashCode: id++, prev: tail, next: null};\n            if (tail) {\n                this.tail.next = node;\n            }\n            this.tail = node;\n            if (!head) {\n                this.head = node;\n            }\n            this.length++;\n            this.__index(node);\n            this.tables.addNode(node);\n            return node;\n        },\n\n        remove: function (node) {\n            if (node.prev) {\n                node.prev.next = node.next;\n            } else {\n                this.head = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            } else {\n                this.tail = node.prev;\n            }\n            this.tables.removeNode(node);\n            this.__removeFromIndex(node);\n            this.length--;\n        },\n\n        forEach: function (cb) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                cb(head.data);\n            }\n        },\n\n        toArray: function () {\n            return this.tables.tuples.slice();\n        },\n\n        clear: function () {\n            this.head = this.tail = null;\n            this.length = 0;\n            this.clearIndexes();\n        },\n\n        clearIndexes: function () {\n            this.tables = {};\n            this.indexes.length = 0;\n        },\n\n        __index: function (node) {\n            var data = node.data,\n                factHash = data.factHash,\n                indexes = this.indexes,\n                entry = this.tables,\n                i = -1, l = indexes.length,\n                tuples, index, val, path, tables, currEntry, prevLookup;\n            while (++i < l) {\n                index = indexes[i];\n                val = index[2](factHash);\n                path = index[0];\n                tables = entry.tables;\n                if (!(tuples = (currEntry = tables[path] || (tables[path] = new Table())).get(val))) {\n                    tuples = new TupleEntry(val, currEntry, true);\n                    currEntry.set(val, tuples);\n                }\n                if (currEntry !== prevLookup) {\n                    node.tuples.push(tuples.addNode(node));\n                }\n                prevLookup = currEntry;\n                if (index[4] === \"eq\") {\n                    entry = tuples;\n                }\n            }\n        },\n\n        __removeFromIndex: function (node) {\n            var tuples = node.tuples, i = tuples.length;\n            while (--i >= 0) {\n                tuples[i].removeNode(node);\n            }\n            node.tuples.length = 0;\n        },\n\n        getMemory: function (tuple) {\n            var ret;\n            if (!this.length) {\n                ret = [];\n            } else {\n                ret = getMemory(this.tables, tuple.factHash, this.indexes);\n            }\n            return ret;\n        },\n\n        __createIndexTree: function () {\n            var table = this.tables.tables = {};\n            var indexes = this.indexes;\n            table[indexes[0][0]] = new Table();\n        },\n\n\n        addIndex: function (primary, lookup, op) {\n            this.indexes.push([primary, lookup, plucker(primary), plucker(lookup), op || \"eq\"]);\n            this.indexes.sort(function (a, b) {\n                var aOp = a[4], bOp = b[4];\n                return aOp === bOp ? 0 : aOp > bOp ? 1 : aOp === bOp ? 0 : -1;\n            });\n            this.__createIndexTree();\n\n        }\n\n    }\n\n}).as(module);\n},{\"../../extended\":12,\"./helpers\":31,\"./table\":35,\"./tupleEntry\":36}],34:[function(require,module,exports){\nvar Memory = require(\"./memory\");\n\nMemory.extend({\n\n    instance: {\n\n        getRightMemory: function (tuple) {\n            return this.getMemory(tuple);\n        }\n    }\n\n}).as(module);\n},{\"./memory\":33}],35:[function(require,module,exports){\nvar extd = require(\"../../extended\"),\n    pPush = Array.prototype.push,\n    HashTable = extd.HashTable,\n    AVLTree = extd.AVLTree;\n\nfunction compare(a, b) {\n    /*jshint eqeqeq: false*/\n    a = a.key;\n    b = b.key;\n    var ret;\n    if (a == b) {\n        ret = 0;\n    } else if (a > b) {\n        ret = 1;\n    } else if (a < b) {\n        ret = -1;\n    } else {\n        ret = 1;\n    }\n    return ret;\n}\n\nfunction compareGT(v1, v2) {\n    return compare(v1, v2) === 1;\n}\nfunction compareGTE(v1, v2) {\n    return compare(v1, v2) !== -1;\n}\n\nfunction compareLT(v1, v2) {\n    return compare(v1, v2) === -1;\n}\nfunction compareLTE(v1, v2) {\n    return compare(v1, v2) !== 1;\n}\n\nvar STACK = [],\n    VALUE = {key: null};\nfunction traverseInOrder(tree, key, comparator) {\n    VALUE.key = key;\n    var ret = [];\n    var i = 0, current = tree.__root, v;\n    while (true) {\n        if (current) {\n            current = (STACK[i++] = current).left;\n        } else {\n            if (i > 0) {\n                v = (current = STACK[--i]).data;\n                if (comparator(v, VALUE)) {\n                    pPush.apply(ret, v.value.tuples);\n                    current = current.right;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    STACK.length = 0;\n    return ret;\n}\n\nfunction traverseReverseOrder(tree, key, comparator) {\n    VALUE.key = key;\n    var ret = [];\n    var i = 0, current = tree.__root, v;\n    while (true) {\n        if (current) {\n            current = (STACK[i++] = current).right;\n        } else {\n            if (i > 0) {\n                v = (current = STACK[--i]).data;\n                if (comparator(v, VALUE)) {\n                    pPush.apply(ret, v.value.tuples);\n                    current = current.left;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    STACK.length = 0;\n    return ret;\n}\n\nAVLTree.extend({\n    instance: {\n\n        constructor: function () {\n            this._super([\n                {\n                    compare: compare\n                }\n            ]);\n            this.gtCache = new HashTable();\n            this.gteCache = new HashTable();\n            this.ltCache = new HashTable();\n            this.lteCache = new HashTable();\n            this.hasGTCache = false;\n            this.hasGTECache = false;\n            this.hasLTCache = false;\n            this.hasLTECache = false;\n        },\n\n        clearCache: function () {\n            this.hasGTCache && this.gtCache.clear() && (this.hasGTCache = false);\n            this.hasGTECache && this.gteCache.clear() && (this.hasGTECache = false);\n            this.hasLTCache && this.ltCache.clear() && (this.hasLTCache = false);\n            this.hasLTECache && this.lteCache.clear() && (this.hasLTECache = false);\n        },\n\n        contains: function (key) {\n            return  this._super([\n                {key: key}\n            ]);\n        },\n\n        \"set\": function (key, value) {\n            this.insert({key: key, value: value});\n            this.clearCache();\n        },\n\n        \"get\": function (key) {\n            var ret = this.find({key: key});\n            return ret && ret.value;\n        },\n\n        \"remove\": function (key) {\n            this.clearCache();\n            return this._super([\n                {key: key}\n            ]);\n        },\n\n        findGT: function (key) {\n            var ret = this.gtCache.get(key);\n            if (!ret) {\n                this.hasGTCache = true;\n                this.gtCache.put(key, (ret = traverseReverseOrder(this, key, compareGT)));\n            }\n            return ret;\n        },\n\n        findGTE: function (key) {\n            var ret = this.gteCache.get(key);\n            if (!ret) {\n                this.hasGTECache = true;\n                this.gteCache.put(key, (ret = traverseReverseOrder(this, key, compareGTE)));\n            }\n            return ret;\n        },\n\n        findLT: function (key) {\n            var ret = this.ltCache.get(key);\n            if (!ret) {\n                this.hasLTCache = true;\n                this.ltCache.put(key, (ret = traverseInOrder(this, key, compareLT)));\n            }\n            return ret;\n        },\n\n        findLTE: function (key) {\n            var ret = this.lteCache.get(key);\n            if (!ret) {\n                this.hasLTECache = true;\n                this.lteCache.put(key, (ret = traverseInOrder(this, key, compareLTE)));\n            }\n            return ret;\n        }\n\n    }\n}).as(module);\n},{\"../../extended\":12}],36:[function(require,module,exports){\nvar extd = require(\"../../extended\"),\n    indexOf = extd.indexOf;\n//    HashSet = require(\"./hashSet\");\n\n\nvar TUPLE_ID = 0;\nextd.declare({\n\n    instance: {\n        tuples: null,\n        tupleMap: null,\n        hashCode: null,\n        tables: null,\n        entry: null,\n        constructor: function (val, entry, canRemove) {\n            this.val = val;\n            this.canRemove = canRemove;\n            this.tuples = [];\n            this.tupleMap = {};\n            this.hashCode = TUPLE_ID++;\n            this.tables = {};\n            this.length = 0;\n            this.entry = entry;\n        },\n\n        addNode: function (node) {\n            this.tuples[this.length++] = node;\n            if (this.length > 1) {\n                this.entry.clearCache();\n            }\n            return this;\n        },\n\n        removeNode: function (node) {\n            var tuples = this.tuples, index = indexOf(tuples, node);\n            if (index !== -1) {\n                tuples.splice(index, 1);\n                this.length--;\n                this.entry.clearCache();\n            }\n            if (this.canRemove && !this.length) {\n                this.entry.remove(this.val);\n            }\n        }\n    }\n}).as(module);\n},{\"../../extended\":12}],37:[function(require,module,exports){\nvar extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    indexOf = extd.indexOf,\n    intersection = extd.intersection,\n    declare = extd.declare,\n    HashTable = extd.HashTable,\n    Context = require(\"../context\");\n\nvar count = 0;\ndeclare({\n    instance: {\n        constructor: function () {\n            this.nodes = new HashTable();\n            this.rules = [];\n            this.parentNodes = [];\n            this.__count = count++;\n            this.__entrySet = [];\n        },\n\n        addRule: function (rule) {\n            if (indexOf(this.rules, rule) === -1) {\n                this.rules.push(rule);\n            }\n            return this;\n        },\n\n        merge: function (that) {\n            that.nodes.forEach(function (entry) {\n                var patterns = entry.value, node = entry.key;\n                for (var i = 0, l = patterns.length; i < l; i++) {\n                    this.addOutNode(node, patterns[i]);\n                }\n                that.nodes.remove(node);\n            }, this);\n            var thatParentNodes = that.parentNodes;\n            for (var i = 0, l = that.parentNodes.l; i < l; i++) {\n                var parentNode = thatParentNodes[i];\n                this.addParentNode(parentNode);\n                parentNode.nodes.remove(that);\n            }\n            return this;\n        },\n\n        resolve: function (mr1, mr2) {\n            return mr1.hashCode === mr2.hashCode;\n        },\n\n        print: function (tab) {\n            console.log(tab + this.toString());\n            forEach(this.parentNodes, function (n) {\n                n.print(\"    \" + tab);\n            });\n        },\n\n        addOutNode: function (outNode, pattern) {\n            if (!this.nodes.contains(outNode)) {\n                this.nodes.put(outNode, []);\n            }\n            this.nodes.get(outNode).push(pattern);\n            this.__entrySet = this.nodes.entrySet();\n        },\n\n        addParentNode: function (n) {\n            if (indexOf(this.parentNodes, n) === -1) {\n                this.parentNodes.push(n);\n            }\n        },\n\n        shareable: function () {\n            return false;\n        },\n\n        __propagate: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode, paths, continuingPaths;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                paths = entry.value;\n\n                if ((continuingPaths = intersection(paths, context.paths)).length) {\n                    outNode[method](new Context(context.fact, continuingPaths, context.match));\n                }\n\n            }\n        },\n\n        dispose: function (assertable) {\n            this.propagateDispose(assertable);\n        },\n\n        retract: function (assertable) {\n            this.propagateRetract(assertable);\n        },\n\n        propagateDispose: function (assertable, outNodes) {\n            outNodes = outNodes || this.nodes;\n            var entrySet = this.__entrySet, i = entrySet.length - 1;\n            for (; i >= 0; i--) {\n                var entry = entrySet[i], outNode = entry.key;\n                outNode.dispose(assertable);\n            }\n        },\n\n        propagateAssert: function (assertable) {\n            this.__propagate(\"assert\", assertable);\n        },\n\n        propagateRetract: function (assertable) {\n            this.__propagate(\"retract\", assertable);\n        },\n\n        assert: function (assertable) {\n            this.propagateAssert(assertable);\n        },\n\n        modify: function (assertable) {\n            this.propagateModify(assertable);\n        },\n\n        propagateModify: function (assertable) {\n            this.__propagate(\"modify\", assertable);\n        }\n    }\n\n}).as(module);\n\n},{\"../context\":10,\"../extended\":12}],38:[function(require,module,exports){\nvar JoinNode = require(\"./joinNode\"),\n    LinkedList = require(\"../linkedList\"),\n    Context = require(\"../context\"),\n    InitialFact = require(\"../pattern\").InitialFact;\n\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"NotNode\",\n\n        constructor: function () {\n            this._super(arguments);\n            this.leftTupleMemory = {};\n            //use this ensure a unique match for and propagated context.\n            this.notMatch = new Context(new InitialFact()).match;\n        },\n\n        __cloneContext: function (context) {\n            return context.clone(null, null, context.match.merge(this.notMatch));\n        },\n\n\n        retractRight: function (context) {\n            var ctx = this.removeFromRightMemory(context),\n                rightContext = ctx.data,\n                blocking = rightContext.blocking;\n            if (blocking.length) {\n                //if we are blocking left contexts\n                var leftContext, thisConstraint = this.constraint, blockingNode = {next: blocking.head}, rc;\n                while ((blockingNode = blockingNode.next)) {\n                    leftContext = blockingNode.data;\n                    this.removeFromLeftBlockedMemory(leftContext);\n                    var rm = this.rightTuples.getRightMemory(leftContext), l = rm.length, i;\n                    i = -1;\n                    while (++i < l) {\n                        if (thisConstraint.isMatch(leftContext, rc = rm[i].data)) {\n                            this.blockedContext(leftContext, rc);\n                            leftContext = null;\n                            break;\n                        }\n                    }\n                    if (leftContext) {\n                        this.notBlockedContext(leftContext, true);\n                    }\n                }\n                blocking.clear();\n            }\n\n        },\n\n        blockedContext: function (leftContext, rightContext, propagate) {\n            leftContext.blocker = rightContext;\n            this.removeFromLeftMemory(leftContext);\n            this.addToLeftBlockedMemory(rightContext.blocking.push(leftContext));\n            propagate && this.__propagate(\"retract\", this.__cloneContext(leftContext));\n        },\n\n        notBlockedContext: function (leftContext, propagate) {\n            this.__addToLeftMemory(leftContext);\n            propagate && this.__propagate(\"assert\", this.__cloneContext(leftContext));\n        },\n\n        propagateFromLeft: function (leftContext) {\n            this.notBlockedContext(leftContext, true);\n        },\n\n        propagateFromRight: function (leftContext) {\n            this.notBlockedContext(leftContext, true);\n        },\n\n        blockFromAssertRight: function (leftContext, rightContext) {\n            this.blockedContext(leftContext, rightContext, true);\n        },\n\n        blockFromAssertLeft: function (leftContext, rightContext) {\n            this.blockedContext(leftContext, rightContext, false);\n        },\n\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                this.__propagate(\"retract\", this.__cloneContext(ctx));\n            } else {\n                if (!this.removeFromLeftBlockedMemory(context)) {\n                    throw new Error();\n                }\n            }\n        },\n\n        assertLeft: function (context) {\n            var values = this.rightTuples.getRightMemory(context),\n                thisConstraint = this.constraint, rc, i = -1, l = values.length;\n            while (++i < l) {\n                if (thisConstraint.isMatch(context, rc = values[i].data)) {\n                    this.blockFromAssertLeft(context, rc);\n                    context = null;\n                    i = l;\n                }\n            }\n            if (context) {\n                this.propagateFromLeft(context);\n            }\n        },\n\n        assertRight: function (context) {\n            this.__addToRightMemory(context);\n            context.blocking = new LinkedList();\n            var fl = this.leftTuples.getLeftMemory(context).slice(),\n                i = -1, l = fl.length,\n                leftContext, thisConstraint = this.constraint;\n            while (++i < l) {\n                leftContext = fl[i].data;\n                if (thisConstraint.isMatch(leftContext, context)) {\n                    this.blockFromAssertRight(leftContext, context);\n                }\n            }\n        },\n\n        addToLeftBlockedMemory: function (context) {\n            var data = context.data, hashCode = data.hashCode;\n            var ctx = this.leftMemory[hashCode];\n            this.leftTupleMemory[hashCode] = context;\n            if (ctx) {\n                this.leftTuples.remove(ctx);\n            }\n            return this;\n        },\n\n        removeFromLeftBlockedMemory: function (context) {\n            var ret = this.leftTupleMemory[context.hashCode] || null;\n            if (ret) {\n                delete this.leftTupleMemory[context.hashCode];\n                ret.data.blocker.blocking.remove(ret);\n            }\n            return ret;\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context),\n                leftContext,\n                thisConstraint = this.constraint,\n                rightTuples = this.rightTuples.getRightMemory(context),\n                l = rightTuples.length,\n                isBlocked = false,\n                i, rc, blocker;\n            if (!ctx) {\n                //blocked before\n                ctx = this.removeFromLeftBlockedMemory(context);\n                isBlocked = true;\n            }\n            if (ctx) {\n                leftContext = ctx.data;\n\n                if (leftContext && leftContext.blocker) {\n                    //we were blocked before so only check nodes previous to our blocker\n                    blocker = this.rightMemory[leftContext.blocker.hashCode];\n                    leftContext.blocker = null;\n                }\n                if (blocker) {\n                    if (thisConstraint.isMatch(context, rc = blocker.data)) {\n                        //we cant be proagated so retract previous\n                        if (!isBlocked) {\n                            //we were asserted before so retract\n                            this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                        }\n                        context.blocker = rc;\n                        this.addToLeftBlockedMemory(rc.blocking.push(context));\n                        context = null;\n                    }\n                }\n                if (context && l) {\n                    i = -1;\n                    //we were propogated before\n                    while (++i < l) {\n                        if (thisConstraint.isMatch(context, rc = rightTuples[i].data)) {\n                            //we cant be proagated so retract previous\n                            if (!isBlocked) {\n                                //we were asserted before so retract\n                                this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                            }\n                            this.addToLeftBlockedMemory(rc.blocking.push(context));\n                            context.blocker = rc;\n                            context = null;\n                            break;\n                        }\n                    }\n                }\n                if (context) {\n                    //we can still be propogated\n                    this.__addToLeftMemory(context);\n                    if (!isBlocked) {\n                        //we weren't blocked before so modify\n                        this.__propagate(\"modify\", this.__cloneContext(context));\n                    } else {\n                        //we were blocked before but aren't now\n                        this.__propagate(\"assert\", this.__cloneContext(context));\n                    }\n\n                }\n            } else {\n                throw new Error();\n            }\n\n        },\n\n        modifyRight: function (context) {\n            var ctx = this.removeFromRightMemory(context);\n            if (ctx) {\n                var rightContext = ctx.data,\n                    leftTuples = this.leftTuples.getLeftMemory(context).slice(),\n                    leftTuplesLength = leftTuples.length,\n                    leftContext,\n                    thisConstraint = this.constraint,\n                    i, node,\n                    blocking = rightContext.blocking;\n                this.__addToRightMemory(context);\n                context.blocking = new LinkedList();\n\n                var rc;\n                //check old blocked contexts\n                //check if the same contexts blocked before are still blocked\n                var blockingNode = {next: blocking.head};\n                while ((blockingNode = blockingNode.next)) {\n                    leftContext = blockingNode.data;\n                    leftContext.blocker = null;\n                    if (thisConstraint.isMatch(leftContext, context)) {\n                        leftContext.blocker = context;\n                        this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                        leftContext = null;\n                    } else {\n                        //we arent blocked anymore\n                        leftContext.blocker = null;\n                        node = ctx;\n                        while ((node = node.next)) {\n                            if (thisConstraint.isMatch(leftContext, rc = node.data)) {\n                                leftContext.blocker = rc;\n                                this.addToLeftBlockedMemory(rc.blocking.push(leftContext));\n                                leftContext = null;\n                                break;\n                            }\n                        }\n                        if (leftContext) {\n                            this.__addToLeftMemory(leftContext);\n                            this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                        }\n                    }\n                }\n                if (leftTuplesLength) {\n                    //check currently left tuples in memory\n                    i = -1;\n                    while (++i < leftTuplesLength) {\n                        leftContext = leftTuples[i].data;\n                        if (thisConstraint.isMatch(leftContext, context)) {\n                            this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                            this.removeFromLeftMemory(leftContext);\n                            this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                            leftContext.blocker = context;\n                        }\n                    }\n                }\n            } else {\n                throw new Error();\n            }\n\n\n        }\n    }\n}).as(module);\n},{\"../context\":10,\"../linkedList\":16,\"../pattern\":48,\"./joinNode\":28}],39:[function(require,module,exports){\nvar AlphaNode = require(\"./alphaNode\"),\n    Context = require(\"../context\"),\n    extd = require(\"../extended\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this._super(arguments);\n            this.alias = this.constraint.get(\"alias\");\n            this.varLength = (this.variables = extd(this.constraint.get(\"variables\")).toArray().value()).length;\n        },\n\n        assert: function (context) {\n            var c = new Context(context.fact, context.paths);\n            var variables = this.variables, o = context.fact.object, item;\n            c.set(this.alias, o);\n            for (var i = 0, l = this.varLength; i < l; i++) {\n                item = variables[i];\n                c.set(item[1], o[item[0]]);\n            }\n\n            this.__propagate(\"assert\", c);\n\n        },\n\n        retract: function (context) {\n            this.__propagate(\"retract\", new Context(context.fact, context.paths));\n        },\n\n        modify: function (context) {\n            var c = new Context(context.fact, context.paths);\n            var variables = this.variables, o = context.fact.object, item;\n            c.set(this.alias, o);\n            for (var i = 0, l = this.varLength; i < l; i++) {\n                item = variables[i];\n                c.set(item[1], o[item[0]]);\n            }\n            this.__propagate(\"modify\", c);\n        },\n\n\n        toString: function () {\n            return \"PropertyNode\" + this.__count;\n        }\n    }\n}).as(module);\n\n\n\n},{\"../context\":10,\"../extended\":12,\"./alphaNode\":20}],40:[function(require,module,exports){\nvar Node = require(\"./adapterNode\");\n\nNode.extend({\n    instance: {\n\n        retractResolve: function (match) {\n            this.__propagate(\"retractResolve\", match);\n        },\n\n        dispose: function (context) {\n            this.propagateDispose(context);\n        },\n\n        propagateAssert: function (context) {\n            this.__propagate(\"assertRight\", context);\n        },\n\n        propagateRetract: function (context) {\n            this.__propagate(\"retractRight\", context);\n        },\n\n        propagateResolve: function (context) {\n            this.__propagate(\"retractResolve\", context);\n        },\n\n        propagateModify: function (context) {\n            this.__propagate(\"modifyRight\", context);\n        },\n\n        toString: function () {\n            return \"RightAdapterNode \" + this.__count;\n        }\n    }\n}).as(module);\n},{\"./adapterNode\":18}],41:[function(require,module,exports){\nvar Node = require(\"./node\"),\n    extd = require(\"../extended\"),\n    bind = extd.bind;\n\nNode.extend({\n    instance: {\n        constructor: function (bucket, index, rule, agenda) {\n            this._super([]);\n            this.resolve = bind(this, this.resolve);\n            this.rule = rule;\n            this.index = index;\n            this.name = this.rule.name;\n            this.agenda = agenda;\n            this.bucket = bucket;\n            agenda.register(this);\n        },\n\n        __assertModify: function (context) {\n            var match = context.match;\n            if (match.isMatch) {\n                var rule = this.rule, bucket = this.bucket;\n                this.agenda.insert(this, {\n                    rule: rule,\n                    hashCode: context.hashCode,\n                    index: this.index,\n                    name: rule.name,\n                    recency: bucket.recency++,\n                    match: match,\n                    counter: bucket.counter\n                });\n            }\n        },\n\n        assert: function (context) {\n            this.__assertModify(context);\n        },\n\n        modify: function (context) {\n            this.agenda.retract(this, context);\n            this.__assertModify(context);\n        },\n\n        retract: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        retractRight: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        retractLeft: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        assertLeft: function (context) {\n            this.__assertModify(context);\n        },\n\n        assertRight: function (context) {\n            this.__assertModify(context);\n        },\n\n        toString: function () {\n            return \"TerminalNode \" + this.rule.name;\n        }\n    }\n}).as(module);\n},{\"../extended\":12,\"./node\":37}],42:[function(require,module,exports){\nvar AlphaNode = require(\"./alphaNode\"),\n    Context = require(\"../context\");\n\nAlphaNode.extend({\n    instance: {\n\n        assert: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"assert\", fact);\n            }\n        },\n\n        modify: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"modify\", fact);\n            }\n        },\n\n        retract: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"retract\", fact);\n            }\n        },\n\n        toString: function () {\n            return \"TypeNode\" + this.__count;\n        },\n\n        dispose: function () {\n            var es = this.__entrySet, i = es.length - 1;\n            for (; i >= 0; i--) {\n                var e = es[i], outNode = e.key, paths = e.value;\n                outNode.dispose({paths: paths});\n            }\n        },\n\n        __propagate: function (method, fact) {\n            var es = this.__entrySet, i = -1, l = es.length;\n            while (++i < l) {\n                var e = es[i], outNode = e.key, paths = e.value;\n                outNode[method](new Context(fact, paths));\n            }\n        }\n    }\n}).as(module);\n\n\n},{\"../context\":10,\"./alphaNode\":20}],43:[function(require,module,exports){\nvar process=require(\"__browserify_process\");/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,29],$V1=[1,30],$V2=[1,26],$V3=[1,24],$V4=[1,16],$V5=[1,18],$V6=[1,19],$V7=[1,20],$V8=[1,21],$V9=[1,22],$Va=[5,38,49],$Vb=[1,33],$Vc=[5,36,38,49],$Vd=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Ve=[2,2],$Vf=[5,24,25,26,27,28,29,36,38,49],$Vg=[1,42],$Vh=[1,43],$Vi=[1,44],$Vj=[1,45],$Vk=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,31,33,36,38,40,46,49],$Vl=[1,46],$Vm=[1,47],$Vn=[1,48],$Vo=[5,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vp=[1,50],$Vq=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,31,33,36,38,40,43,44,46,48,49],$Vr=[5,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vs=[1,55],$Vt=[1,54],$Vu=[5,8,15,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vv=[1,56],$Vw=[1,57],$Vx=[1,58],$Vy=[1,87],$Vz=[40,46,49];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"EXPRESSION\":4,\"EOF\":5,\"UNARY_EXPRESSION\":6,\"LITERAL_EXPRESSION\":7,\"-\":8,\"!\":9,\"MULTIPLICATIVE_EXPRESSION\":10,\"*\":11,\"/\":12,\"%\":13,\"ADDITIVE_EXPRESSION\":14,\"+\":15,\"EXPONENT_EXPRESSION\":16,\"^\":17,\"RELATIONAL_EXPRESSION\":18,\"<\":19,\">\":20,\"<=\":21,\">=\":22,\"EQUALITY_EXPRESSION\":23,\"==\":24,\"===\":25,\"!=\":26,\"!==\":27,\"=~\":28,\"!=~\":29,\"IN_EXPRESSION\":30,\"in\":31,\"ARRAY_EXPRESSION\":32,\"notIn\":33,\"OBJECT_EXPRESSION\":34,\"AND_EXPRESSION\":35,\"&&\":36,\"OR_EXPRESSION\":37,\"||\":38,\"ARGUMENT_LIST\":39,\",\":40,\"IDENTIFIER_EXPRESSION\":41,\"IDENTIFIER\":42,\".\":43,\"[\":44,\"STRING_EXPRESSION\":45,\"]\":46,\"NUMBER_EXPRESSION\":47,\"(\":48,\")\":49,\"STRING\":50,\"NUMBER\":51,\"REGEXP_EXPRESSION\":52,\"REGEXP\":53,\"BOOLEAN_EXPRESSION\":54,\"BOOLEAN\":55,\"NULL_EXPRESSION\":56,\"NULL\":57,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",8:\"-\",9:\"!\",11:\"*\",12:\"/\",13:\"%\",15:\"+\",17:\"^\",19:\"<\",20:\">\",21:\"<=\",22:\">=\",24:\"==\",25:\"===\",26:\"!=\",27:\"!==\",28:\"=~\",29:\"!=~\",31:\"in\",33:\"notIn\",36:\"&&\",38:\"||\",40:\",\",42:\"IDENTIFIER\",43:\".\",44:\"[\",46:\"]\",48:\"(\",49:\")\",50:\"STRING\",51:\"NUMBER\",53:\"REGEXP\",55:\"BOOLEAN\",57:\"NULL\"},\nproductions_: [0,[3,2],[6,1],[6,2],[6,2],[10,1],[10,3],[10,3],[10,3],[14,1],[14,3],[14,3],[16,1],[16,3],[18,1],[18,3],[18,3],[18,3],[18,3],[23,1],[23,3],[23,3],[23,3],[23,3],[23,3],[23,3],[30,1],[30,3],[30,3],[30,3],[30,3],[35,1],[35,3],[37,1],[37,3],[39,1],[39,3],[41,1],[34,1],[34,3],[34,4],[34,4],[34,4],[34,3],[34,4],[45,1],[47,1],[52,1],[54,1],[56,1],[32,2],[32,3],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,3],[4,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\nreturn $$[$0-1];\nbreak;\ncase 3:\nthis.$ = [$$[$0], null, 'unary'];\nbreak;\ncase 4:\nthis.$ = [$$[$0], null, 'logicalNot'];\nbreak;\ncase 6:\nthis.$ = [$$[$0-2], $$[$0], 'mult'];\nbreak;\ncase 7:\nthis.$ = [$$[$0-2], $$[$0], 'div'];\nbreak;\ncase 8:\nthis.$ = [$$[$0-2], $$[$0], 'mod'];\nbreak;\ncase 10:\nthis.$ = [$$[$0-2], $$[$0], 'plus'];\nbreak;\ncase 11:\nthis.$ = [$$[$0-2], $$[$0], 'minus'];\nbreak;\ncase 13:\nthis.$ = [$$[$0-2], $$[$0], 'pow'];\nbreak;\ncase 15:\nthis.$ = [$$[$0-2], $$[$0], 'lt'];\nbreak;\ncase 16:\nthis.$ = [$$[$0-2], $$[$0], 'gt'];\nbreak;\ncase 17:\nthis.$ = [$$[$0-2], $$[$0], 'lte'];\nbreak;\ncase 18:\nthis.$ = [$$[$0-2], $$[$0], 'gte'];\nbreak;\ncase 20:\nthis.$ = [$$[$0-2], $$[$0], 'eq'];\nbreak;\ncase 21:\nthis.$ = [$$[$0-2], $$[$0], 'seq'];\nbreak;\ncase 22:\nthis.$ = [$$[$0-2], $$[$0], 'neq'];\nbreak;\ncase 23:\nthis.$ = [$$[$0-2], $$[$0], 'sneq'];\nbreak;\ncase 24:\nthis.$ = [$$[$0-2], $$[$0], 'like'];\nbreak;\ncase 25:\nthis.$ = [$$[$0-2], $$[$0], 'notLike'];\nbreak;\ncase 27: case 29:\nthis.$ = [$$[$0-2], $$[$0], 'in'];\nbreak;\ncase 28: case 30:\nthis.$ = [$$[$0-2], $$[$0], 'notIn'];\nbreak;\ncase 32:\nthis.$ = [$$[$0-2], $$[$0], 'and'];\nbreak;\ncase 34:\nthis.$ = [$$[$0-2], $$[$0], 'or'];\nbreak;\ncase 36:\nthis.$ = [$$[$0-2], $$[$0], 'arguments']\nbreak;\ncase 37:\nthis.$ = [String(yytext), null, 'identifier'];\nbreak;\ncase 39:\nthis.$ = [$$[$0-2],$$[$0], 'prop'];\nbreak;\ncase 40: case 41: case 42:\nthis.$ = [$$[$0-3],$$[$0-1], 'propLookup'];\nbreak;\ncase 43:\nthis.$ = [$$[$0-2], [null, null, 'arguments'], 'function']\nbreak;\ncase 44:\nthis.$ = [$$[$0-3], $$[$0-1], 'function']\nbreak;\ncase 45:\nthis.$ = [String(yytext.replace(/^['|\"]|['|\"]$/g, '')), null, 'string'];\nbreak;\ncase 46:\nthis.$ = [Number(yytext), null, 'number'];\nbreak;\ncase 47:\nthis.$ = [yytext, null, 'regexp'];\nbreak;\ncase 48:\nthis.$ = [yytext.replace(/^\\s+/, '') == 'true', null, 'boolean'];\nbreak;\ncase 49:\nthis.$ = [null, null, 'null'];\nbreak;\ncase 50:\nthis.$ = [null, null, 'array'];\nbreak;\ncase 51:\nthis.$ = [$$[$0-1], null, 'array'];\nbreak;\ncase 59:\nthis.$ = [$$[$0-1], null, 'composite']\nbreak;\n}\n},\ntable: [{3:1,4:2,6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:4,37:3,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{1:[3]},{5:[1,31]},o([5,49],[2,60],{38:[1,32]}),o($Va,[2,33],{36:$Vb}),o($Vc,[2,31]),o($Vc,[2,26],{24:[1,34],25:[1,35],26:[1,36],27:[1,37],28:[1,38],29:[1,39]}),o($Vd,$Ve,{31:[1,40],33:[1,41]}),o($Vf,[2,19],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vk,[2,52]),o($Vk,[2,53]),o($Vk,[2,54]),o($Vk,[2,55]),o($Vk,[2,56]),o($Vk,[2,57],{43:$Vl,44:$Vm,48:$Vn}),o($Vk,[2,58]),{4:49,6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:4,37:3,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vo,[2,14],{17:$Vp}),o($Vk,[2,45]),o($Vk,[2,46]),o($Vk,[2,47]),o($Vk,[2,48]),o($Vk,[2,49]),o($Vq,[2,38]),{7:53,32:15,34:14,39:52,41:23,42:$V2,44:$V3,45:9,46:[1,51],47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vr,[2,12],{8:$Vs,15:$Vt}),o($Vq,[2,37]),o($Vu,[2,9],{11:$Vv,12:$Vw,13:$Vx}),o($Vd,[2,5]),{6:59,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:61,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{1:[2,1]},{6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:62,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:63,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:64,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:65,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:66,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:67,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:68,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:69,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{32:70,34:71,41:23,42:$V2,44:$V3},{32:72,34:73,41:23,42:$V2,44:$V3},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:74,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:75,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:76,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:77,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{41:78,42:$V2},{34:81,41:23,42:$V2,45:79,47:80,50:$V5,51:$V6},{7:53,32:15,34:14,39:83,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,49:[1,82],50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{49:[1,84]},{6:28,7:60,8:$V0,9:$V1,10:27,14:85,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vk,[2,50]),{40:$Vy,46:[1,86]},o($Vz,[2,35]),{6:28,7:60,8:$V0,9:$V1,10:88,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:89,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:90,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:91,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:92,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vd,[2,3]),o($Vd,$Ve),o($Vd,[2,4]),o($Va,[2,34],{36:$Vb}),o($Vc,[2,32]),o($Vf,[2,20],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,21],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,22],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,23],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,24],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,25],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vc,[2,27]),o($Vc,[2,29],{43:$Vl,44:$Vm,48:$Vn}),o($Vc,[2,28]),o($Vc,[2,30],{43:$Vl,44:$Vm,48:$Vn}),o($Vo,[2,15],{17:$Vp}),o($Vo,[2,16],{17:$Vp}),o($Vo,[2,17],{17:$Vp}),o($Vo,[2,18],{17:$Vp}),o($Vq,[2,39]),{46:[1,93]},{46:[1,94]},{43:$Vl,44:$Vm,46:[1,95],48:$Vn},o($Vq,[2,43]),{40:$Vy,49:[1,96]},o($Vk,[2,59]),o($Vr,[2,13],{8:$Vs,15:$Vt}),o($Vk,[2,51]),{7:97,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vu,[2,10],{11:$Vv,12:$Vw,13:$Vx}),o($Vu,[2,11],{11:$Vv,12:$Vw,13:$Vx}),o($Vd,[2,6]),o($Vd,[2,7]),o($Vd,[2,8]),o($Vq,[2,40]),o($Vq,[2,41]),o($Vq,[2,42]),o($Vq,[2,44]),o($Vz,[2,36])],\ndefaultActions: {31:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 31;\nbreak;\ncase 1:return 33;\nbreak;\ncase 2:return 'from';\nbreak;\ncase 3:return 24;\nbreak;\ncase 4:return 25;\nbreak;\ncase 5:return 26;\nbreak;\ncase 6:return 27;\nbreak;\ncase 7:return 21;\nbreak;\ncase 8:return 19;\nbreak;\ncase 9:return 22;\nbreak;\ncase 10:return 20;\nbreak;\ncase 11:return 28;\nbreak;\ncase 12:return 29;\nbreak;\ncase 13:return 36;\nbreak;\ncase 14:return 38;\nbreak;\ncase 15:return 57;\nbreak;\ncase 16:return 55;\nbreak;\ncase 17:/* skip whitespace */\nbreak;\ncase 18:return 51;\nbreak;\ncase 19:return 50;\nbreak;\ncase 20:return 50;\nbreak;\ncase 21:return 42;\nbreak;\ncase 22:return 53;\nbreak;\ncase 23:return 43;\nbreak;\ncase 24:return 11;\nbreak;\ncase 25:return 12;\nbreak;\ncase 26:return 13;\nbreak;\ncase 27:return 40;\nbreak;\ncase 28:return 8;\nbreak;\ncase 29:return 28;\nbreak;\ncase 30:return 29;\nbreak;\ncase 31:return 25;\nbreak;\ncase 32:return 24;\nbreak;\ncase 33:return 27;\nbreak;\ncase 34:return 26;\nbreak;\ncase 35:return 21;\nbreak;\ncase 36:return 22;\nbreak;\ncase 37:return 20;\nbreak;\ncase 38:return 19;\nbreak;\ncase 39:return 36;\nbreak;\ncase 40:return 38;\nbreak;\ncase 41:return 15;\nbreak;\ncase 42:return 17;\nbreak;\ncase 43:return 48;\nbreak;\ncase 44:return 46;\nbreak;\ncase 45:return 44;\nbreak;\ncase 46:return 49;\nbreak;\ncase 47:return 9;\nbreak;\ncase 48:return 5;\nbreak;\n}\n},\nrules: [/^(?:\\s+in\\b)/,/^(?:\\s+notIn\\b)/,/^(?:\\s+from\\b)/,/^(?:\\s+(eq|EQ)\\b)/,/^(?:\\s+(seq|SEQ)\\b)/,/^(?:\\s+(neq|NEQ)\\b)/,/^(?:\\s+(sneq|SNEQ)\\b)/,/^(?:\\s+(lte|LTE)\\b)/,/^(?:\\s+(lt|LT)\\b)/,/^(?:\\s+(gte|GTE)\\b)/,/^(?:\\s+(gt|GT)\\b)/,/^(?:\\s+(like|LIKE)\\b)/,/^(?:\\s+(notLike|NOT_LIKE)\\b)/,/^(?:\\s+(and|AND)\\b)/,/^(?:\\s+(or|OR)\\b)/,/^(?:\\s*(null)\\b)/,/^(?:\\s*(true|false)\\b)/,/^(?:\\s+)/,/^(?:-?[0-9]+(?:\\.[0-9]+)?\\b)/,/^(?:'[^']*')/,/^(?:\"[^\"]*\")/,/^(?:([a-zA-Z_$][0-9a-zA-Z_$]*))/,/^(?:^\\/((?![\\s=])[^[\\/\\n\\\\]*(?:(?:\\\\[\\s\\S]|\\[[^\\]\\n\\\\]*(?:\\\\[\\s\\S][^\\]\\n\\\\]*)*])[^[\\/\\n\\\\]*)*\\/[imgy]{0,4})(?!\\w))/,/^(?:\\.)/,/^(?:\\*)/,/^(?:\\/)/,/^(?:\\%)/,/^(?:,)/,/^(?:-)/,/^(?:=~)/,/^(?:!=~)/,/^(?:===)/,/^(?:==)/,/^(?:!==)/,/^(?:!=)/,/^(?:<=)/,/^(?:>=)/,/^(?:>)/,/^(?:<)/,/^(?:&&)/,/^(?:\\|\\|)/,/^(?:\\+)/,/^(?:\\^)/,/^(?:\\()/,/^(?:\\])/,/^(?:\\[)/,/^(?:\\))/,/^(?:!)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n},{\"__browserify_process\":64,\"fs\":61,\"path\":62}],44:[function(require,module,exports){\n(function () {\n    \"use strict\";\n    var constraintParser = require(\"./constraint/parser\"),\n        noolParser = require(\"./nools/nool.parser\");\n\n    exports.parseConstraint = function (expression) {\n        try {\n            return constraintParser.parse(expression);\n        } catch (e) {\n            throw new Error(\"Invalid expression '\" + expression + \"'\");\n        }\n    };\n\n    exports.parseRuleSet = function (source, file) {\n        return noolParser.parse(source, file);\n    };\n})();\n},{\"./constraint/parser\":43,\"./nools/nool.parser\":45}],45:[function(require,module,exports){\n\"use strict\";\n\nvar tokens = require(\"./tokens.js\"),\n    extd = require(\"../../extended\"),\n    keys = extd.hash.keys,\n    utils = require(\"./util.js\");\n\nvar parse = function (src, keywords, context) {\n    var orig = src;\n    src = src.replace(/\\/\\/(.*)/g, \"\").replace(/\\r\\n|\\r|\\n/g, \" \");\n\n    var blockTypes = new RegExp(\"^(\" + keys(keywords).join(\"|\") + \")\"), index;\n    while (src && (index = utils.findNextTokenIndex(src)) !== -1) {\n        src = src.substr(index);\n        var blockType = src.match(blockTypes);\n        if (blockType !== null) {\n            blockType = blockType[1];\n            if (blockType in keywords) {\n                try {\n                    src = keywords[blockType](src, context, parse).replace(/^\\s*|\\s*$/g, \"\");\n                } catch (e) {\n                    throw new Error(\"Invalid \" + blockType + \" definition \\n\" + e.message + \"; \\nstarting at : \" + orig);\n                }\n            } else {\n                throw new Error(\"Unknown token\" + blockType);\n            }\n        } else {\n            throw new Error(\"Error parsing \" + src);\n        }\n    }\n};\n\nexports.parse = function (src, file) {\n    var context = {define: [], rules: [], scope: [], loaded: [], file: file};\n    parse(src, tokens, context);\n    return context;\n};\n\n\n},{\"../../extended\":12,\"./tokens.js\":46,\"./util.js\":47}],46:[function(require,module,exports){\nvar process=require(\"__browserify_process\");\"use strict\";\n\nvar utils = require(\"./util.js\"),\n    fs = require(\"fs\"),\n    extd = require(\"../../extended\"),\n    filter = extd.filter,\n    indexOf = extd.indexOf,\n    predicates = [\"not\", \"or\", \"exists\"],\n    predicateRegExp = new RegExp(\"^(\" + predicates.join(\"|\") + \") *\\\\((.*)\\\\)$\", \"m\"),\n    predicateBeginExp = new RegExp(\" *(\" + predicates.join(\"|\") + \") *\\\\(\", \"g\");\n\nvar isWhiteSpace = function (str) {\n    return str.replace(/[\\s|\\n|\\r|\\t]/g, \"\").length === 0;\n};\n\nvar joinFunc = function (m, str) {\n    return \"; \" + str;\n};\n\nvar splitRuleLineByPredicateExpressions = function (ruleLine) {\n    var str = ruleLine.replace(/,\\s*(\\$?\\w+\\s*:)/g, joinFunc);\n    var parts = filter(str.split(predicateBeginExp), function (str) {\n            return str !== \"\";\n        }),\n        l = parts.length, ret = [];\n\n    if (l) {\n        for (var i = 0; i < l; i++) {\n            if (indexOf(predicates, parts[i]) !== -1) {\n                ret.push([parts[i], \"(\", parts[++i].replace(/, *$/, \"\")].join(\"\"));\n            } else {\n                ret.push(parts[i].replace(/, *$/, \"\"));\n            }\n        }\n    } else {\n        return str;\n    }\n    return ret.join(\";\");\n};\n\nvar ruleTokens = {\n\n    salience: (function () {\n        var salienceRegexp = /^(salience|priority)\\s*:\\s*(-?\\d+)\\s*[,;]?/;\n        return function (src, context) {\n            if (salienceRegexp.test(src)) {\n                var parts = src.match(salienceRegexp),\n                    priority = parseInt(parts[2], 10);\n                if (!isNaN(priority)) {\n                    context.options.priority = priority;\n                } else {\n                    throw new Error(\"Invalid salience/priority \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    agendaGroup: (function () {\n        var agendaGroupRegexp = /^(agenda-group|agendaGroup)\\s*:\\s*([a-zA-Z_$][0-9a-zA-Z_$]*|\"[^\"]*\"|'[^']*')\\s*[,;]?/;\n        return function (src, context) {\n            if (agendaGroupRegexp.test(src)) {\n                var parts = src.match(agendaGroupRegexp),\n                    agendaGroup = parts[2];\n                if (agendaGroup) {\n                    context.options.agendaGroup = agendaGroup.replace(/^[\"']|[\"']$/g, \"\");\n                } else {\n                    throw new Error(\"Invalid agenda-group \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    autoFocus: (function () {\n        var autoFocusRegexp = /^(auto-focus|autoFocus)\\s*:\\s*(true|false)\\s*[,;]?/;\n        return function (src, context) {\n            if (autoFocusRegexp.test(src)) {\n                var parts = src.match(autoFocusRegexp),\n                    autoFocus = parts[2];\n                if (autoFocus) {\n                    context.options.autoFocus = autoFocus === \"true\" ? true : false;\n                } else {\n                    throw new Error(\"Invalid auto-focus \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    \"agenda-group\": function () {\n        return this.agendaGroup.apply(this, arguments);\n    },\n\n    \"auto-focus\": function () {\n        return this.autoFocus.apply(this, arguments);\n    },\n\n    priority: function () {\n        return this.salience.apply(this, arguments);\n    },\n\n    when: (function () {\n        /*jshint evil:true*/\n\n        var ruleRegExp = /^(\\$?\\w+) *: *(\\w+)(.*)/;\n\n        var constraintRegExp = /(\\{ *(?:[\"']?\\$?\\w+[\"']?\\s*:\\s*[\"']?\\$?\\w+[\"']? *(?:, *[\"']?\\$?\\w+[\"']?\\s*:\\s*[\"']?\\$?\\w+[\"']?)*)+ *\\})/;\n        var fromRegExp = /(\\bfrom\\s+.*)/;\n        var parseRules = function (str) {\n            var rules = [];\n            var ruleLines = str.split(\";\"), l = ruleLines.length, ruleLine;\n            for (var i = 0; i < l && (ruleLine = ruleLines[i].replace(/^\\s*|\\s*$/g, \"\").replace(/\\n/g, \"\")); i++) {\n                if (!isWhiteSpace(ruleLine)) {\n                    var rule = [];\n                    if (predicateRegExp.test(ruleLine)) {\n                        var m = ruleLine.match(predicateRegExp);\n                        var pred = m[1].replace(/^\\s*|\\s*$/g, \"\");\n                        rule.push(pred);\n                        ruleLine = m[2].replace(/^\\s*|\\s*$/g, \"\");\n                        if (pred === \"or\") {\n                            rule = rule.concat(parseRules(splitRuleLineByPredicateExpressions(ruleLine)));\n                            rules.push(rule);\n                            continue;\n                        }\n\n                    }\n                    var parts = ruleLine.match(ruleRegExp);\n                    if (parts && parts.length) {\n                        rule.push(parts[2], parts[1]);\n                        var constraints = parts[3].replace(/^\\s*|\\s*$/g, \"\");\n                        var hashParts = constraints.match(constraintRegExp), from = null, fromMatch;\n                        if (hashParts) {\n                            var hash = hashParts[1], constraint = constraints.replace(hash, \"\");\n                            if (fromRegExp.test(constraint)) {\n                                fromMatch = constraint.match(fromRegExp);\n                                from = fromMatch[0];\n                                constraint = constraint.replace(fromMatch[0], \"\");\n                            }\n                            if (constraint) {\n                                rule.push(constraint.replace(/^\\s*|\\s*$/g, \"\"));\n                            }\n                            if (hash) {\n                                rule.push(eval(\"(\" + hash.replace(/(\\$?\\w+)\\s*:\\s*(\\$?\\w+)/g, '\"$1\" : \"$2\"') + \")\"));\n                            }\n                        } else if (constraints && !isWhiteSpace(constraints)) {\n                            if (fromRegExp.test(constraints)) {\n                                fromMatch = constraints.match(fromRegExp);\n                                from = fromMatch[0];\n                                constraints = constraints.replace(fromMatch[0], \"\");\n                            }\n                            rule.push(constraints);\n                        }\n                        if (from) {\n                            rule.push(from);\n                        }\n                        rules.push(rule);\n                    } else {\n                        throw new Error(\"Invalid constraint \" + ruleLine);\n                    }\n                }\n            }\n            return rules;\n        };\n\n        return function (orig, context) {\n            var src = orig.replace(/^when\\s*/, \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                context.constraints = parseRules(body.replace(/^\\{\\s*|\\}\\s*$/g, \"\"));\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        };\n    })(),\n\n    then: (function () {\n        return function (orig, context) {\n            if (!context.action) {\n                var src = orig.replace(/^then\\s*/, \"\").replace(/^\\s*|\\s*$/g, \"\");\n                if (utils.findNextToken(src) === \"{\") {\n                    var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                    src = src.replace(body, \"\");\n                    if (!context.action) {\n                        context.action = body.replace(/^\\{\\s*|\\}\\s*$/g, \"\");\n                    }\n                    if (!isWhiteSpace(src)) {\n                        throw new Error(\"Error parsing then block \" + orig);\n                    }\n                    return src;\n                } else {\n                    throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n                }\n            } else {\n                throw new Error(\"action already defined for rule\" + context.name);\n            }\n\n        };\n    })()\n};\n\nvar topLevelTokens = {\n    \"/\": function (orig) {\n        if (orig.match(/^\\/\\*/)) {\n            // Block Comment parse\n            return orig.replace(/\\/\\*.*?\\*\\//, \"\");\n        } else {\n            return orig;\n        }\n    },\n\n    \"define\": function (orig, context) {\n        var src = orig.replace(/^define\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*)/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                name = name[1];\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                //should\n                context.define.push({name: name, properties: \"(\" + body + \")\"});\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    \"import\": function (orig, context, parse) {\n        if (typeof window !== 'undefined') {\n            throw new Error(\"import cannot be used in a browser\");\n        }\n        var src = orig.replace(/^import\\s*/, \"\");\n        if (utils.findNextToken(src) === \"(\") {\n            var file = utils.getParamList(src);\n            src = src.replace(file, \"\").replace(/^\\s*|\\s*$/g, \"\");\n            utils.findNextToken(src) === \";\" && (src = src.replace(/\\s*;/, \"\"));\n            file = file.replace(/[\\(|\\)]/g, \"\").split(\",\");\n            if (file.length === 1) {\n                file = utils.resolve(context.file || process.cwd(), file[0].replace(/[\"|']/g, \"\"));\n                if (indexOf(context.loaded, file) === -1) {\n                    var origFile = context.file;\n                    context.file = file;\n                    parse(fs.readFileSync(file, \"utf8\"), topLevelTokens, context);\n                    context.loaded.push(file);\n                    context.file = origFile;\n                }\n                return src;\n            } else {\n                throw new Error(\"import accepts a single file\");\n            }\n        } else {\n            throw new Error(\"unexpected token : expected : '(' found : '\" + utils.findNextToken(src) + \"'\");\n        }\n\n    },\n\n    //define a global\n    \"global\": function (orig, context) {\n        var src = orig.replace(/^global\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*\\s*)/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"=\") {\n                name = name[1].replace(/^\\s+|\\s+$/g, '');\n                var fullbody = utils.getTokensBetween(src, \"=\", \";\", true).join(\"\");\n                var body = fullbody.substring(1, fullbody.length - 1);\n                body = body.replace(/^\\s+|\\s+$/g, '');\n                if (/^require\\(/.test(body)) {\n                    var file = utils.getParamList(body.replace(\"require\")).replace(/[\\(|\\)]/g, \"\").split(\",\");\n                    if (file.length === 1) {\n                        //handle relative require calls\n                        file = file[0].replace(/[\"|']/g, \"\");\n                        body = [\"require('\", utils.resolve(context.file || process.cwd(), file) , \"')\"].join(\"\");\n                    }\n                }\n                context.scope.push({name: name, body: body});\n                src = src.replace(fullbody, \"\");\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '=' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    //define a function\n    \"function\": function (orig, context) {\n        var src = orig.replace(/^function\\s*/, \"\");\n        //parse the function name\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*)\\s*/);\n        if (name) {\n            src = src.replace(name[0], \"\");\n            if (utils.findNextToken(src) === \"(\") {\n                name = name[1];\n                var params = utils.getParamList(src);\n                src = src.replace(params, \"\").replace(/^\\s*|\\s*$/g, \"\");\n                if (utils.findNextToken(src) === \"{\") {\n                    var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                    src = src.replace(body, \"\");\n                    //should\n                    context.scope.push({name: name, body: \"function\" + params + body});\n                    return src;\n                } else {\n                    throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n                }\n            } else {\n                throw new Error(\"unexpected token : expected : '(' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    \"rule\": function (orig, context, parse) {\n        var src = orig.replace(/^rule\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*|\"[^\"]*\"|'[^']*')/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                name = name[1].replace(/^[\"']|[\"']$/g, \"\");\n                var rule = {name: name, options: {}, constraints: null, action: null};\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                parse(body.replace(/^\\{\\s*|\\}\\s*$/g, \"\"), ruleTokens, rule);\n                context.rules.push(rule);\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n\n    }\n};\nmodule.exports = topLevelTokens;\n\n\n},{\"../../extended\":12,\"./util.js\":47,\"__browserify_process\":64,\"fs\":61}],47:[function(require,module,exports){\nvar process=require(\"__browserify_process\");\"use strict\";\n\nvar path = require(\"path\");\nvar WHITE_SPACE_REG = /[\\s|\\n|\\r|\\t]/,\n    pathSep = path.sep || ( process.platform === 'win32' ? '\\\\' : '/' );\n\nvar TOKEN_INVERTS = {\n    \"{\": \"}\",\n    \"}\": \"{\",\n    \"(\": \")\",\n    \")\": \"(\",\n    \"[\": \"]\"\n};\n\nvar getTokensBetween = exports.getTokensBetween = function (str, start, stop, includeStartEnd) {\n    var depth = 0, ret = [];\n    if (!start) {\n        start = TOKEN_INVERTS[stop];\n        depth = 1;\n    }\n    if (!stop) {\n        stop = TOKEN_INVERTS[start];\n    }\n    str = Object(str);\n    var startPushing = false, token, cursor = 0, found = false;\n    while ((token = str.charAt(cursor++))) {\n        if (token === start) {\n            depth++;\n            if (!startPushing) {\n                startPushing = true;\n                if (includeStartEnd) {\n                    ret.push(token);\n                }\n            } else {\n                ret.push(token);\n            }\n        } else if (token === stop && cursor) {\n            depth--;\n            if (depth === 0) {\n                if (includeStartEnd) {\n                    ret.push(token);\n                }\n                found = true;\n                break;\n            }\n            ret.push(token);\n        } else if (startPushing) {\n            ret.push(token);\n        }\n    }\n    if (!found) {\n        throw new Error(\"Unable to match \" + start + \" in \" + str);\n    }\n    return ret;\n};\n\nexports.getParamList = function (str) {\n    return  getTokensBetween(str, \"(\", \")\", true).join(\"\");\n};\n\nexports.resolve = function (from, to) {\n    if (process.platform === 'win32') {\n        to = to.replace(/\\//g, '\\\\');\n    }\n    if (path.extname(from) !== '') {\n        from = path.dirname(from);\n    }\n    if (to.split(pathSep).length === 1) {\n        return to;\n    }\n    return path.resolve(from, to).replace(/\\\\/g, '/');\n\n};\n\nvar findNextTokenIndex = exports.findNextTokenIndex = function (str, startIndex, endIndex) {\n    startIndex = startIndex || 0;\n    endIndex = endIndex || str.length;\n    var ret = -1, l = str.length;\n    if (!endIndex || endIndex > l) {\n        endIndex = l;\n    }\n    for (; startIndex < endIndex; startIndex++) {\n        var c = str.charAt(startIndex);\n        if (!WHITE_SPACE_REG.test(c)) {\n            ret = startIndex;\n            break;\n        }\n    }\n    return ret;\n};\n\nexports.findNextToken = function (str, startIndex, endIndex) {\n    return str.charAt(findNextTokenIndex(str, startIndex, endIndex));\n};\n},{\"__browserify_process\":64,\"path\":62}],48:[function(require,module,exports){\n\"use strict\";\nvar extd = require(\"./extended\"),\n    isEmpty = extd.isEmpty,\n    merge = extd.merge,\n    forEach = extd.forEach,\n    declare = extd.declare,\n    constraintMatcher = require(\"./constraintMatcher\"),\n    constraint = require(\"./constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    FromConstraint = constraint.FromConstraint;\n\nvar id = 0;\nvar Pattern = declare({});\n\nvar ObjectPattern = Pattern.extend({\n    instance: {\n        constructor: function (type, alias, conditions, store, options) {\n            options = options || {};\n            this.id = id++;\n            this.type = type;\n            this.alias = alias;\n            this.conditions = conditions;\n            this.pattern = options.pattern;\n            var constraints = [new constraint.ObjectConstraint(type)];\n            var constrnts = constraintMatcher.toConstraints(conditions, merge({alias: alias}, options));\n            if (constrnts.length) {\n                constraints = constraints.concat(constrnts);\n            } else {\n                var cnstrnt = new constraint.TrueConstraint();\n                constraints.push(cnstrnt);\n            }\n            if (store && !isEmpty(store)) {\n                var atm = new constraint.HashConstraint(store);\n                constraints.push(atm);\n            }\n\n            forEach(constraints, function (constraint) {\n                constraint.set(\"alias\", alias);\n            });\n            this.constraints = constraints;\n        },\n\n        getSpecificity: function () {\n            var constraints = this.constraints, specificity = 0;\n            for (var i = 0, l = constraints.length; i < l; i++) {\n                if (constraints[i] instanceof EqualityConstraint) {\n                    specificity++;\n                }\n            }\n            return specificity;\n        },\n\n        hasConstraint: function (type) {\n            return extd.some(this.constraints, function (c) {\n                return c instanceof type;\n            });\n        },\n\n        hashCode: function () {\n            return [this.type, this.alias, extd.format(\"%j\", this.conditions)].join(\":\");\n        },\n\n        toString: function () {\n            return extd.format(\"%j\", this.constraints);\n        }\n    }\n}).as(exports, \"ObjectPattern\");\n\nvar FromPattern = ObjectPattern.extend({\n    instance: {\n        constructor: function (type, alias, conditions, store, from, options) {\n            this._super([type, alias, conditions, store, options]);\n            this.from = new FromConstraint(from, options);\n        },\n\n        hasConstraint: function (type) {\n            return extd.some(this.constraints, function (c) {\n                return c instanceof type;\n            });\n        },\n\n        getSpecificity: function () {\n            return this._super(arguments) + 1;\n        },\n\n        hashCode: function () {\n            return [this.type, this.alias, extd.format(\"%j\", this.conditions), this.from.from].join(\":\");\n        },\n\n        toString: function () {\n            return extd.format(\"%j from %s\", this.constraints, this.from.from);\n        }\n    }\n}).as(exports, \"FromPattern\");\n\n\nFromPattern.extend().as(exports, \"FromNotPattern\");\nObjectPattern.extend().as(exports, \"NotPattern\");\nObjectPattern.extend().as(exports, \"ExistsPattern\");\nFromPattern.extend().as(exports, \"FromExistsPattern\");\n\nPattern.extend({\n\n    instance: {\n        constructor: function (left, right) {\n            this.id = id++;\n            this.leftPattern = left;\n            this.rightPattern = right;\n        },\n\n        hashCode: function () {\n            return [this.leftPattern.hashCode(), this.rightPattern.hashCode()].join(\":\");\n        },\n\n        getSpecificity: function () {\n            return this.rightPattern.getSpecificity() + this.leftPattern.getSpecificity();\n        },\n\n        getters: {\n            constraints: function () {\n                return this.leftPattern.constraints.concat(this.rightPattern.constraints);\n            }\n        }\n    }\n\n}).as(exports, \"CompositePattern\");\n\n\nvar InitialFact = declare({\n    instance: {\n        constructor: function () {\n            this.id = id++;\n            this.recency = 0;\n        }\n    }\n}).as(exports, \"InitialFact\");\n\nObjectPattern.extend({\n    instance: {\n        constructor: function () {\n            this._super([InitialFact, \"__i__\", [], {}]);\n        },\n\n        assert: function () {\n            return true;\n        }\n    }\n}).as(exports, \"InitialFactPattern\");\n\n\n\n\n},{\"./constraint\":8,\"./constraintMatcher\":9,\"./extended\":12}],49:[function(require,module,exports){\n\"use strict\";\nvar extd = require(\"./extended\"),\n    isArray = extd.isArray,\n    Promise = extd.Promise,\n    declare = extd.declare,\n    isHash = extd.isHash,\n    isString = extd.isString,\n    format = extd.format,\n    parser = require(\"./parser\"),\n    pattern = require(\"./pattern\"),\n    ObjectPattern = pattern.ObjectPattern,\n    FromPattern = pattern.FromPattern,\n    NotPattern = pattern.NotPattern,\n    ExistsPattern = pattern.ExistsPattern,\n    FromNotPattern = pattern.FromNotPattern,\n    FromExistsPattern = pattern.FromExistsPattern,\n    CompositePattern = pattern.CompositePattern;\n\nvar parseConstraint = function (constraint) {\n    if (typeof constraint === 'function') {\n        // No parsing is needed for constraint functions\n        return constraint;\n    }\n    return parser.parseConstraint(constraint);\n};\n\nvar parseExtra = extd\n    .switcher()\n    .isUndefinedOrNull(function () {\n        return null;\n    })\n    .isLike(/^from +/, function (s) {\n        return {from: s.replace(/^from +/, \"\").replace(/^\\s*|\\s*$/g, \"\")};\n    })\n    .def(function (o) {\n        throw new Error(\"invalid rule constraint option \" + o);\n    })\n    .switcher();\n\nvar normailizeConstraint = extd\n    .switcher()\n    .isLength(1, function (c) {\n        throw new Error(\"invalid rule constraint \" + format(\"%j\", [c]));\n    })\n    .isLength(2, function (c) {\n        c.push(\"true\");\n        return c;\n    })\n    //handle case where c[2] is a hash rather than a constraint string\n    .isLength(3, function (c) {\n        if (isString(c[2]) && /^from +/.test(c[2])) {\n            var extra = c[2];\n            c.splice(2, 0, \"true\");\n            c[3] = null;\n            c[4] = parseExtra(extra);\n        } else if (isHash(c[2])) {\n            c.splice(2, 0, \"true\");\n        }\n        return c;\n    })\n    //handle case where c[3] is a from clause rather than a hash for references\n    .isLength(4, function (c) {\n        if (isString(c[3])) {\n            c.splice(3, 0, null);\n            c[4] = parseExtra(c[4]);\n        }\n        return c;\n    })\n    .def(function (c) {\n        if (c.length === 5) {\n            c[4] = parseExtra(c[4]);\n        }\n        return c;\n    })\n    .switcher();\n\nvar getParamType = function getParamType(type, scope) {\n    scope = scope || {};\n    var getParamTypeSwitch = extd\n        .switcher()\n        .isEq(\"string\", function () {\n            return String;\n        })\n        .isEq(\"date\", function () {\n            return Date;\n        })\n        .isEq(\"array\", function () {\n            return Array;\n        })\n        .isEq(\"boolean\", function () {\n            return Boolean;\n        })\n        .isEq(\"regexp\", function () {\n            return RegExp;\n        })\n        .isEq(\"number\", function () {\n            return Number;\n        })\n        .isEq(\"object\", function () {\n            return Object;\n        })\n        .isEq(\"hash\", function () {\n            return Object;\n        })\n        .def(function (param) {\n            throw new TypeError(\"invalid param type \" + param);\n        })\n        .switcher();\n\n    var _getParamType = extd\n        .switcher()\n        .isString(function (param) {\n            var t = scope[param];\n            if (!t) {\n                return getParamTypeSwitch(param.toLowerCase());\n            } else {\n                return t;\n            }\n        })\n        .isFunction(function (func) {\n            return func;\n        })\n        .deepEqual([], function () {\n            return Array;\n        })\n        .def(function (param) {\n            throw  new Error(\"invalid param type \" + param);\n        })\n        .switcher();\n\n    return _getParamType(type);\n};\n\nvar parsePattern = extd\n    .switcher()\n    .containsAt(\"or\", 0, function (condition) {\n        condition.shift();\n        return extd(condition).map(function (cond) {\n            cond.scope = condition.scope;\n            return parsePattern(cond);\n        }).flatten().value();\n    })\n    .containsAt(\"not\", 0, function (condition) {\n        condition.shift();\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromNotPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new NotPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    })\n    .containsAt(\"exists\", 0, function (condition) {\n        condition.shift();\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromExistsPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new ExistsPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    })\n    .def(function (condition) {\n        if (typeof condition === 'function') {\n            return [condition];\n        }\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new ObjectPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    }).switcher();\n\nvar Rule = declare({\n    instance: {\n        constructor: function (name, options, pattern, cb) {\n            this.name = name;\n            this.pattern = pattern;\n            this.cb = cb;\n            if (options.agendaGroup) {\n                this.agendaGroup = options.agendaGroup;\n                this.autoFocus = extd.isBoolean(options.autoFocus) ? options.autoFocus : false;\n            }\n            this.priority = options.priority || options.salience || 0;\n        },\n\n        fire: function (flow, match) {\n            var ret = new Promise(), cb = this.cb;\n            try {\n                if (cb.length === 3) {\n                    cb.call(flow, match.factHash, flow, ret.resolve);\n                } else {\n                    ret = cb.call(flow, match.factHash, flow);\n                }\n            } catch (e) {\n                ret.errback(e);\n            }\n            return ret;\n        }\n    }\n});\n\nfunction createRule(name, options, conditions, cb) {\n    if (isArray(options)) {\n        cb = conditions;\n        conditions = options;\n    } else {\n        options = options || {};\n    }\n    var isRules = extd.every(conditions, function (cond) {\n        return isArray(cond);\n    });\n    if (isRules && conditions.length === 1) {\n        conditions = conditions[0];\n        isRules = false;\n    }\n    var rules = [];\n    var scope = options.scope || {};\n    conditions.scope = scope;\n    if (isRules) {\n        var _mergePatterns = function (patt, i) {\n            if (!patterns[i]) {\n                patterns[i] = i === 0 ? [] : patterns[i - 1].slice();\n                //remove dup\n                if (i !== 0) {\n                    patterns[i].pop();\n                }\n                patterns[i].push(patt);\n            } else {\n                extd(patterns).forEach(function (p) {\n                    p.push(patt);\n                });\n            }\n\n        };\n        var l = conditions.length, patterns = [], condition;\n        for (var i = 0; i < l; i++) {\n            condition = conditions[i];\n            condition.scope = scope;\n            extd.forEach(parsePattern(condition), _mergePatterns);\n\n        }\n        rules = extd.map(patterns, function (patterns) {\n            var compPat = null;\n            for (var i = 0; i < patterns.length; i++) {\n                if (compPat === null) {\n                    compPat = new CompositePattern(patterns[i++], patterns[i]);\n                } else {\n                    compPat = new CompositePattern(compPat, patterns[i]);\n                }\n            }\n            return new Rule(name, options, compPat, cb);\n        });\n    } else {\n        rules = extd.map(parsePattern(conditions), function (cond) {\n            return new Rule(name, options, cond, cb);\n        });\n    }\n    return rules;\n}\n\nexports.createRule = createRule;\n\n\n\n\n},{\"./extended\":12,\"./parser\":44,\"./pattern\":48}],50:[function(require,module,exports){\n\"use strict\";\nvar declare = require(\"declare.js\"),\n    LinkedList = require(\"./linkedList\"),\n    InitialFact = require(\"./pattern\").InitialFact,\n    id = 0;\n\nvar Fact = declare({\n\n    instance: {\n        constructor: function (obj) {\n            this.object = obj;\n            this.recency = 0;\n            this.id = id++;\n        },\n\n        equals: function (fact) {\n            return fact === this.object;\n        },\n\n        hashCode: function () {\n            return this.id;\n        }\n    }\n\n});\n\ndeclare({\n\n    instance: {\n\n        constructor: function () {\n            this.recency = 0;\n            this.facts = new LinkedList();\n        },\n\n        dispose: function () {\n            this.facts.clear();\n        },\n\n        getFacts: function () {\n            var head = {next: this.facts.head}, ret = [], i = 0, val;\n            while ((head = head.next)) {\n                if (!((val = head.data.object)  instanceof InitialFact)) {\n                    ret[i++] = val;\n                }\n            }\n            return ret;\n        },\n\n        getFactsByType: function (Type) {\n            var head = {next: this.facts.head}, ret = [], i = 0;\n            while ((head = head.next)) {\n                var val = head.data.object;\n                if (!(val  instanceof InitialFact) && (val instanceof Type || val.constructor === Type)) {\n                    ret[i++] = val;\n                }\n            }\n            return ret;\n        },\n\n        getFactHandle: function (o) {\n            var head = {next: this.facts.head}, ret;\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(o)) {\n                    return existingFact;\n                }\n            }\n            if (!ret) {\n                ret = new Fact(o);\n                ret.recency = this.recency++;\n                //this.facts.push(ret);\n            }\n            return ret;\n        },\n\n        modifyFact: function (fact) {\n            var head = {next: this.facts.head};\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(fact)) {\n                    existingFact.recency = this.recency++;\n                    return existingFact;\n                }\n            }\n            //if we made it here we did not find the fact\n            throw new Error(\"the fact to modify does not exist\");\n        },\n\n        assertFact: function (fact) {\n            var ret = new Fact(fact);\n            ret.recency = this.recency++;\n            this.facts.push(ret);\n            return ret;\n        },\n\n        retractFact: function (fact) {\n            var facts = this.facts, head = {next: facts.head};\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(fact)) {\n                    facts.remove(head);\n                    return existingFact;\n                }\n            }\n            //if we made it here we did not find the fact\n            throw new Error(\"the fact to remove does not exist\");\n\n\n        }\n    }\n\n}).as(exports, \"WorkingMemory\");\n\n\n},{\"./linkedList\":16,\"./pattern\":48,\"declare.js\":55}],51:[function(require,module,exports){\n(function () {\n    \"use strict\";\n\n    function defineArgumentsExtended(extended, is) {\n\n        var pSlice = Array.prototype.slice,\n            isArguments = is.isArguments;\n\n        function argsToArray(args, slice) {\n            var i = -1, j = 0, l = args.length, ret = [];\n            slice = slice || 0;\n            i += slice;\n            while (++i < l) {\n                ret[j++] = args[i];\n            }\n            return ret;\n        }\n\n\n        return extended\n            .define(isArguments, {\n                toArray: argsToArray\n            })\n            .expose({\n                argsToArray: argsToArray\n            });\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineArgumentsExtended(require(\"extended\"), require(\"is-extended\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extended\", \"is-extended\"], function (extended, is) {\n            return defineArgumentsExtended(extended, is);\n        });\n    } else {\n        this.argumentsExtended = defineArgumentsExtended(this.extended, this.isExtended);\n    }\n\n}).call(this);\n\n\n},{\"extended\":56,\"is-extended\":66}],52:[function(require,module,exports){\n(function () {\n    \"use strict\";\n    /*global define*/\n\n    function defineArray(extended, is, args) {\n\n        var isString = is.isString,\n            isArray = Array.isArray || is.isArray,\n            isDate = is.isDate,\n            floor = Math.floor,\n            abs = Math.abs,\n            mathMax = Math.max,\n            mathMin = Math.min,\n            arrayProto = Array.prototype,\n            arrayIndexOf = arrayProto.indexOf,\n            arrayForEach = arrayProto.forEach,\n            arrayMap = arrayProto.map,\n            arrayReduce = arrayProto.reduce,\n            arrayReduceRight = arrayProto.reduceRight,\n            arrayFilter = arrayProto.filter,\n            arrayEvery = arrayProto.every,\n            arraySome = arrayProto.some,\n            argsToArray = args.argsToArray;\n\n\n        function cross(num, cros) {\n            return reduceRight(cros, function (a, b) {\n                if (!isArray(b)) {\n                    b = [b];\n                }\n                b.unshift(num);\n                a.unshift(b);\n                return a;\n            }, []);\n        }\n\n        function permute(num, cross, length) {\n            var ret = [];\n            for (var i = 0; i < cross.length; i++) {\n                ret.push([num].concat(rotate(cross, i)).slice(0, length));\n            }\n            return ret;\n        }\n\n\n        function intersection(a, b) {\n            var ret = [], aOne, i = -1, l;\n            l = a.length;\n            while (++i < l) {\n                aOne = a[i];\n                if (indexOf(b, aOne) !== -1) {\n                    ret.push(aOne);\n                }\n            }\n            return ret;\n        }\n\n\n        var _sort = (function () {\n\n            var isAll = function (arr, test) {\n                return every(arr, test);\n            };\n\n            var defaultCmp = function (a, b) {\n                return a - b;\n            };\n\n            var dateSort = function (a, b) {\n                return a.getTime() - b.getTime();\n            };\n\n            return function _sort(arr, property) {\n                var ret = [];\n                if (isArray(arr)) {\n                    ret = arr.slice();\n                    if (property) {\n                        if (typeof property === \"function\") {\n                            ret.sort(property);\n                        } else {\n                            ret.sort(function (a, b) {\n                                var aProp = a[property], bProp = b[property];\n                                if (isString(aProp) && isString(bProp)) {\n                                    return aProp > bProp ? 1 : aProp < bProp ? -1 : 0;\n                                } else if (isDate(aProp) && isDate(bProp)) {\n                                    return aProp.getTime() - bProp.getTime();\n                                } else {\n                                    return aProp - bProp;\n                                }\n                            });\n                        }\n                    } else {\n                        if (isAll(ret, isString)) {\n                            ret.sort();\n                        } else if (isAll(ret, isDate)) {\n                            ret.sort(dateSort);\n                        } else {\n                            ret.sort(defaultCmp);\n                        }\n                    }\n                }\n                return ret;\n            };\n\n        })();\n\n        function indexOf(arr, searchElement, from) {\n            var index = (from || 0) - 1,\n                length = arr.length;\n            while (++index < length) {\n                if (arr[index] === searchElement) {\n                    return index;\n                }\n            }\n            return -1;\n        }\n\n        function lastIndexOf(arr, searchElement, from) {\n            if (!isArray(arr)) {\n                throw new TypeError();\n            }\n\n            var t = Object(arr);\n            var len = t.length >>> 0;\n            if (len === 0) {\n                return -1;\n            }\n\n            var n = len;\n            if (arguments.length > 2) {\n                n = Number(arguments[2]);\n                if (n !== n) {\n                    n = 0;\n                } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n                    n = (n > 0 || -1) * floor(abs(n));\n                }\n            }\n\n            var k = n >= 0 ? mathMin(n, len - 1) : len - abs(n);\n\n            for (; k >= 0; k--) {\n                if (k in t && t[k] === searchElement) {\n                    return k;\n                }\n            }\n            return -1;\n        }\n\n        function filter(arr, iterator, scope) {\n            if (arr && arrayFilter && arrayFilter === arr.filter) {\n                return arr.filter(iterator, scope);\n            }\n            if (!isArray(arr) || typeof iterator !== \"function\") {\n                throw new TypeError();\n            }\n\n            var t = Object(arr);\n            var len = t.length >>> 0;\n            var res = [];\n            for (var i = 0; i < len; i++) {\n                if (i in t) {\n                    var val = t[i]; // in case fun mutates this\n                    if (iterator.call(scope, val, i, t)) {\n                        res.push(val);\n                    }\n                }\n            }\n            return res;\n        }\n\n        function forEach(arr, iterator, scope) {\n            if (!isArray(arr) || typeof iterator !== \"function\") {\n                throw new TypeError();\n            }\n            if (arr && arrayForEach && arrayForEach === arr.forEach) {\n                arr.forEach(iterator, scope);\n                return arr;\n            }\n            for (var i = 0, len = arr.length; i < len; ++i) {\n                iterator.call(scope || arr, arr[i], i, arr);\n            }\n\n            return arr;\n        }\n\n        function every(arr, iterator, scope) {\n            if (arr && arrayEvery && arrayEvery === arr.every) {\n                return arr.every(iterator, scope);\n            }\n            if (!isArray(arr) || typeof iterator !== \"function\") {\n                throw new TypeError();\n            }\n            var t = Object(arr);\n            var len = t.length >>> 0;\n            for (var i = 0; i < len; i++) {\n                if (i in t && !iterator.call(scope, t[i], i, t)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function some(arr, iterator, scope) {\n            if (arr && arraySome && arraySome === arr.some) {\n                return arr.some(iterator, scope);\n            }\n            if (!isArray(arr) || typeof iterator !== \"function\") {\n                throw new TypeError();\n            }\n            var t = Object(arr);\n            var len = t.length >>> 0;\n            for (var i = 0; i < len; i++) {\n                if (i in t && iterator.call(scope, t[i], i, t)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function map(arr, iterator, scope) {\n            if (arr && arrayMap && arrayMap === arr.map) {\n                return arr.map(iterator, scope);\n            }\n            if (!isArray(arr) || typeof iterator !== \"function\") {\n                throw new TypeError();\n            }\n\n            var t = Object(arr);\n            var len = t.length >>> 0;\n            var res = [];\n            for (var i = 0; i < len; i++) {\n                if (i in t) {\n                    res.push(iterator.call(scope, t[i], i, t));\n                }\n            }\n            return res;\n        }\n\n        function reduce(arr, accumulator, curr) {\n            var initial = arguments.length > 2;\n            if (arr && arrayReduce && arrayReduce === arr.reduce) {\n                return initial ? arr.reduce(accumulator, curr) : arr.reduce(accumulator);\n            }\n            if (!isArray(arr) || typeof accumulator !== \"function\") {\n                throw new TypeError();\n            }\n            var i = 0, l = arr.length >> 0;\n            if (arguments.length < 3) {\n                if (l === 0) {\n                    throw new TypeError(\"Array length is 0 and no second argument\");\n                }\n                curr = arr[0];\n                i = 1; // start accumulating at the second element\n            } else {\n                curr = arguments[2];\n            }\n            while (i < l) {\n                if (i in arr) {\n                    curr = accumulator.call(undefined, curr, arr[i], i, arr);\n                }\n                ++i;\n            }\n            return curr;\n        }\n\n        function reduceRight(arr, accumulator, curr) {\n            var initial = arguments.length > 2;\n            if (arr && arrayReduceRight && arrayReduceRight === arr.reduceRight) {\n                return initial ? arr.reduceRight(accumulator, curr) : arr.reduceRight(accumulator);\n            }\n            if (!isArray(arr) || typeof accumulator !== \"function\") {\n                throw new TypeError();\n            }\n\n            var t = Object(arr);\n            var len = t.length >>> 0;\n\n            // no value to return if no initial value, empty array\n            if (len === 0 && arguments.length === 2) {\n                throw new TypeError();\n            }\n\n            var k = len - 1;\n            if (arguments.length >= 3) {\n                curr = arguments[2];\n            } else {\n                do {\n                    if (k in arr) {\n                        curr = arr[k--];\n                        break;\n                    }\n                }\n                while (true);\n            }\n            while (k >= 0) {\n                if (k in t) {\n                    curr = accumulator.call(undefined, curr, t[k], k, t);\n                }\n                k--;\n            }\n            return curr;\n        }\n\n\n        function toArray(o) {\n            var ret = [];\n            if (o !== null) {\n                var args = argsToArray(arguments);\n                if (args.length === 1) {\n                    if (isArray(o)) {\n                        ret = o;\n                    } else if (is.isHash(o)) {\n                        for (var i in o) {\n                            if (o.hasOwnProperty(i)) {\n                                ret.push([i, o[i]]);\n                            }\n                        }\n                    } else {\n                        ret.push(o);\n                    }\n                } else {\n                    forEach(args, function (a) {\n                        ret = ret.concat(toArray(a));\n                    });\n                }\n            }\n            return ret;\n        }\n\n        function sum(array) {\n            array = array || [];\n            if (array.length) {\n                return reduce(array, function (a, b) {\n                    return a + b;\n                });\n            } else {\n                return 0;\n            }\n        }\n\n        function avg(arr) {\n            arr = arr || [];\n            if (arr.length) {\n                var total = sum(arr);\n                if (is.isNumber(total)) {\n                    return  total / arr.length;\n                } else {\n                    throw new Error(\"Cannot average an array of non numbers.\");\n                }\n            } else {\n                return 0;\n            }\n        }\n\n        function sort(arr, cmp) {\n            return _sort(arr, cmp);\n        }\n\n        function min(arr, cmp) {\n            return _sort(arr, cmp)[0];\n        }\n\n        function max(arr, cmp) {\n            return _sort(arr, cmp)[arr.length - 1];\n        }\n\n        function difference(arr1) {\n            var ret = arr1, args = flatten(argsToArray(arguments, 1));\n            if (isArray(arr1)) {\n                ret = filter(arr1, function (a) {\n                    return indexOf(args, a) === -1;\n                });\n            }\n            return ret;\n        }\n\n        function removeDuplicates(arr) {\n            var ret = [], i = -1, l, retLength = 0;\n            if (arr) {\n                l = arr.length;\n                while (++i < l) {\n                    var item = arr[i];\n                    if (indexOf(ret, item) === -1) {\n                        ret[retLength++] = item;\n                    }\n                }\n            }\n            return ret;\n        }\n\n\n        function unique(arr) {\n            return removeDuplicates(arr);\n        }\n\n\n        function rotate(arr, numberOfTimes) {\n            var ret = arr.slice();\n            if (typeof numberOfTimes !== \"number\") {\n                numberOfTimes = 1;\n            }\n            if (numberOfTimes && isArray(arr)) {\n                if (numberOfTimes > 0) {\n                    ret.push(ret.shift());\n                    numberOfTimes--;\n                } else {\n                    ret.unshift(ret.pop());\n                    numberOfTimes++;\n                }\n                return rotate(ret, numberOfTimes);\n            } else {\n                return ret;\n            }\n        }\n\n        function permutations(arr, length) {\n            var ret = [];\n            if (isArray(arr)) {\n                var copy = arr.slice(0);\n                if (typeof length !== \"number\") {\n                    length = arr.length;\n                }\n                if (!length) {\n                    ret = [\n                        []\n                    ];\n                } else if (length <= arr.length) {\n                    ret = reduce(arr, function (a, b, i) {\n                        var ret;\n                        if (length > 1) {\n                            ret = permute(b, rotate(copy, i).slice(1), length);\n                        } else {\n                            ret = [\n                                [b]\n                            ];\n                        }\n                        return a.concat(ret);\n                    }, []);\n                }\n            }\n            return ret;\n        }\n\n        function zip() {\n            var ret = [];\n            var arrs = argsToArray(arguments);\n            if (arrs.length > 1) {\n                var arr1 = arrs.shift();\n                if (isArray(arr1)) {\n                    ret = reduce(arr1, function (a, b, i) {\n                        var curr = [b];\n                        for (var j = 0; j < arrs.length; j++) {\n                            var currArr = arrs[j];\n                            if (isArray(currArr) && !is.isUndefined(currArr[i])) {\n                                curr.push(currArr[i]);\n                            } else {\n                                curr.push(null);\n                            }\n                        }\n                        a.push(curr);\n                        return a;\n                    }, []);\n                }\n            }\n            return ret;\n        }\n\n        function transpose(arr) {\n            var ret = [];\n            if (isArray(arr) && arr.length) {\n                var last;\n                forEach(arr, function (a) {\n                    if (isArray(a) && (!last || a.length === last.length)) {\n                        forEach(a, function (b, i) {\n                            if (!ret[i]) {\n                                ret[i] = [];\n                            }\n                            ret[i].push(b);\n                        });\n                        last = a;\n                    }\n                });\n            }\n            return ret;\n        }\n\n        function valuesAt(arr, indexes) {\n            var ret = [];\n            indexes = argsToArray(arguments);\n            arr = indexes.shift();\n            if (isArray(arr) && indexes.length) {\n                for (var i = 0, l = indexes.length; i < l; i++) {\n                    ret.push(arr[indexes[i]] || null);\n                }\n            }\n            return ret;\n        }\n\n        function union() {\n            var ret = [];\n            var arrs = argsToArray(arguments);\n            if (arrs.length > 1) {\n                for (var i = 0, l = arrs.length; i < l; i++) {\n                    ret = ret.concat(arrs[i]);\n                }\n                ret = removeDuplicates(ret);\n            }\n            return ret;\n        }\n\n        function intersect() {\n            var collect = [], sets, i = -1 , l;\n            if (arguments.length > 1) {\n                //assume we are intersections all the lists in the array\n                sets = argsToArray(arguments);\n            } else {\n                sets = arguments[0];\n            }\n            if (isArray(sets)) {\n                collect = sets[0];\n                i = 0;\n                l = sets.length;\n                while (++i < l) {\n                    collect = intersection(collect, sets[i]);\n                }\n            }\n            return removeDuplicates(collect);\n        }\n\n        function powerSet(arr) {\n            var ret = [];\n            if (isArray(arr) && arr.length) {\n                ret = reduce(arr, function (a, b) {\n                    var ret = map(a, function (c) {\n                        return c.concat(b);\n                    });\n                    return a.concat(ret);\n                }, [\n                    []\n                ]);\n            }\n            return ret;\n        }\n\n        function cartesian(a, b) {\n            var ret = [];\n            if (isArray(a) && isArray(b) && a.length && b.length) {\n                ret = cross(a[0], b).concat(cartesian(a.slice(1), b));\n            }\n            return ret;\n        }\n\n        function compact(arr) {\n            var ret = [];\n            if (isArray(arr) && arr.length) {\n                ret = filter(arr, function (item) {\n                    return !is.isUndefinedOrNull(item);\n                });\n            }\n            return ret;\n        }\n\n        function multiply(arr, times) {\n            times = is.isNumber(times) ? times : 1;\n            if (!times) {\n                //make sure times is greater than zero if it is zero then dont multiply it\n                times = 1;\n            }\n            arr = toArray(arr || []);\n            var ret = [], i = 0;\n            while (++i <= times) {\n                ret = ret.concat(arr);\n            }\n            return ret;\n        }\n\n        function flatten(arr) {\n            var set;\n            var args = argsToArray(arguments);\n            if (args.length > 1) {\n                //assume we are intersections all the lists in the array\n                set = args;\n            } else {\n                set = toArray(arr);\n            }\n            return reduce(set, function (a, b) {\n                return a.concat(b);\n            }, []);\n        }\n\n        function pluck(arr, prop) {\n            prop = prop.split(\".\");\n            var result = arr.slice(0);\n            forEach(prop, function (prop) {\n                var exec = prop.match(/(\\w+)\\(\\)$/);\n                result = map(result, function (item) {\n                    return exec ? item[exec[1]]() : item[prop];\n                });\n            });\n            return result;\n        }\n\n        function invoke(arr, func, args) {\n            args = argsToArray(arguments, 2);\n            return map(arr, function (item) {\n                var exec = isString(func) ? item[func] : func;\n                return exec.apply(item, args);\n            });\n        }\n\n\n        var array = {\n            toArray: toArray,\n            sum: sum,\n            avg: avg,\n            sort: sort,\n            min: min,\n            max: max,\n            difference: difference,\n            removeDuplicates: removeDuplicates,\n            unique: unique,\n            rotate: rotate,\n            permutations: permutations,\n            zip: zip,\n            transpose: transpose,\n            valuesAt: valuesAt,\n            union: union,\n            intersect: intersect,\n            powerSet: powerSet,\n            cartesian: cartesian,\n            compact: compact,\n            multiply: multiply,\n            flatten: flatten,\n            pluck: pluck,\n            invoke: invoke,\n            forEach: forEach,\n            map: map,\n            filter: filter,\n            reduce: reduce,\n            reduceRight: reduceRight,\n            some: some,\n            every: every,\n            indexOf: indexOf,\n            lastIndexOf: lastIndexOf\n        };\n\n        return extended.define(isArray, array).expose(array);\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineArray(require(\"extended\"), require(\"is-extended\"), require(\"arguments-extended\"));\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extended\", \"is-extended\", \"arguments-extended\"], function (extended, is, args) {\n            return defineArray(extended, is, args);\n        });\n    } else {\n        this.arrayExtended = defineArray(this.extended, this.isExtended, this.argumentsExtended);\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"arguments-extended\":51,\"extended\":56,\"is-extended\":66}],53:[function(require,module,exports){\n(function () {\n    \"use strict\";\n\n    function defineDate(extended, is, array) {\n\n        function _pad(string, length, ch, end) {\n            string = \"\" + string; //check for numbers\n            ch = ch || \" \";\n            var strLen = string.length;\n            while (strLen < length) {\n                if (end) {\n                    string += ch;\n                } else {\n                    string = ch + string;\n                }\n                strLen++;\n            }\n            return string;\n        }\n\n        function _truncate(string, length, end) {\n            var ret = string;\n            if (is.isString(ret)) {\n                if (string.length > length) {\n                    if (end) {\n                        var l = string.length;\n                        ret = string.substring(l - length, l);\n                    } else {\n                        ret = string.substring(0, length);\n                    }\n                }\n            } else {\n                ret = _truncate(\"\" + ret, length);\n            }\n            return ret;\n        }\n\n        function every(arr, iterator, scope) {\n            if (!is.isArray(arr) || typeof iterator !== \"function\") {\n                throw new TypeError();\n            }\n            var t = Object(arr);\n            var len = t.length >>> 0;\n            for (var i = 0; i < len; i++) {\n                if (i in t && !iterator.call(scope, t[i], i, t)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n\n        var transforms = (function () {\n                var floor = Math.floor, round = Math.round;\n\n                var addMap = {\n                    day: function addDay(date, amount) {\n                        return [amount, \"Date\", false];\n                    },\n                    weekday: function addWeekday(date, amount) {\n                        // Divide the increment time span into weekspans plus leftover days\n                        // e.g., 8 days is one 5-day weekspan / and two leftover days\n                        // Can't have zero leftover days, so numbers divisible by 5 get\n                        // a days value of 5, and the remaining days make up the number of weeks\n                        var days, weeks, mod = amount % 5, strt = date.getDay(), adj = 0;\n                        if (!mod) {\n                            days = (amount > 0) ? 5 : -5;\n                            weeks = (amount > 0) ? ((amount - 5) / 5) : ((amount + 5) / 5);\n                        } else {\n                            days = mod;\n                            weeks = parseInt(amount / 5, 10);\n                        }\n                        if (strt === 6 && amount > 0) {\n                            adj = 1;\n                        } else if (strt === 0 && amount < 0) {\n                            // Orig date is Sun / negative increment\n                            // Jump back over Sat\n                            adj = -1;\n                        }\n                        // Get weekday val for the new date\n                        var trgt = strt + days;\n                        // New date is on Sat or Sun\n                        if (trgt === 0 || trgt === 6) {\n                            adj = (amount > 0) ? 2 : -2;\n                        }\n                        // Increment by number of weeks plus leftover days plus\n                        // weekend adjustments\n                        return [(7 * weeks) + days + adj, \"Date\", false];\n                    },\n                    year: function addYear(date, amount) {\n                        return [amount, \"FullYear\", true];\n                    },\n                    week: function addWeek(date, amount) {\n                        return [amount * 7, \"Date\", false];\n                    },\n                    quarter: function addYear(date, amount) {\n                        return [amount * 3, \"Month\", true];\n                    },\n                    month: function addYear(date, amount) {\n                        return [amount, \"Month\", true];\n                    }\n                };\n\n                function addTransform(interval, date, amount) {\n                    interval = interval.replace(/s$/, \"\");\n                    if (addMap.hasOwnProperty(interval)) {\n                        return addMap[interval](date, amount);\n                    }\n                    return [amount, \"UTC\" + interval.charAt(0).toUpperCase() + interval.substring(1) + \"s\", false];\n                }\n\n\n                var differenceMap = {\n                    \"quarter\": function quarterDifference(date1, date2, utc) {\n                        var yearDiff = date2.getFullYear() - date1.getFullYear();\n                        var m1 = date1[utc ? \"getUTCMonth\" : \"getMonth\"]();\n                        var m2 = date2[utc ? \"getUTCMonth\" : \"getMonth\"]();\n                        // Figure out which quarter the months are in\n                        var q1 = floor(m1 / 3) + 1;\n                        var q2 = floor(m2 / 3) + 1;\n                        // Add quarters for any year difference between the dates\n                        q2 += (yearDiff * 4);\n                        return q2 - q1;\n                    },\n\n                    \"weekday\": function weekdayDifference(date1, date2, utc) {\n                        var days = differenceTransform(\"day\", date1, date2, utc), weeks;\n                        var mod = days % 7;\n                        // Even number of weeks\n                        if (mod === 0) {\n                            days = differenceTransform(\"week\", date1, date2, utc) * 5;\n                        } else {\n                            // Weeks plus spare change (< 7 days)\n                            var adj = 0, aDay = date1[utc ? \"getUTCDay\" : \"getDay\"](), bDay = date2[utc ? \"getUTCDay\" : \"getDay\"]();\n                            weeks = parseInt(days / 7, 10);\n                            // Mark the date advanced by the number of\n                            // round weeks (may be zero)\n                            var dtMark = new Date(+date1);\n                            dtMark.setDate(dtMark[utc ? \"getUTCDate\" : \"getDate\"]() + (weeks * 7));\n                            var dayMark = dtMark[utc ? \"getUTCDay\" : \"getDay\"]();\n\n                            // Spare change days -- 6 or less\n                            if (days > 0) {\n                                if (aDay === 6 || bDay === 6) {\n                                    adj = -1;\n                                } else if (aDay === 0) {\n                                    adj = 0;\n                                } else if (bDay === 0 || (dayMark + mod) > 5) {\n                                    adj = -2;\n                                }\n                            } else if (days < 0) {\n                                if (aDay === 6) {\n                                    adj = 0;\n                                } else if (aDay === 0 || bDay === 0) {\n                                    adj = 1;\n                                } else if (bDay === 6 || (dayMark + mod) < 0) {\n                                    adj = 2;\n                                }\n                            }\n                            days += adj;\n                            days -= (weeks * 2);\n                        }\n                        return days;\n                    },\n                    year: function (date1, date2) {\n                        return date2.getFullYear() - date1.getFullYear();\n                    },\n                    month: function (date1, date2, utc) {\n                        var m1 = date1[utc ? \"getUTCMonth\" : \"getMonth\"]();\n                        var m2 = date2[utc ? \"getUTCMonth\" : \"getMonth\"]();\n                        return (m2 - m1) + ((date2.getFullYear() - date1.getFullYear()) * 12);\n                    },\n                    week: function (date1, date2, utc) {\n                        return round(differenceTransform(\"day\", date1, date2, utc) / 7);\n                    },\n                    day: function (date1, date2) {\n                        return 1.1574074074074074e-8 * (date2.getTime() - date1.getTime());\n                    },\n                    hour: function (date1, date2) {\n                        return 2.7777777777777776e-7 * (date2.getTime() - date1.getTime());\n                    },\n                    minute: function (date1, date2) {\n                        return 0.000016666666666666667 * (date2.getTime() - date1.getTime());\n                    },\n                    second: function (date1, date2) {\n                        return 0.001 * (date2.getTime() - date1.getTime());\n                    },\n                    millisecond: function (date1, date2) {\n                        return date2.getTime() - date1.getTime();\n                    }\n                };\n\n\n                function differenceTransform(interval, date1, date2, utc) {\n                    interval = interval.replace(/s$/, \"\");\n                    return round(differenceMap[interval](date1, date2, utc));\n                }\n\n\n                return {\n                    addTransform: addTransform,\n                    differenceTransform: differenceTransform\n                };\n            }()),\n            addTransform = transforms.addTransform,\n            differenceTransform = transforms.differenceTransform;\n\n\n        /**\n         * @ignore\n         * Based on DOJO Date Implementation\n         *\n         * Dojo is available under *either* the terms of the modified BSD license *or* the\n         * Academic Free License version 2.1. As a recipient of Dojo, you may choose which\n         * license to receive this code under (except as noted in per-module LICENSE\n         * files). Some modules may not be the copyright of the Dojo Foundation. These\n         * modules contain explicit declarations of copyright in both the LICENSE files in\n         * the directories in which they reside and in the code itself. No external\n         * contributions are allowed under licenses which are fundamentally incompatible\n         * with the AFL or BSD licenses that Dojo is distributed under.\n         *\n         */\n\n        var floor = Math.floor, round = Math.round, min = Math.min, pow = Math.pow, ceil = Math.ceil, abs = Math.abs;\n        var monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n        var monthAbbr = [\"Jan.\", \"Feb.\", \"Mar.\", \"Apr.\", \"May.\", \"Jun.\", \"Jul.\", \"Aug.\", \"Sep.\", \"Oct.\", \"Nov.\", \"Dec.\"];\n        var dayNames = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n        var dayAbbr = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n        var eraNames = [\"Before Christ\", \"Anno Domini\"];\n        var eraAbbr = [\"BC\", \"AD\"];\n\n\n        function getDayOfYear(/*Date*/dateObject, utc) {\n            // summary: gets the day of the year as represented by dateObject\n            return date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject, null, utc) + 1; // Number\n        }\n\n        function getWeekOfYear(/*Date*/dateObject, /*Number*/firstDayOfWeek, utc) {\n            firstDayOfWeek = firstDayOfWeek || 0;\n            var fullYear = dateObject[utc ? \"getUTCFullYear\" : \"getFullYear\"]();\n            var firstDayOfYear = new Date(fullYear, 0, 1).getDay(),\n                adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,\n                week = floor((getDayOfYear(dateObject) + adj - 1) / 7);\n\n            // if year starts on the specified day, start counting weeks at 1\n            if (firstDayOfYear === firstDayOfWeek) {\n                week++;\n            }\n\n            return week; // Number\n        }\n\n        function getTimezoneName(/*Date*/dateObject) {\n            var str = dateObject.toString();\n            var tz = '';\n            var pos = str.indexOf('(');\n            if (pos > -1) {\n                tz = str.substring(++pos, str.indexOf(')'));\n            }\n            return tz; // String\n        }\n\n\n        function buildDateEXP(pattern, tokens) {\n            return pattern.replace(/([a-z])\\1*/ig,function (match) {\n                // Build a simple regexp.  Avoid captures, which would ruin the tokens list\n                var s,\n                    c = match.charAt(0),\n                    l = match.length,\n                    p2 = '0?',\n                    p3 = '0{0,2}';\n                if (c === 'y') {\n                    s = '\\\\d{2,4}';\n                } else if (c === \"M\") {\n                    s = (l > 2) ? '\\\\S+?' : '1[0-2]|' + p2 + '[1-9]';\n                } else if (c === \"D\") {\n                    s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|' + p3 + '[1-9][0-9]|' + p2 + '[1-9]';\n                } else if (c === \"d\") {\n                    s = '3[01]|[12]\\\\d|' + p2 + '[1-9]';\n                } else if (c === \"w\") {\n                    s = '[1-4][0-9]|5[0-3]|' + p2 + '[1-9]';\n                } else if (c === \"E\") {\n                    s = '\\\\S+';\n                } else if (c === \"h\") {\n                    s = '1[0-2]|' + p2 + '[1-9]';\n                } else if (c === \"K\") {\n                    s = '1[01]|' + p2 + '\\\\d';\n                } else if (c === \"H\") {\n                    s = '1\\\\d|2[0-3]|' + p2 + '\\\\d';\n                } else if (c === \"k\") {\n                    s = '1\\\\d|2[0-4]|' + p2 + '[1-9]';\n                } else if (c === \"m\" || c === \"s\") {\n                    s = '[0-5]\\\\d';\n                } else if (c === \"S\") {\n                    s = '\\\\d{' + l + '}';\n                } else if (c === \"a\") {\n                    var am = 'AM', pm = 'PM';\n                    s = am + '|' + pm;\n                    if (am !== am.toLowerCase()) {\n                        s += '|' + am.toLowerCase();\n                    }\n                    if (pm !== pm.toLowerCase()) {\n                        s += '|' + pm.toLowerCase();\n                    }\n                    s = s.replace(/\\./g, \"\\\\.\");\n                } else if (c === 'v' || c === 'z' || c === 'Z' || c === 'G' || c === 'q' || c === 'Q') {\n                    s = \".*\";\n                } else {\n                    s = c === \" \" ? \"\\\\s*\" : c + \"*\";\n                }\n                if (tokens) {\n                    tokens.push(match);\n                }\n\n                return \"(\" + s + \")\"; // add capture\n            }).replace(/[\\xa0 ]/g, \"[\\\\s\\\\xa0]\"); // normalize whitespace.  Need explicit handling of \\xa0 for IE.\n        }\n\n\n        /**\n         * @namespace Utilities for Dates\n         */\n        var date = {\n\n            /**@lends date*/\n\n            /**\n             * Returns the number of days in the month of a date\n             *\n             * @example\n             *\n             *  dateExtender.getDaysInMonth(new Date(2006, 1, 1)); //28\n             *  dateExtender.getDaysInMonth(new Date(2004, 1, 1)); //29\n             *  dateExtender.getDaysInMonth(new Date(2006, 2, 1)); //31\n             *  dateExtender.getDaysInMonth(new Date(2006, 3, 1)); //30\n             *  dateExtender.getDaysInMonth(new Date(2006, 4, 1)); //31\n             *  dateExtender.getDaysInMonth(new Date(2006, 5, 1)); //30\n             *  dateExtender.getDaysInMonth(new Date(2006, 6, 1)); //31\n             * @param {Date} dateObject the date containing the month\n             * @return {Number} the number of days in the month\n             */\n            getDaysInMonth: function (/*Date*/dateObject) {\n                //\tsummary:\n                //\t\tReturns the number of days in the month used by dateObject\n                var month = dateObject.getMonth();\n                var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n                if (month === 1 && date.isLeapYear(dateObject)) {\n                    return 29;\n                } // Number\n                return days[month]; // Number\n            },\n\n            /**\n             * Determines if a date is a leap year\n             *\n             * @example\n             *\n             *  dateExtender.isLeapYear(new Date(1600, 0, 1)); //true\n             *  dateExtender.isLeapYear(new Date(2004, 0, 1)); //true\n             *  dateExtender.isLeapYear(new Date(2000, 0, 1)); //true\n             *  dateExtender.isLeapYear(new Date(2006, 0, 1)); //false\n             *  dateExtender.isLeapYear(new Date(1900, 0, 1)); //false\n             *  dateExtender.isLeapYear(new Date(1800, 0, 1)); //false\n             *  dateExtender.isLeapYear(new Date(1700, 0, 1)); //false\n             *\n             * @param {Date} dateObject\n             * @returns {Boolean} true if it is a leap year false otherwise\n             */\n            isLeapYear: function (/*Date*/dateObject, utc) {\n                var year = dateObject[utc ? \"getUTCFullYear\" : \"getFullYear\"]();\n                return (year % 400 === 0) || (year % 4 === 0 && year % 100 !== 0);\n\n            },\n\n            /**\n             * Determines if a date is on a weekend\n             *\n             * @example\n             *\n             * var thursday = new Date(2006, 8, 21);\n             * var saturday = new Date(2006, 8, 23);\n             * var sunday = new Date(2006, 8, 24);\n             * var monday = new Date(2006, 8, 25);\n             * dateExtender.isWeekend(thursday)); //false\n             * dateExtender.isWeekend(saturday); //true\n             * dateExtender.isWeekend(sunday); //true\n             * dateExtender.isWeekend(monday)); //false\n             *\n             * @param {Date} dateObject the date to test\n             *\n             * @returns {Boolean} true if the date is a weekend\n             */\n            isWeekend: function (/*Date?*/dateObject, utc) {\n                // summary:\n                //\tDetermines if the date falls on a weekend, according to local custom.\n                var day = (dateObject || new Date())[utc ? \"getUTCDay\" : \"getDay\"]();\n                return day === 0 || day === 6;\n            },\n\n            /**\n             * Get the timezone of a date\n             *\n             * @example\n             *  //just setting the strLocal to simulate the toString() of a date\n             *  dt.str = 'Sun Sep 17 2006 22:25:51 GMT-0500 (CDT)';\n             *  //just setting the strLocal to simulate the locale\n             *  dt.strLocale = 'Sun 17 Sep 2006 10:25:51 PM CDT';\n             *  dateExtender.getTimezoneName(dt); //'CDT'\n             *  dt.str = 'Sun Sep 17 2006 22:57:18 GMT-0500 (CDT)';\n             *  dt.strLocale = 'Sun Sep 17 22:57:18 2006';\n             *  dateExtender.getTimezoneName(dt); //'CDT'\n             * @param dateObject the date to get the timezone from\n             *\n             * @returns {String} the timezone of the date\n             */\n            getTimezoneName: getTimezoneName,\n\n            /**\n             * Compares two dates\n             *\n             * @example\n             *\n             * var d1 = new Date();\n             * d1.setHours(0);\n             * dateExtender.compare(d1, d1); // 0\n             *\n             *  var d1 = new Date();\n             *  d1.setHours(0);\n             *  var d2 = new Date();\n             *  d2.setFullYear(2005);\n             *  d2.setHours(12);\n             *  dateExtender.compare(d1, d2, \"date\"); // 1\n             *  dateExtender.compare(d1, d2, \"datetime\"); // 1\n             *\n             *  var d1 = new Date();\n             *  d1.setHours(0);\n             *  var d2 = new Date();\n             *  d2.setFullYear(2005);\n             *  d2.setHours(12);\n             *  dateExtender.compare(d2, d1, \"date\"); // -1\n             *  dateExtender.compare(d1, d2, \"time\"); //-1\n             *\n             * @param {Date|String} date1 the date to comapare\n             * @param {Date|String} [date2=new Date()] the date to compare date1 againse\n             * @param {\"date\"|\"time\"|\"datetime\"} portion compares the portion specified\n             *\n             * @returns -1 if date1 is < date2 0 if date1 === date2  1 if date1 > date2\n             */\n            compare: function (/*Date*/date1, /*Date*/date2, /*String*/portion) {\n                date1 = new Date(+date1);\n                date2 = new Date(+(date2 || new Date()));\n\n                if (portion === \"date\") {\n                    // Ignore times and compare dates.\n                    date1.setHours(0, 0, 0, 0);\n                    date2.setHours(0, 0, 0, 0);\n                } else if (portion === \"time\") {\n                    // Ignore dates and compare times.\n                    date1.setFullYear(0, 0, 0);\n                    date2.setFullYear(0, 0, 0);\n                }\n                return date1 > date2 ? 1 : date1 < date2 ? -1 : 0;\n            },\n\n\n            /**\n             * Adds a specified interval and amount to a date\n             *\n             * @example\n             *  var dtA = new Date(2005, 11, 27);\n             *  dateExtender.add(dtA, \"year\", 1); //new Date(2006, 11, 27);\n             *  dateExtender.add(dtA, \"years\", 1); //new Date(2006, 11, 27);\n             *\n             *  dtA = new Date(2000, 0, 1);\n             *  dateExtender.add(dtA, \"quarter\", 1); //new Date(2000, 3, 1);\n             *  dateExtender.add(dtA, \"quarters\", 1); //new Date(2000, 3, 1);\n             *\n             *  dtA = new Date(2000, 0, 1);\n             *  dateExtender.add(dtA, \"month\", 1); //new Date(2000, 1, 1);\n             *  dateExtender.add(dtA, \"months\", 1); //new Date(2000, 1, 1);\n             *\n             *  dtA = new Date(2000, 0, 31);\n             *  dateExtender.add(dtA, \"month\", 1); //new Date(2000, 1, 29);\n             *  dateExtender.add(dtA, \"months\", 1); //new Date(2000, 1, 29);\n             *\n             *  dtA = new Date(2000, 0, 1);\n             *  dateExtender.add(dtA, \"week\", 1); //new Date(2000, 0, 8);\n             *  dateExtender.add(dtA, \"weeks\", 1); //new Date(2000, 0, 8);\n             *\n             *  dtA = new Date(2000, 0, 1);\n             *  dateExtender.add(dtA, \"day\", 1); //new Date(2000, 0, 2);\n             *\n             *  dtA = new Date(2000, 0, 1);\n             *  dateExtender.add(dtA, \"weekday\", 1); //new Date(2000, 0, 3);\n             *\n             *  dtA = new Date(2000, 0, 1, 11);\n             *  dateExtender.add(dtA, \"hour\", 1); //new Date(2000, 0, 1, 12);\n             *\n             *  dtA = new Date(2000, 11, 31, 23, 59);\n             *  dateExtender.add(dtA, \"minute\", 1); //new Date(2001, 0, 1, 0, 0);\n             *\n             *  dtA = new Date(2000, 11, 31, 23, 59, 59);\n             *  dateExtender.add(dtA, \"second\", 1); //new Date(2001, 0, 1, 0, 0, 0);\n             *\n             *  dtA = new Date(2000, 11, 31, 23, 59, 59, 999);\n             *  dateExtender.add(dtA, \"millisecond\", 1); //new Date(2001, 0, 1, 0, 0, 0, 0);\n             *\n             * @param {Date} date\n             * @param {String} interval the interval to add\n             *  <ul>\n             *      <li>day | days</li>\n             *      <li>weekday | weekdays</li>\n             *      <li>year | years</li>\n             *      <li>week | weeks</li>\n             *      <li>quarter | quarters</li>\n             *      <li>months | months</li>\n             *      <li>hour | hours</li>\n             *      <li>minute | minutes</li>\n             *      <li>second | seconds</li>\n             *      <li>millisecond | milliseconds</li>\n             *  </ul>\n             * @param {Number} [amount=0] the amount to add\n             */\n            add: function (/*Date*/date, /*String*/interval, /*int*/amount) {\n                var res = addTransform(interval, date, amount || 0);\n                amount = res[0];\n                var property = res[1];\n                var sum = new Date(+date);\n                var fixOvershoot = res[2];\n                if (property) {\n                    sum[\"set\" + property](sum[\"get\" + property]() + amount);\n                }\n\n                if (fixOvershoot && (sum.getDate() < date.getDate())) {\n                    sum.setDate(0);\n                }\n\n                return sum; // Date\n            },\n\n            /**\n             * Finds the difference between two dates based on the specified interval\n             *\n             * @example\n             *\n             * var dtA, dtB;\n             *\n             * dtA = new Date(2005, 11, 27);\n             * dtB = new Date(2006, 11, 27);\n             * dateExtender.difference(dtA, dtB, \"year\"); //1\n             *\n             * dtA = new Date(2000, 1, 29);\n             * dtB = new Date(2001, 2, 1);\n             * dateExtender.difference(dtA, dtB, \"quarter\"); //4\n             * dateExtender.difference(dtA, dtB, \"month\"); //13\n             *\n             * dtA = new Date(2000, 1, 1);\n             * dtB = new Date(2000, 1, 8);\n             * dateExtender.difference(dtA, dtB, \"week\"); //1\n             *\n             * dtA = new Date(2000, 1, 29);\n             * dtB = new Date(2000, 2, 1);\n             * dateExtender.difference(dtA, dtB, \"day\"); //1\n             *\n             * dtA = new Date(2006, 7, 3);\n             * dtB = new Date(2006, 7, 11);\n             * dateExtender.difference(dtA, dtB, \"weekday\"); //6\n             *\n             * dtA = new Date(2000, 11, 31, 23);\n             * dtB = new Date(2001, 0, 1, 0);\n             * dateExtender.difference(dtA, dtB, \"hour\"); //1\n             *\n             * dtA = new Date(2000, 11, 31, 23, 59);\n             * dtB = new Date(2001, 0, 1, 0, 0);\n             * dateExtender.difference(dtA, dtB, \"minute\"); //1\n             *\n             * dtA = new Date(2000, 11, 31, 23, 59, 59);\n             * dtB = new Date(2001, 0, 1, 0, 0, 0);\n             * dateExtender.difference(dtA, dtB, \"second\"); //1\n             *\n             * dtA = new Date(2000, 11, 31, 23, 59, 59, 999);\n             * dtB = new Date(2001, 0, 1, 0, 0, 0, 0);\n             * dateExtender.difference(dtA, dtB, \"millisecond\"); //1\n             *\n             *\n             * @param {Date} date1\n             * @param {Date} [date2 = new Date()]\n             * @param {String} [interval = \"day\"] the intercal to find the difference of.\n             *   <ul>\n             *      <li>day | days</li>\n             *      <li>weekday | weekdays</li>\n             *      <li>year | years</li>\n             *      <li>week | weeks</li>\n             *      <li>quarter | quarters</li>\n             *      <li>months | months</li>\n             *      <li>hour | hours</li>\n             *      <li>minute | minutes</li>\n             *      <li>second | seconds</li>\n             *      <li>millisecond | milliseconds</li>\n             *  </ul>\n             */\n            difference: function (/*Date*/date1, /*Date?*/date2, /*String*/interval, utc) {\n                date2 = date2 || new Date();\n                interval = interval || \"day\";\n                return differenceTransform(interval, date1, date2, utc);\n            },\n\n            /**\n             * Formats a date to the specidifed format string\n             *\n             * @example\n             *\n             * var date = new Date(2006, 7, 11, 0, 55, 12, 345);\n             * dateExtender.format(date, \"EEEE, MMMM dd, yyyy\"); //\"Friday, August 11, 2006\"\n             * dateExtender.format(date, \"M/dd/yy\"); //\"8/11/06\"\n             * dateExtender.format(date, \"E\"); //\"6\"\n             * dateExtender.format(date, \"h:m a\"); //\"12:55 AM\"\n             * dateExtender.format(date, 'h:m:s'); //\"12:55:12\"\n             * dateExtender.format(date, 'h:m:s.SS'); //\"12:55:12.35\"\n             * dateExtender.format(date, 'k:m:s.SS'); //\"24:55:12.35\"\n             * dateExtender.format(date, 'H:m:s.SS'); //\"0:55:12.35\"\n             * dateExtender.format(date, \"ddMMyyyy\"); //\"11082006\"\n             *\n             * @param date the date to format\n             * @param {String} format the format of the date composed of the following options\n             * <ul>\n             *                  <li> G    Era designator    Text    AD</li>\n             *                  <li> y    Year    Year    1996; 96</li>\n             *                  <li> M    Month in year    Month    July; Jul; 07</li>\n             *                  <li> w    Week in year    Number    27</li>\n             *                  <li> W    Week in month    Number    2</li>\n             *                  <li> D    Day in year    Number    189</li>\n             *                  <li> d    Day in month    Number    10</li>\n             *                  <li> E    Day in week    Text    Tuesday; Tue</li>\n             *                  <li> a    Am/pm marker    Text    PM</li>\n             *                  <li> H    Hour in day (0-23)    Number    0</li>\n             *                  <li> k    Hour in day (1-24)    Number    24</li>\n             *                  <li> K    Hour in am/pm (0-11)    Number    0</li>\n             *                  <li> h    Hour in am/pm (1-12)    Number    12</li>\n             *                  <li> m    Minute in hour    Number    30</li>\n             *                  <li> s    Second in minute    Number    55</li>\n             *                  <li> S    Millisecond    Number    978</li>\n             *                  <li> z    Time zone    General time zone    Pacific Standard Time; PST; GMT-08:00</li>\n             *                  <li> Z    Time zone    RFC 822 time zone    -0800 </li>\n             * </ul>\n             */\n            format: function (date, format, utc) {\n                utc = utc || false;\n                var fullYear, month, day, d, hour, minute, second, millisecond;\n                if (utc) {\n                    fullYear = date.getUTCFullYear();\n                    month = date.getUTCMonth();\n                    day = date.getUTCDay();\n                    d = date.getUTCDate();\n                    hour = date.getUTCHours();\n                    minute = date.getUTCMinutes();\n                    second = date.getUTCSeconds();\n                    millisecond = date.getUTCMilliseconds();\n                } else {\n                    fullYear = date.getFullYear();\n                    month = date.getMonth();\n                    d = date.getDate();\n                    day = date.getDay();\n                    hour = date.getHours();\n                    minute = date.getMinutes();\n                    second = date.getSeconds();\n                    millisecond = date.getMilliseconds();\n                }\n                return format.replace(/([A-Za-z])\\1*/g, function (match) {\n                    var s, pad,\n                        c = match.charAt(0),\n                        l = match.length;\n                    if (c === 'd') {\n                        s = \"\" + d;\n                        pad = true;\n                    } else if (c === \"H\" && !s) {\n                        s = \"\" + hour;\n                        pad = true;\n                    } else if (c === 'm' && !s) {\n                        s = \"\" + minute;\n                        pad = true;\n                    } else if (c === 's') {\n                        if (!s) {\n                            s = \"\" + second;\n                        }\n                        pad = true;\n                    } else if (c === \"G\") {\n                        s = ((l < 4) ? eraAbbr : eraNames)[fullYear < 0 ? 0 : 1];\n                    } else if (c === \"y\") {\n                        s = fullYear;\n                        if (l > 1) {\n                            if (l === 2) {\n                                s = _truncate(\"\" + s, 2, true);\n                            } else {\n                                pad = true;\n                            }\n                        }\n                    } else if (c.toUpperCase() === \"Q\") {\n                        s = ceil((month + 1) / 3);\n                        pad = true;\n                    } else if (c === \"M\") {\n                        if (l < 3) {\n                            s = month + 1;\n                            pad = true;\n                        } else {\n                            s = (l === 3 ? monthAbbr : monthNames)[month];\n                        }\n                    } else if (c === \"w\") {\n                        s = getWeekOfYear(date, 0, utc);\n                        pad = true;\n                    } else if (c === \"D\") {\n                        s = getDayOfYear(date, utc);\n                        pad = true;\n                    } else if (c === \"E\") {\n                        if (l < 3) {\n                            s = day + 1;\n                            pad = true;\n                        } else {\n                            s = (l === -3 ? dayAbbr : dayNames)[day];\n                        }\n                    } else if (c === 'a') {\n                        s = (hour < 12) ? 'AM' : 'PM';\n                    } else if (c === \"h\") {\n                        s = (hour % 12) || 12;\n                        pad = true;\n                    } else if (c === \"K\") {\n                        s = (hour % 12);\n                        pad = true;\n                    } else if (c === \"k\") {\n                        s = hour || 24;\n                        pad = true;\n                    } else if (c === \"S\") {\n                        s = round(millisecond * pow(10, l - 3));\n                        pad = true;\n                    } else if (c === \"z\" || c === \"v\" || c === \"Z\") {\n                        s = getTimezoneName(date);\n                        if ((c === \"z\" || c === \"v\") && !s) {\n                            l = 4;\n                        }\n                        if (!s || c === \"Z\") {\n                            var offset = date.getTimezoneOffset();\n                            var tz = [\n                                (offset >= 0 ? \"-\" : \"+\"),\n                                _pad(floor(abs(offset) / 60), 2, \"0\"),\n                                _pad(abs(offset) % 60, 2, \"0\")\n                            ];\n                            if (l === 4) {\n                                tz.splice(0, 0, \"GMT\");\n                                tz.splice(3, 0, \":\");\n                            }\n                            s = tz.join(\"\");\n                        }\n                    } else {\n                        s = match;\n                    }\n                    if (pad) {\n                        s = _pad(s, l, '0');\n                    }\n                    return s;\n                });\n            }\n\n        };\n\n        var numberDate = {};\n\n        function addInterval(interval) {\n            numberDate[interval + \"sFromNow\"] = function (val) {\n                return date.add(new Date(), interval, val);\n            };\n            numberDate[interval + \"sAgo\"] = function (val) {\n                return date.add(new Date(), interval, -val);\n            };\n        }\n\n        var intervals = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"];\n        for (var i = 0, l = intervals.length; i < l; i++) {\n            addInterval(intervals[i]);\n        }\n\n        var stringDate = {\n\n            parseDate: function (dateStr, format) {\n                if (!format) {\n                    throw new Error('format required when calling dateExtender.parse');\n                }\n                var tokens = [], regexp = buildDateEXP(format, tokens),\n                    re = new RegExp(\"^\" + regexp + \"$\", \"i\"),\n                    match = re.exec(dateStr);\n                if (!match) {\n                    return null;\n                } // null\n                var result = [1970, 0, 1, 0, 0, 0, 0], // will get converted to a Date at the end\n                    amPm = \"\",\n                    valid = every(match, function (v, i) {\n                        if (i) {\n                            var token = tokens[i - 1];\n                            var l = token.length, type = token.charAt(0);\n                            if (type === 'y') {\n                                if (v < 100) {\n                                    v = parseInt(v, 10);\n                                    //choose century to apply, according to a sliding window\n                                    //of 80 years before and 20 years after present year\n                                    var year = '' + new Date().getFullYear(),\n                                        century = year.substring(0, 2) * 100,\n                                        cutoff = min(year.substring(2, 4) + 20, 99);\n                                    result[0] = (v < cutoff) ? century + v : century - 100 + v;\n                                } else {\n                                    result[0] = v;\n                                }\n                            } else if (type === \"M\") {\n                                if (l > 2) {\n                                    var months = monthNames, j, k;\n                                    if (l === 3) {\n                                        months = monthAbbr;\n                                    }\n                                    //Tolerate abbreviating period in month part\n                                    //Case-insensitive comparison\n                                    v = v.replace(\".\", \"\").toLowerCase();\n                                    var contains = false;\n                                    for (j = 0, k = months.length; j < k && !contains; j++) {\n                                        var s = months[j].replace(\".\", \"\").toLocaleLowerCase();\n                                        if (s === v) {\n                                            v = j;\n                                            contains = true;\n                                        }\n                                    }\n                                    if (!contains) {\n                                        return false;\n                                    }\n                                } else {\n                                    v--;\n                                }\n                                result[1] = v;\n                            } else if (type === \"E\" || type === \"e\") {\n                                var days = dayNames;\n                                if (l === 3) {\n                                    days = dayAbbr;\n                                }\n                                //Case-insensitive comparison\n                                v = v.toLowerCase();\n                                days = array.map(days, function (d) {\n                                    return d.toLowerCase();\n                                });\n                                var d = array.indexOf(days, v);\n                                if (d === -1) {\n                                    v = parseInt(v, 10);\n                                    if (isNaN(v) || v > days.length) {\n                                        return false;\n                                    }\n                                } else {\n                                    v = d;\n                                }\n                            } else if (type === 'D' || type === \"d\") {\n                                if (type === \"D\") {\n                                    result[1] = 0;\n                                }\n                                result[2] = v;\n                            } else if (type === \"a\") {\n                                var am = \"am\";\n                                var pm = \"pm\";\n                                var period = /\\./g;\n                                v = v.replace(period, '').toLowerCase();\n                                // we might not have seen the hours field yet, so store the state and apply hour change later\n                                amPm = (v === pm) ? 'p' : (v === am) ? 'a' : '';\n                            } else if (type === \"k\" || type === \"h\" || type === \"H\" || type === \"K\") {\n                                if (type === \"k\" && (+v) === 24) {\n                                    v = 0;\n                                }\n                                result[3] = v;\n                            } else if (type === \"m\") {\n                                result[4] = v;\n                            } else if (type === \"s\") {\n                                result[5] = v;\n                            } else if (type === \"S\") {\n                                result[6] = v;\n                            }\n                        }\n                        return true;\n                    });\n                if (valid) {\n                    var hours = +result[3];\n                    //account for am/pm\n                    if (amPm === 'p' && hours < 12) {\n                        result[3] = hours + 12; //e.g., 3pm -> 15\n                    } else if (amPm === 'a' && hours === 12) {\n                        result[3] = 0; //12am -> 0\n                    }\n                    var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date\n                    var dateToken = (array.indexOf(tokens, 'd') !== -1),\n                        monthToken = (array.indexOf(tokens, 'M') !== -1),\n                        month = result[1],\n                        day = result[2],\n                        dateMonth = dateObject.getMonth(),\n                        dateDay = dateObject.getDate();\n                    if ((monthToken && dateMonth > month) || (dateToken && dateDay > day)) {\n                        return null;\n                    }\n                    return dateObject; // Date\n                } else {\n                    return null;\n                }\n            }\n        };\n\n\n        var ret = extended.define(is.isDate, date).define(is.isString, stringDate).define(is.isNumber, numberDate);\n        for (i in date) {\n            if (date.hasOwnProperty(i)) {\n                ret[i] = date[i];\n            }\n        }\n\n        for (i in stringDate) {\n            if (stringDate.hasOwnProperty(i)) {\n                ret[i] = stringDate[i];\n            }\n        }\n        for (i in numberDate) {\n            if (numberDate.hasOwnProperty(i)) {\n                ret[i] = numberDate[i];\n            }\n        }\n        return ret;\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineDate(require(\"extended\"), require(\"is-extended\"), require(\"array-extended\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extended\", \"is-extended\", \"array-extended\"], function (extended, is, arr) {\n            return defineDate(extended, is, arr);\n        });\n    } else {\n        this.dateExtended = defineDate(this.extended, this.isExtended, this.arrayExtended);\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"array-extended\":52,\"extended\":56,\"is-extended\":66}],54:[function(require,module,exports){\n(function () {\n\n    /**\n     * @projectName declare\n     * @github http://github.com/doug-martin/declare.js\n     * @header\n     *\n     * Declare is a library designed to allow writing object oriented code the same way in both the browser and node.js.\n     *\n     * ##Installation\n     *\n     * `npm install declare.js`\n     *\n     * Or [download the source](https://raw.github.com/doug-martin/declare.js/master/declare.js) ([minified](https://raw.github.com/doug-martin/declare.js/master/declare-min.js))\n     *\n     * ###Requirejs\n     *\n     * To use with requirejs place the `declare` source in the root scripts directory\n     *\n     * ```\n     *\n     * define([\"declare\"], function(declare){\n     *      return declare({\n     *          instance : {\n     *              hello : function(){\n     *                  return \"world\";\n     *              }\n     *          }\n     *      });\n     * });\n     *\n     * ```\n     *\n     *\n     * ##Usage\n     *\n     * declare.js provides\n     *\n     * Class methods\n     *\n     * * `as(module | object, name)` : exports the object to module or the object with the name\n     * * `mixin(mixin)` : mixes in an object but does not inherit directly from the object. **Note** this does not return a new class but changes the original class.\n     * * `extend(proto)` : extend a class with the given properties. A shortcut to `declare(Super, {})`;\n     *\n     * Instance methods\n     *\n     * * `_super(arguments)`: calls the super of the current method, you can pass in either the argments object or an array with arguments you want passed to super\n     * * `_getSuper()`: returns a this methods direct super.\n     * * `_static` : use to reference class properties and methods.\n     * * `get(prop)` : gets a property invoking the getter if it exists otherwise it just returns the named property on the object.\n     * * `set(prop, val)` : sets a property invoking the setter if it exists otherwise it just sets the named property on the object.\n     *\n     *\n     * ###Declaring a new Class\n     *\n     * Creating a new class with declare is easy!\n     *\n     * ```\n     *\n     * var Mammal = declare({\n     *      //define your instance methods and properties\n     *      instance : {\n     *\n     *          //will be called whenever a new instance is created\n     *          constructor: function(options) {\n     *              options = options || {};\n     *              this._super(arguments);\n     *              this._type = options.type || \"mammal\";\n     *          },\n     *\n     *          speak : function() {\n     *              return  \"A mammal of type \" + this._type + \" sounds like\";\n     *          },\n     *\n     *          //Define your getters\n     *          getters : {\n     *\n     *              //can be accessed by using the get method. (mammal.get(\"type\"))\n     *              type : function() {\n     *                  return this._type;\n     *              }\n     *          },\n     *\n     *           //Define your setters\n     *          setters : {\n     *\n     *                //can be accessed by using the set method. (mammal.set(\"type\", \"mammalType\"))\n     *              type : function(t) {\n     *                  this._type = t;\n     *              }\n     *          }\n     *      },\n     *\n     *      //Define your static methods\n     *      static : {\n     *\n     *          //Mammal.soundOff(); //\"Im a mammal!!\"\n     *          soundOff : function() {\n     *              return \"Im a mammal!!\";\n     *          }\n     *      }\n     * });\n     *\n     *\n     * ```\n     *\n     * You can use Mammal just like you would any other class.\n     *\n     * ```\n     * Mammal.soundOff(\"Im a mammal!!\");\n     *\n     * var myMammal = new Mammal({type : \"mymammal\"});\n     * myMammal.speak(); // \"A mammal of type mymammal sounds like\"\n     * myMammal.get(\"type\"); //\"mymammal\"\n     * myMammal.set(\"type\", \"mammal\");\n     * myMammal.get(\"type\"); //\"mammal\"\n     *\n     *\n     * ```\n     *\n     * ###Extending a class\n     *\n     * If you want to just extend a single class use the .extend method.\n     *\n     * ```\n     *\n     * var Wolf = Mammal.extend({\n     *\n     *   //define your instance method\n     *   instance: {\n     *\n     *        //You can override super constructors just be sure to call `_super`\n     *       constructor: function(options) {\n     *          options = options || {};\n     *          this._super(arguments); //call our super constructor.\n     *          this._sound = \"growl\";\n     *          this._color = options.color || \"grey\";\n     *      },\n     *\n     *      //override Mammals `speak` method by appending our own data to it.\n     *      speak : function() {\n     *          return this._super(arguments) + \" a \" + this._sound;\n     *      },\n     *\n     *      //add new getters for sound and color\n     *      getters : {\n     *\n     *           //new Wolf().get(\"type\")\n     *           //notice color is read only as we did not define a setter\n     *          color : function() {\n     *              return this._color;\n     *          },\n     *\n     *          //new Wolf().get(\"sound\")\n     *          sound : function() {\n     *              return this._sound;\n     *          }\n     *      },\n     *\n     *      setters : {\n     *\n     *          //new Wolf().set(\"sound\", \"howl\")\n     *          sound : function(s) {\n     *              this._sound = s;\n     *          }\n     *      }\n     *\n     *  },\n     *\n     *  static : {\n     *\n     *      //You can override super static methods also! And you can still use _super\n     *      soundOff : function() {\n     *          //You can even call super in your statics!!!\n     *          //should return \"I'm a mammal!! that growls\"\n     *          return this._super(arguments) + \" that growls\";\n     *      }\n     *  }\n     * });\n     *\n     * Wolf.soundOff(); //Im a mammal!! that growls\n     *\n     * var myWolf = new Wolf();\n     * myWolf instanceof Mammal //true\n     * myWolf instanceof Wolf //true\n     *\n     * ```\n     *\n     * You can also extend a class by using the declare method and just pass in the super class.\n     *\n     * ```\n     * //Typical hierarchical inheritance\n     * // Mammal->Wolf->Dog\n     * var Dog = declare(Wolf, {\n     *    instance: {\n     *        constructor: function(options) {\n     *            options = options || {};\n     *            this._super(arguments);\n     *            //override Wolfs initialization of sound to woof.\n     *            this._sound = \"woof\";\n     *\n     *        },\n     *\n     *        speak : function() {\n     *            //Should return \"A mammal of type mammal sounds like a growl thats domesticated\"\n     *            return this._super(arguments) + \" thats domesticated\";\n     *        }\n     *    },\n     *\n     *    static : {\n     *        soundOff : function() {\n     *            //should return \"I'm a mammal!! that growls but now barks\"\n     *            return this._super(arguments) + \" but now barks\";\n     *        }\n     *    }\n     * });\n     *\n     * Dog.soundOff(); //Im a mammal!! that growls but now barks\n     *\n     * var myDog = new Dog();\n     * myDog instanceof Mammal //true\n     * myDog instanceof Wolf //true\n     * myDog instanceof Dog //true\n     *\n     *\n     * //Notice you still get the extend method.\n     *\n     * // Mammal->Wolf->Dog->Breed\n     * var Breed = Dog.extend({\n     *    instance: {\n     *\n     *        //initialize outside of constructor\n     *        _pitch : \"high\",\n     *\n     *        constructor: function(options) {\n     *            options = options || {};\n     *            this._super(arguments);\n     *            this.breed = options.breed || \"lab\";\n     *        },\n     *\n     *        speak : function() {\n     *            //Should return \"A mammal of type mammal sounds like a\n     *            //growl thats domesticated with a high pitch!\"\n     *            return this._super(arguments) + \" with a \" + this._pitch + \" pitch!\";\n     *        },\n     *\n     *        getters : {\n     *            pitch : function() {\n     *                return this._pitch;\n     *            }\n     *        }\n     *    },\n     *\n     *    static : {\n     *        soundOff : function() {\n     *            //should return \"I'M A MAMMAL!! THAT GROWLS BUT NOW BARKS!\"\n     *            return this._super(arguments).toUpperCase() + \"!\";\n     *        }\n     *    }\n     * });\n     *\n     *\n     * Breed.soundOff()//\"IM A MAMMAL!! THAT GROWLS BUT NOW BARKS!\"\n     *\n     * var myBreed = new Breed({color : \"gold\", type : \"lab\"}),\n     * myBreed instanceof Dog //true\n     * myBreed instanceof Wolf //true\n     * myBreed instanceof Mammal //true\n     * myBreed.speak() //\"A mammal of type lab sounds like a woof thats domesticated with a high pitch!\"\n     * myBreed.get(\"type\") //\"lab\"\n     * myBreed.get(\"color\") //\"gold\"\n     * myBreed.get(\"sound\")\" //\"woof\"\n     * ```\n     *\n     * ###Multiple Inheritance / Mixins\n     *\n     * declare also allows the use of multiple super classes.\n     * This is useful if you have generic classes that provide functionality but shouldnt be used on their own.\n     *\n     * Lets declare a mixin that allows us to watch for property changes.\n     *\n     * ```\n     * //Notice that we set up the functions outside of declare because we can reuse them\n     *\n     * function _set(prop, val) {\n     *     //get the old value\n     *     var oldVal = this.get(prop);\n     *     //call super to actually set the property\n     *     var ret = this._super(arguments);\n     *     //call our handlers\n     *     this.__callHandlers(prop, oldVal, val);\n     *     return ret;\n     * }\n     *\n     * function _callHandlers(prop, oldVal, newVal) {\n     *    //get our handlers for the property\n     *     var handlers = this.__watchers[prop], l;\n     *     //if the handlers exist and their length does not equal 0 then we call loop through them\n     *     if (handlers && (l = handlers.length) !== 0) {\n     *         for (var i = 0; i < l; i++) {\n     *             //call the handler\n     *             handlers[i].call(null, prop, oldVal, newVal);\n     *         }\n     *     }\n     * }\n     *\n     *\n     * //the watch function\n     * function _watch(prop, handler) {\n     *     if (\"function\" !== typeof handler) {\n     *         //if its not a function then its an invalid handler\n     *         throw new TypeError(\"Invalid handler.\");\n     *     }\n     *     if (!this.__watchers[prop]) {\n     *         //create the watchers if it doesnt exist\n     *         this.__watchers[prop] = [handler];\n     *     } else {\n     *         //otherwise just add it to the handlers array\n     *         this.__watchers[prop].push(handler);\n     *     }\n     * }\n     *\n     * function _unwatch(prop, handler) {\n     *     if (\"function\" !== typeof handler) {\n     *         throw new TypeError(\"Invalid handler.\");\n     *     }\n     *     var handlers = this.__watchers[prop], index;\n     *     if (handlers && (index = handlers.indexOf(handler)) !== -1) {\n     *        //remove the handler if it is found\n     *         handlers.splice(index, 1);\n     *     }\n     * }\n     *\n     * declare({\n     *     instance:{\n     *         constructor:function () {\n     *             this._super(arguments);\n     *             //set up our watchers\n     *             this.__watchers = {};\n     *         },\n     *\n     *         //override the default set function so we can watch values\n     *         \"set\":_set,\n     *         //set up our callhandlers function\n     *         __callHandlers:_callHandlers,\n     *         //add the watch function\n     *         watch:_watch,\n     *         //add the unwatch function\n     *         unwatch:_unwatch\n     *     },\n     *\n     *     \"static\":{\n     *\n     *         init:function () {\n     *             this._super(arguments);\n     *             this.__watchers = {};\n     *         },\n     *         //override the default set function so we can watch values\n     *         \"set\":_set,\n     *         //set our callHandlers function\n     *         __callHandlers:_callHandlers,\n     *         //add the watch\n     *         watch:_watch,\n     *         //add the unwatch function\n     *         unwatch:_unwatch\n     *     }\n     * })\n     *\n     * ```\n     *\n     * Now lets use the mixin\n     *\n     * ```\n     * var WatchDog = declare([Dog, WatchMixin]);\n     *\n     * var watchDog = new WatchDog();\n     * //create our handler\n     * function watch(id, oldVal, newVal) {\n     *     console.log(\"watchdog's %s was %s, now %s\", id, oldVal, newVal);\n     * }\n     *\n     * //watch for property changes\n     * watchDog.watch(\"type\", watch);\n     * watchDog.watch(\"color\", watch);\n     * watchDog.watch(\"sound\", watch);\n     *\n     * //now set the properties each handler will be called\n     * watchDog.set(\"type\", \"newDog\");\n     * watchDog.set(\"color\", \"newColor\");\n     * watchDog.set(\"sound\", \"newSound\");\n     *\n     *\n     * //unwatch the property changes\n     * watchDog.unwatch(\"type\", watch);\n     * watchDog.unwatch(\"color\", watch);\n     * watchDog.unwatch(\"sound\", watch);\n     *\n     * //no handlers will be called this time\n     * watchDog.set(\"type\", \"newDog\");\n     * watchDog.set(\"color\", \"newColor\");\n     * watchDog.set(\"sound\", \"newSound\");\n     *\n     *\n     * ```\n     *\n     * ###Accessing static methods and properties witin an instance.\n     *\n     * To access static properties on an instance use the `_static` property which is a reference to your constructor.\n     *\n     * For example if your in your constructor and you want to have configurable default values.\n     *\n     * ```\n     * consturctor : function constructor(opts){\n     *     this.opts = opts || {};\n     *     this._type = opts.type || this._static.DEFAULT_TYPE;\n     * }\n     * ```\n     *\n     *\n     *\n     * ###Creating a new instance of within an instance.\n     *\n     * Often times you want to create a new instance of an object within an instance. If your subclassed however you cannot return a new instance of the parent class as it will not be the right sub class. `declare` provides a way around this by setting the `_static` property on each isntance of the class.\n     *\n     * Lets add a reproduce method `Mammal`\n     *\n     * ```\n     * reproduce : function(options){\n     *     return new this._static(options);\n     * }\n     * ```\n     *\n     * Now in each subclass you can call reproduce and get the proper type.\n     *\n     * ```\n     * var myDog = new Dog();\n     * var myDogsChild = myDog.reproduce();\n     *\n     * myDogsChild instanceof Dog; //true\n     * ```\n     *\n     * ###Using the `as`\n     *\n     * `declare` also provides an `as` method which allows you to add your class to an object or if your using node.js you can pass in `module` and the class will be exported as the module.\n     *\n     * ```\n     * var animals = {};\n     *\n     * Mammal.as(animals, \"Dog\");\n     * Wolf.as(animals, \"Wolf\");\n     * Dog.as(animals, \"Dog\");\n     * Breed.as(animals, \"Breed\");\n     *\n     * var myDog = new animals.Dog();\n     *\n     * ```\n     *\n     * Or in node\n     *\n     * ```\n     * Mammal.as(exports, \"Dog\");\n     * Wolf.as(exports, \"Wolf\");\n     * Dog.as(exports, \"Dog\");\n     * Breed.as(exports, \"Breed\");\n     *\n     * ```\n     *\n     * To export a class as the `module` in node\n     *\n     * ```\n     * Mammal.as(module);\n     * ```\n     *\n     *\n     */\n    function createDeclared() {\n        var arraySlice = Array.prototype.slice, classCounter = 0, Base, forceNew = new Function();\n\n        var SUPER_REGEXP = /(super)/g;\n\n        function argsToArray(args, slice) {\n            slice = slice || 0;\n            return arraySlice.call(args, slice);\n        }\n\n        function isArray(obj) {\n            return Object.prototype.toString.call(obj) === \"[object Array]\";\n        }\n\n        function isObject(obj) {\n            var undef;\n            return obj !== null && obj !== undef && typeof obj === \"object\";\n        }\n\n        function isHash(obj) {\n            var ret = isObject(obj);\n            return ret && obj.constructor === Object;\n        }\n\n        var isArguments = function _isArguments(object) {\n            return Object.prototype.toString.call(object) === '[object Arguments]';\n        };\n\n        if (!isArguments(arguments)) {\n            isArguments = function _isArguments(obj) {\n                return !!(obj && obj.hasOwnProperty(\"callee\"));\n            };\n        }\n\n        function indexOf(arr, item) {\n            if (arr && arr.length) {\n                for (var i = 0, l = arr.length; i < l; i++) {\n                    if (arr[i] === item) {\n                        return i;\n                    }\n                }\n            }\n            return -1;\n        }\n\n        function merge(target, source, exclude) {\n            var name, s;\n            for (name in source) {\n                if (source.hasOwnProperty(name) && indexOf(exclude, name) === -1) {\n                    s = source[name];\n                    if (!(name in target) || (target[name] !== s)) {\n                        target[name] = s;\n                    }\n                }\n            }\n            return target;\n        }\n\n        function callSuper(args, a) {\n            var meta = this.__meta,\n                supers = meta.supers,\n                l = supers.length, superMeta = meta.superMeta, pos = superMeta.pos;\n            if (l > pos) {\n                args = !args ? [] : (!isArguments(args) && !isArray(args)) ? [args] : args;\n                var name = superMeta.name, f = superMeta.f, m;\n                do {\n                    m = supers[pos][name];\n                    if (\"function\" === typeof m && (m = m._f || m) !== f) {\n                        superMeta.pos = 1 + pos;\n                        return m.apply(this, args);\n                    }\n                } while (l > ++pos);\n            }\n\n            return null;\n        }\n\n        function getSuper() {\n            var meta = this.__meta,\n                supers = meta.supers,\n                l = supers.length, superMeta = meta.superMeta, pos = superMeta.pos;\n            if (l > pos) {\n                var name = superMeta.name, f = superMeta.f, m;\n                do {\n                    m = supers[pos][name];\n                    if (\"function\" === typeof m && (m = m._f || m) !== f) {\n                        superMeta.pos = 1 + pos;\n                        return m.bind(this);\n                    }\n                } while (l > ++pos);\n            }\n            return null;\n        }\n\n        function getter(name) {\n            var getters = this.__getters__;\n            if (getters.hasOwnProperty(name)) {\n                return getters[name].apply(this);\n            } else {\n                return this[name];\n            }\n        }\n\n        function setter(name, val) {\n            var setters = this.__setters__;\n            if (isHash(name)) {\n                for (var i in name) {\n                    var prop = name[i];\n                    if (setters.hasOwnProperty(i)) {\n                        setters[name].call(this, prop);\n                    } else {\n                        this[i] = prop;\n                    }\n                }\n            } else {\n                if (setters.hasOwnProperty(name)) {\n                    return setters[name].apply(this, argsToArray(arguments, 1));\n                } else {\n                    return this[name] = val;\n                }\n            }\n        }\n\n\n        function defaultFunction() {\n            var meta = this.__meta || {},\n                supers = meta.supers,\n                l = supers.length, superMeta = meta.superMeta, pos = superMeta.pos;\n            if (l > pos) {\n                var name = superMeta.name, f = superMeta.f, m;\n                do {\n                    m = supers[pos][name];\n                    if (\"function\" === typeof m && (m = m._f || m) !== f) {\n                        superMeta.pos = 1 + pos;\n                        return m.apply(this, arguments);\n                    }\n                } while (l > ++pos);\n            }\n            return null;\n        }\n\n\n        function functionWrapper(f, name) {\n            if (f.toString().match(SUPER_REGEXP)) {\n                var wrapper = function wrapper() {\n                    var ret, meta = this.__meta || {};\n                    var orig = meta.superMeta;\n                    meta.superMeta = {f: f, pos: 0, name: name};\n                    switch (arguments.length) {\n                    case 0:\n                        ret = f.call(this);\n                        break;\n                    case 1:\n                        ret = f.call(this, arguments[0]);\n                        break;\n                    case 2:\n                        ret = f.call(this, arguments[0], arguments[1]);\n                        break;\n\n                    case 3:\n                        ret = f.call(this, arguments[0], arguments[1], arguments[2]);\n                        break;\n                    default:\n                        ret = f.apply(this, arguments);\n                    }\n                    meta.superMeta = orig;\n                    return ret;\n                };\n                wrapper._f = f;\n                return wrapper;\n            } else {\n                f._f = f;\n                return f;\n            }\n        }\n\n        function defineMixinProps(child, proto) {\n\n            var operations = proto.setters || {}, __setters = child.__setters__, __getters = child.__getters__;\n            for (var i in operations) {\n                if (!__setters.hasOwnProperty(i)) {  //make sure that the setter isnt already there\n                    __setters[i] = operations[i];\n                }\n            }\n            operations = proto.getters || {};\n            for (i in operations) {\n                if (!__getters.hasOwnProperty(i)) {  //make sure that the setter isnt already there\n                    __getters[i] = operations[i];\n                }\n            }\n            for (var j in proto) {\n                if (j !== \"getters\" && j !== \"setters\") {\n                    var p = proto[j];\n                    if (\"function\" === typeof p) {\n                        if (!child.hasOwnProperty(j)) {\n                            child[j] = functionWrapper(defaultFunction, j);\n                        }\n                    } else {\n                        child[j] = p;\n                    }\n                }\n            }\n        }\n\n        function mixin() {\n            var args = argsToArray(arguments), l = args.length;\n            var child = this.prototype;\n            var childMeta = child.__meta, thisMeta = this.__meta, bases = child.__meta.bases, staticBases = bases.slice(),\n                staticSupers = thisMeta.supers || [], supers = childMeta.supers || [];\n            for (var i = 0; i < l; i++) {\n                var m = args[i], mProto = m.prototype;\n                var protoMeta = mProto.__meta, meta = m.__meta;\n                !protoMeta && (protoMeta = (mProto.__meta = {proto: mProto || {}}));\n                !meta && (meta = (m.__meta = {proto: m.__proto__ || {}}));\n                defineMixinProps(child, protoMeta.proto || {});\n                defineMixinProps(this, meta.proto || {});\n                //copy the bases for static,\n\n                mixinSupers(m.prototype, supers, bases);\n                mixinSupers(m, staticSupers, staticBases);\n            }\n            return this;\n        }\n\n        function mixinSupers(sup, arr, bases) {\n            var meta = sup.__meta;\n            !meta && (meta = (sup.__meta = {}));\n            var unique = sup.__meta.unique;\n            !unique && (meta.unique = \"declare\" + ++classCounter);\n            //check it we already have this super mixed into our prototype chain\n            //if true then we have already looped their supers!\n            if (indexOf(bases, unique) === -1) {\n                //add their id to our bases\n                bases.push(unique);\n                var supers = sup.__meta.supers || [], i = supers.length - 1 || 0;\n                while (i >= 0) {\n                    mixinSupers(supers[i--], arr, bases);\n                }\n                arr.unshift(sup);\n            }\n        }\n\n        function defineProps(child, proto) {\n            var operations = proto.setters,\n                __setters = child.__setters__,\n                __getters = child.__getters__;\n            if (operations) {\n                for (var i in operations) {\n                    __setters[i] = operations[i];\n                }\n            }\n            operations = proto.getters || {};\n            if (operations) {\n                for (i in operations) {\n                    __getters[i] = operations[i];\n                }\n            }\n            for (i in proto) {\n                if (i != \"getters\" && i != \"setters\") {\n                    var f = proto[i];\n                    if (\"function\" === typeof f) {\n                        var meta = f.__meta || {};\n                        if (!meta.isConstructor) {\n                            child[i] = functionWrapper(f, i);\n                        } else {\n                            child[i] = f;\n                        }\n                    } else {\n                        child[i] = f;\n                    }\n                }\n            }\n\n        }\n\n        function _export(obj, name) {\n            if (obj && name) {\n                obj[name] = this;\n            } else {\n                obj.exports = obj = this;\n            }\n            return this;\n        }\n\n        function extend(proto) {\n            return declare(this, proto);\n        }\n\n        function getNew(ctor) {\n            // create object with correct prototype using a do-nothing\n            // constructor\n            forceNew.prototype = ctor.prototype;\n            var t = new forceNew();\n            forceNew.prototype = null;\t// clean up\n            return t;\n        }\n\n\n        function __declare(child, sup, proto) {\n            var childProto = {}, supers = [];\n            var unique = \"declare\" + ++classCounter, bases = [], staticBases = [];\n            var instanceSupers = [], staticSupers = [];\n            var meta = {\n                supers: instanceSupers,\n                unique: unique,\n                bases: bases,\n                superMeta: {\n                    f: null,\n                    pos: 0,\n                    name: null\n                }\n            };\n            var childMeta = {\n                supers: staticSupers,\n                unique: unique,\n                bases: staticBases,\n                isConstructor: true,\n                superMeta: {\n                    f: null,\n                    pos: 0,\n                    name: null\n                }\n            };\n\n            if (isHash(sup) && !proto) {\n                proto = sup;\n                sup = Base;\n            }\n\n            if (\"function\" === typeof sup || isArray(sup)) {\n                supers = isArray(sup) ? sup : [sup];\n                sup = supers.shift();\n                child.__meta = childMeta;\n                childProto = getNew(sup);\n                childProto.__meta = meta;\n                childProto.__getters__ = merge({}, childProto.__getters__ || {});\n                childProto.__setters__ = merge({}, childProto.__setters__ || {});\n                child.__getters__ = merge({}, child.__getters__ || {});\n                child.__setters__ = merge({}, child.__setters__ || {});\n                mixinSupers(sup.prototype, instanceSupers, bases);\n                mixinSupers(sup, staticSupers, staticBases);\n            } else {\n                child.__meta = childMeta;\n                childProto.__meta = meta;\n                childProto.__getters__ = childProto.__getters__ || {};\n                childProto.__setters__ = childProto.__setters__ || {};\n                child.__getters__ = child.__getters__ || {};\n                child.__setters__ = child.__setters__ || {};\n            }\n            child.prototype = childProto;\n            if (proto) {\n                var instance = meta.proto = proto.instance || {};\n                var stat = childMeta.proto = proto.static || {};\n                stat.init = stat.init || defaultFunction;\n                defineProps(childProto, instance);\n                defineProps(child, stat);\n                if (!instance.hasOwnProperty(\"constructor\")) {\n                    childProto.constructor = instance.constructor = functionWrapper(defaultFunction, \"constructor\");\n                } else {\n                    childProto.constructor = functionWrapper(instance.constructor, \"constructor\");\n                }\n            } else {\n                meta.proto = {};\n                childMeta.proto = {};\n                child.init = functionWrapper(defaultFunction, \"init\");\n                childProto.constructor = functionWrapper(defaultFunction, \"constructor\");\n            }\n            if (supers.length) {\n                mixin.apply(child, supers);\n            }\n            if (sup) {\n                //do this so we mixin our super methods directly but do not ov\n                merge(child, merge(merge({}, sup), child));\n            }\n            childProto._super = child._super = callSuper;\n            childProto._getSuper = child._getSuper = getSuper;\n            childProto._static = child;\n        }\n\n        function declare(sup, proto) {\n            function declared() {\n                switch (arguments.length) {\n                case 0:\n                    this.constructor.call(this);\n                    break;\n                case 1:\n                    this.constructor.call(this, arguments[0]);\n                    break;\n                case 2:\n                    this.constructor.call(this, arguments[0], arguments[1]);\n                    break;\n                case 3:\n                    this.constructor.call(this, arguments[0], arguments[1], arguments[2]);\n                    break;\n                default:\n                    this.constructor.apply(this, arguments);\n                }\n            }\n\n            __declare(declared, sup, proto);\n            return declared.init() || declared;\n        }\n\n        function singleton(sup, proto) {\n            var retInstance;\n\n            function declaredSingleton() {\n                if (!retInstance) {\n                    this.constructor.apply(this, arguments);\n                    retInstance = this;\n                }\n                return retInstance;\n            }\n\n            __declare(declaredSingleton, sup, proto);\n            return  declaredSingleton.init() || declaredSingleton;\n        }\n\n        Base = declare({\n            instance: {\n                \"get\": getter,\n                \"set\": setter\n            },\n\n            \"static\": {\n                \"get\": getter,\n                \"set\": setter,\n                mixin: mixin,\n                extend: extend,\n                as: _export\n            }\n        });\n\n        declare.singleton = singleton;\n        return declare;\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = createDeclared();\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define(createDeclared);\n    } else {\n        this.declare = createDeclared();\n    }\n}());\n\n\n\n\n},{}],55:[function(require,module,exports){\nmodule.exports = require(\"./declare.js\");\n},{\"./declare.js\":54}],56:[function(require,module,exports){\n(function () {\n    \"use strict\";\n    /*global extender is, dateExtended*/\n\n    function defineExtended(extender) {\n\n\n        var merge = (function merger() {\n            function _merge(target, source) {\n                var name, s;\n                for (name in source) {\n                    if (source.hasOwnProperty(name)) {\n                        s = source[name];\n                        if (!(name in target) || (target[name] !== s)) {\n                            target[name] = s;\n                        }\n                    }\n                }\n                return target;\n            }\n\n            return function merge(obj) {\n                if (!obj) {\n                    obj = {};\n                }\n                for (var i = 1, l = arguments.length; i < l; i++) {\n                    _merge(obj, arguments[i]);\n                }\n                return obj; // Object\n            };\n        }());\n\n        function getExtended() {\n\n            var loaded = {};\n\n\n            //getInitial instance;\n            var extended = extender.define();\n            extended.expose({\n                register: function register(alias, extendWith) {\n                    if (!extendWith) {\n                        extendWith = alias;\n                        alias = null;\n                    }\n                    var type = typeof extendWith;\n                    if (alias) {\n                        extended[alias] = extendWith;\n                    } else if (extendWith && type === \"function\") {\n                        extended.extend(extendWith);\n                    } else if (type === \"object\") {\n                        extended.expose(extendWith);\n                    } else {\n                        throw new TypeError(\"extended.register must be called with an extender function\");\n                    }\n                    return extended;\n                },\n\n                define: function () {\n                    return extender.define.apply(extender, arguments);\n                }\n            });\n\n            return extended;\n        }\n\n        function extended() {\n            return getExtended();\n        }\n\n        extended.define = function define() {\n            return extender.define.apply(extender, arguments);\n        };\n\n        return extended;\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineExtended(require(\"extender\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extender\"], function (extender) {\n            return defineExtended(extender);\n        });\n    } else {\n        this.extended = defineExtended(this.extender);\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"extender\":58}],57:[function(require,module,exports){\n(function () {\n    /*jshint strict:false*/\n\n\n    /**\n     *\n     * @projectName extender\n     * @github http://github.com/doug-martin/extender\n     * @header\n     * [![build status](https://secure.travis-ci.org/doug-martin/extender.png)](http://travis-ci.org/doug-martin/extender)\n     * # Extender\n     *\n     * `extender` is a library that helps in making chainable APIs, by creating a function that accepts different values and returns an object decorated with functions based on the type.\n     *\n     * ## Why Is Extender Different?\n     *\n     * Extender is different than normal chaining because is does more than return `this`. It decorates your values in a type safe manner.\n     *\n     * For example if you return an array from a string based method then the returned value will be decorated with array methods and not the string methods. This allow you as the developer to focus on your API and not worrying about how to properly build and connect your API.\n     *\n     *\n     * ## Installation\n     *\n     * ```\n     * npm install extender\n     * ```\n     *\n     * Or [download the source](https://raw.github.com/doug-martin/extender/master/extender.js) ([minified](https://raw.github.com/doug-martin/extender/master/extender-min.js))\n     *\n     * **Note** `extender` depends on [`declare.js`](http://doug-martin.github.com/declare.js/).\n     *\n     * ### Requirejs\n     *\n     * To use with requirejs place the `extend` source in the root scripts directory\n     *\n     * ```javascript\n     *\n     * define([\"extender\"], function(extender){\n     * });\n     *\n     * ```\n     *\n     *\n     * ## Usage\n     *\n     * **`extender.define(tester, decorations)`**\n     *\n     * To create your own extender call the `extender.define` function.\n     *\n     * This function accepts an optional tester which is used to determine a value should be decorated with the specified `decorations`\n     *\n     * ```javascript\n     * function isString(obj) {\n     *     return !isUndefinedOrNull(obj) && (typeof obj === \"string\" || obj instanceof String);\n     * }\n     *\n     *\n     * var myExtender = extender.define(isString, {\n     *\t\tmultiply: function (str, times) {\n     *\t\t\tvar ret = str;\n     *\t\t\tfor (var i = 1; i < times; i++) {\n     *\t\t\t\tret += str;\n     *\t\t\t}\n     *\t\t\treturn ret;\n     *\t\t},\n     *\t\ttoArray: function (str, delim) {\n     *\t\t\tdelim = delim || \"\";\n     *\t\t\treturn str.split(delim);\n     *\t\t}\n     *\t});\n     *\n     * myExtender(\"hello\").multiply(2).value(); //hellohello\n     *\n     * ```\n     *\n     * If you do not specify a tester function and just pass in an object of `functions` then all values passed in will be decorated with methods.\n     *\n     * ```javascript\n     *\n     * function isUndefined(obj) {\n     *     var undef;\n     *     return obj === undef;\n     * }\n     *\n     * function isUndefinedOrNull(obj) {\n     *\tvar undef;\n     *     return obj === undef || obj === null;\n     * }\n     *\n     * function isArray(obj) {\n     *     return Object.prototype.toString.call(obj) === \"[object Array]\";\n     * }\n     *\n     * function isBoolean(obj) {\n     *     var undef, type = typeof obj;\n     *     return !isUndefinedOrNull(obj) && type === \"boolean\" || type === \"Boolean\";\n     * }\n     *\n     * function isString(obj) {\n     *     return !isUndefinedOrNull(obj) && (typeof obj === \"string\" || obj instanceof String);\n     * }\n     *\n     * var myExtender = extender.define({\n     *\tisUndefined : isUndefined,\n     *\tisUndefinedOrNull : isUndefinedOrNull,\n     *\tisArray : isArray,\n     *\tisBoolean : isBoolean,\n     *\tisString : isString\n     * });\n     *\n     * ```\n     *\n     * To use\n     *\n     * ```\n     * var undef;\n     * myExtender(\"hello\").isUndefined().value(); //false\n     * myExtender(undef).isUndefined().value(); //true\n     * ```\n     *\n     * You can also chain extenders so that they accept multiple types and decorates accordingly.\n     *\n     * ```javascript\n     * myExtender\n     *     .define(isArray, {\n     *\t\tpluck: function (arr, m) {\n     *\t\t\tvar ret = [];\n     *\t\t\tfor (var i = 0, l = arr.length; i < l; i++) {\n     *\t\t\t\tret.push(arr[i][m]);\n     *\t\t\t}\n     *\t\t\treturn ret;\n     *\t\t}\n     *\t})\n     *     .define(isBoolean, {\n     *\t\tinvert: function (val) {\n     *\t\t\treturn !val;\n     *\t\t}\n     *\t});\n     *\n     * myExtender([{a: \"a\"},{a: \"b\"},{a: \"c\"}]).pluck(\"a\").value(); //[\"a\", \"b\", \"c\"]\n     * myExtender(\"I love javascript!\").toArray(/\\s+/).pluck(\"0\"); //[\"I\", \"l\", \"j\"]\n     *\n     * ```\n     *\n     * Notice that we reuse the same extender as defined above.\n     *\n     * **Return Values**\n     *\n     * When creating an extender if you return a value from one of the decoration functions then that value will also be decorated. If you do not return any values then the extender will be returned.\n     *\n     * **Default decoration methods**\n     *\n     * By default every value passed into an extender is decorated with the following methods.\n     *\n     * * `value` : The value this extender represents.\n     * * `eq(otherValue)` : Tests strict equality of the currently represented value to the `otherValue`\n     * * `neq(oterValue)` : Tests strict inequality of the currently represented value.\n     * * `print` : logs the current value to the console.\n     *\n     * **Extender initialization**\n     *\n     * When creating an extender you can also specify a constructor which will be invoked with the current value.\n     *\n     * ```javascript\n     * myExtender.define(isString, {\n     *\tconstructor : function(val){\n     *     //set our value to the string trimmed\n     *\t\tthis._value = val.trimRight().trimLeft();\n     *\t}\n     * });\n     * ```\n     *\n     * **`noWrap`**\n     *\n     * `extender` also allows you to specify methods that should not have the value wrapped providing a cleaner exit function other than `value()`.\n     *\n     * For example suppose you have an API that allows you to build a validator, rather than forcing the user to invoke the `value` method you could add a method called `validator` which makes more syntactic sense.\n     *\n     * ```\n     *\n     * var myValidator = extender.define({\n     *     //chainable validation methods\n     *     //...\n     *     //end chainable validation methods\n     *\n     *     noWrap : {\n     *         validator : function(){\n     *             //return your validator\n     *         }\n     *     }\n     * });\n     *\n     * myValidator().isNotNull().isEmailAddress().validator(); //now you dont need to call .value()\n     *\n     *\n     * ```\n     * **`extender.extend(extendr)`**\n     *\n     * You may also compose extenders through the use of `extender.extend(extender)`, which will return an entirely new extender that is the composition of extenders.\n     *\n     * Suppose you have the following two extenders.\n     *\n     * ```javascript\n     * var myExtender = extender\n     *        .define({\n     *            isFunction: is.function,\n     *            isNumber: is.number,\n     *            isString: is.string,\n     *            isDate: is.date,\n     *            isArray: is.array,\n     *            isBoolean: is.boolean,\n     *            isUndefined: is.undefined,\n     *            isDefined: is.defined,\n     *            isUndefinedOrNull: is.undefinedOrNull,\n     *            isNull: is.null,\n     *            isArguments: is.arguments,\n     *            isInstanceOf: is.instanceOf,\n     *            isRegExp: is.regExp\n     *        });\n     * var myExtender2 = extender.define(is.array, {\n     *     pluck: function (arr, m) {\n     *         var ret = [];\n     *         for (var i = 0, l = arr.length; i < l; i++) {\n     *             ret.push(arr[i][m]);\n     *         }\n     *         return ret;\n     *     },\n     *\n     *     noWrap: {\n     *         pluckPlain: function (arr, m) {\n     *             var ret = [];\n     *             for (var i = 0, l = arr.length; i < l; i++) {\n     *                 ret.push(arr[i][m]);\n     *             }\n     *             return ret;\n     *         }\n     *     }\n     * });\n     *\n     *\n     * ```\n     *\n     * And you do not want to alter either of them but instead what to create a third that is the union of the two.\n     *\n     *\n     * ```javascript\n     * var composed = extender.extend(myExtender).extend(myExtender2);\n     * ```\n     * So now you can use the new extender with the joined functionality if `myExtender` and `myExtender2`.\n     *\n     * ```javascript\n     * var extended = composed([\n     *      {a: \"a\"},\n     *      {a: \"b\"},\n     *      {a: \"c\"}\n     * ]);\n     * extended.isArray().value(); //true\n     * extended.pluck(\"a\").value(); // [\"a\", \"b\", \"c\"]);\n     *\n     * ```\n     *\n     * **Note** `myExtender` and `myExtender2` will **NOT** be altered.\n     *\n     * **`extender.expose(methods)`**\n     *\n     * The `expose` method allows you to add methods to your extender that are not wrapped or automatically chained by exposing them on the extender directly.\n     *\n     * ```\n     * var isMethods = {\n     *      isFunction: is.function,\n     *      isNumber: is.number,\n     *      isString: is.string,\n     *      isDate: is.date,\n     *      isArray: is.array,\n     *      isBoolean: is.boolean,\n     *      isUndefined: is.undefined,\n     *      isDefined: is.defined,\n     *      isUndefinedOrNull: is.undefinedOrNull,\n     *      isNull: is.null,\n     *      isArguments: is.arguments,\n     *      isInstanceOf: is.instanceOf,\n     *      isRegExp: is.regExp\n     * };\n     *\n     * var myExtender = extender.define(isMethods).expose(isMethods);\n     *\n     * myExtender.isArray([]); //true\n     * myExtender([]).isArray([]).value(); //true\n     *\n     * ```\n     *\n     *\n     * **Using `instanceof`**\n     *\n     * When using extenders you can test if a value is an `instanceof` of an extender by using the instanceof operator.\n     *\n     * ```javascript\n     * var str = myExtender(\"hello\");\n     *\n     * str instanceof myExtender; //true\n     * ```\n     *\n     * ## Examples\n     *\n     * To see more examples click [here](https://github.com/doug-martin/extender/tree/master/examples)\n     */\n    function defineExtender(declare) {\n\n\n        var slice = Array.prototype.slice, undef;\n\n        function indexOf(arr, item) {\n            if (arr && arr.length) {\n                for (var i = 0, l = arr.length; i < l; i++) {\n                    if (arr[i] === item) {\n                        return i;\n                    }\n                }\n            }\n            return -1;\n        }\n\n        function isArray(obj) {\n            return Object.prototype.toString.call(obj) === \"[object Array]\";\n        }\n\n        var merge = (function merger() {\n            function _merge(target, source, exclude) {\n                var name, s;\n                for (name in source) {\n                    if (source.hasOwnProperty(name) && indexOf(exclude, name) === -1) {\n                        s = source[name];\n                        if (!(name in target) || (target[name] !== s)) {\n                            target[name] = s;\n                        }\n                    }\n                }\n                return target;\n            }\n\n            return function merge(obj) {\n                if (!obj) {\n                    obj = {};\n                }\n                var l = arguments.length;\n                var exclude = arguments[arguments.length - 1];\n                if (isArray(exclude)) {\n                    l--;\n                } else {\n                    exclude = [];\n                }\n                for (var i = 1; i < l; i++) {\n                    _merge(obj, arguments[i], exclude);\n                }\n                return obj; // Object\n            };\n        }());\n\n\n        function extender(supers) {\n            supers = supers || [];\n            var Base = declare({\n                instance: {\n                    constructor: function (value) {\n                        this._value = value;\n                    },\n\n                    value: function () {\n                        return this._value;\n                    },\n\n                    eq: function eq(val) {\n                        return this[\"__extender__\"](this._value === val);\n                    },\n\n                    neq: function neq(other) {\n                        return this[\"__extender__\"](this._value !== other);\n                    },\n                    print: function () {\n                        console.log(this._value);\n                        return this;\n                    }\n                }\n            }), defined = [];\n\n            function addMethod(proto, name, func) {\n                if (\"function\" !== typeof func) {\n                    throw new TypeError(\"when extending type you must provide a function\");\n                }\n                var extendedMethod;\n                if (name === \"constructor\") {\n                    extendedMethod = function () {\n                        this._super(arguments);\n                        func.apply(this, arguments);\n                    };\n                } else {\n                    extendedMethod = function extendedMethod() {\n                        var args = slice.call(arguments);\n                        args.unshift(this._value);\n                        var ret = func.apply(this, args);\n                        return ret !== undef ? this[\"__extender__\"](ret) : this;\n                    };\n                }\n                proto[name] = extendedMethod;\n            }\n\n            function addNoWrapMethod(proto, name, func) {\n                if (\"function\" !== typeof func) {\n                    throw new TypeError(\"when extending type you must provide a function\");\n                }\n                var extendedMethod;\n                if (name === \"constructor\") {\n                    extendedMethod = function () {\n                        this._super(arguments);\n                        func.apply(this, arguments);\n                    };\n                } else {\n                    extendedMethod = function extendedMethod() {\n                        var args = slice.call(arguments);\n                        args.unshift(this._value);\n                        return func.apply(this, args);\n                    };\n                }\n                proto[name] = extendedMethod;\n            }\n\n            function decorateProto(proto, decoration, nowrap) {\n                for (var i in decoration) {\n                    if (decoration.hasOwnProperty(i)) {\n                        if (i !== \"getters\" && i !== \"setters\") {\n                            if (i === \"noWrap\") {\n                                decorateProto(proto, decoration[i], true);\n                            } else if (nowrap) {\n                                addNoWrapMethod(proto, i, decoration[i]);\n                            } else {\n                                addMethod(proto, i, decoration[i]);\n                            }\n                        } else {\n                            proto[i] = decoration[i];\n                        }\n                    }\n                }\n            }\n\n            function _extender(obj) {\n                var ret = obj, i, l;\n                if (!(obj instanceof Base)) {\n                    var OurBase = Base;\n                    for (i = 0, l = defined.length; i < l; i++) {\n                        var definer = defined[i];\n                        if (definer[0](obj)) {\n                            OurBase = OurBase.extend({instance: definer[1]});\n                        }\n                    }\n                    ret = new OurBase(obj);\n                    ret[\"__extender__\"] = _extender;\n                }\n                return ret;\n            }\n\n            function always() {\n                return true;\n            }\n\n            function define(tester, decorate) {\n                if (arguments.length) {\n                    if (typeof tester === \"object\") {\n                        decorate = tester;\n                        tester = always;\n                    }\n                    decorate = decorate || {};\n                    var proto = {};\n                    decorateProto(proto, decorate);\n                    //handle browsers like which skip over the constructor while looping\n                    if (!proto.hasOwnProperty(\"constructor\")) {\n                        if (decorate.hasOwnProperty(\"constructor\")) {\n                            addMethod(proto, \"constructor\", decorate.constructor);\n                        } else {\n                            proto.constructor = function () {\n                                this._super(arguments);\n                            };\n                        }\n                    }\n                    defined.push([tester, proto]);\n                }\n                return _extender;\n            }\n\n            function extend(supr) {\n                if (supr && supr.hasOwnProperty(\"__defined__\")) {\n                    _extender[\"__defined__\"] = defined = defined.concat(supr[\"__defined__\"]);\n                }\n                merge(_extender, supr, [\"define\", \"extend\", \"expose\", \"__defined__\"]);\n                return _extender;\n            }\n\n            _extender.define = define;\n            _extender.extend = extend;\n            _extender.expose = function expose() {\n                var methods;\n                for (var i = 0, l = arguments.length; i < l; i++) {\n                    methods = arguments[i];\n                    if (typeof methods === \"object\") {\n                        merge(_extender, methods, [\"define\", \"extend\", \"expose\", \"__defined__\"]);\n                    }\n                }\n                return _extender;\n            };\n            _extender[\"__defined__\"] = defined;\n\n\n            return _extender;\n        }\n\n        return {\n            define: function () {\n                return extender().define.apply(extender, arguments);\n            },\n\n            extend: function (supr) {\n                return extender().define().extend(supr);\n            }\n        };\n\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineExtender(require(\"declare.js\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"declare\"], function (declare) {\n            return defineExtender(declare);\n        });\n    } else {\n        this.extender = defineExtender(this.declare);\n    }\n\n}).call(this);\n},{\"declare.js\":55}],58:[function(require,module,exports){\nmodule.exports = require(\"./extender.js\");\n},{\"./extender.js\":57}],59:[function(require,module,exports){\n(function () {\n    \"use strict\";\n\n    function defineFunction(extended, is, args) {\n\n        var isArray = is.isArray,\n            isObject = is.isObject,\n            isString = is.isString,\n            isFunction = is.isFunction,\n            argsToArray = args.argsToArray;\n\n        function spreadArgs(f, args, scope) {\n            var ret;\n            switch ((args || []).length) {\n            case 0:\n                ret = f.call(scope);\n                break;\n            case 1:\n                ret = f.call(scope, args[0]);\n                break;\n            case 2:\n                ret = f.call(scope, args[0], args[1]);\n                break;\n            case 3:\n                ret = f.call(scope, args[0], args[1], args[2]);\n                break;\n            default:\n                ret = f.apply(scope, args);\n            }\n            return ret;\n        }\n\n        function hitch(scope, method, args) {\n            args = argsToArray(arguments, 2);\n            if ((isString(method) && !(method in scope))) {\n                throw new Error(method + \" property not defined in scope\");\n            } else if (!isString(method) && !isFunction(method)) {\n                throw new Error(method + \" is not a function\");\n            }\n            if (isString(method)) {\n                return function () {\n                    var func = scope[method];\n                    if (isFunction(func)) {\n                        return spreadArgs(func, args.concat(argsToArray(arguments)), scope);\n                    } else {\n                        return func;\n                    }\n                };\n            } else {\n                if (args.length) {\n                    return function () {\n                        return spreadArgs(method, args.concat(argsToArray(arguments)), scope);\n                    };\n                } else {\n\n                    return function () {\n                        return spreadArgs(method, arguments, scope);\n                    };\n                }\n            }\n        }\n\n\n        function applyFirst(method, args) {\n            args = argsToArray(arguments, 1);\n            if (!isString(method) && !isFunction(method)) {\n                throw new Error(method + \" must be the name of a property or function to execute\");\n            }\n            if (isString(method)) {\n                return function () {\n                    var scopeArgs = argsToArray(arguments), scope = scopeArgs.shift();\n                    var func = scope[method];\n                    if (isFunction(func)) {\n                        scopeArgs = args.concat(scopeArgs);\n                        return spreadArgs(func, scopeArgs, scope);\n                    } else {\n                        return func;\n                    }\n                };\n            } else {\n                return function () {\n                    var scopeArgs = argsToArray(arguments), scope = scopeArgs.shift();\n                    scopeArgs = args.concat(scopeArgs);\n                    return spreadArgs(method, scopeArgs, scope);\n                };\n            }\n        }\n\n\n        function hitchIgnore(scope, method, args) {\n            args = argsToArray(arguments, 2);\n            if ((isString(method) && !(method in scope))) {\n                throw new Error(method + \" property not defined in scope\");\n            } else if (!isString(method) && !isFunction(method)) {\n                throw new Error(method + \" is not a function\");\n            }\n            if (isString(method)) {\n                return function () {\n                    var func = scope[method];\n                    if (isFunction(func)) {\n                        return spreadArgs(func, args, scope);\n                    } else {\n                        return func;\n                    }\n                };\n            } else {\n                return function () {\n                    return spreadArgs(method, args, scope);\n                };\n            }\n        }\n\n\n        function hitchAll(scope) {\n            var funcs = argsToArray(arguments, 1);\n            if (!isObject(scope) && !isFunction(scope)) {\n                throw new TypeError(\"scope must be an object\");\n            }\n            if (funcs.length === 1 && isArray(funcs[0])) {\n                funcs = funcs[0];\n            }\n            if (!funcs.length) {\n                funcs = [];\n                for (var k in scope) {\n                    if (scope.hasOwnProperty(k) && isFunction(scope[k])) {\n                        funcs.push(k);\n                    }\n                }\n            }\n            for (var i = 0, l = funcs.length; i < l; i++) {\n                scope[funcs[i]] = hitch(scope, scope[funcs[i]]);\n            }\n            return scope;\n        }\n\n\n        function partial(method, args) {\n            args = argsToArray(arguments, 1);\n            if (!isString(method) && !isFunction(method)) {\n                throw new Error(method + \" must be the name of a property or function to execute\");\n            }\n            if (isString(method)) {\n                return function () {\n                    var func = this[method];\n                    if (isFunction(func)) {\n                        var scopeArgs = args.concat(argsToArray(arguments));\n                        return spreadArgs(func, scopeArgs, this);\n                    } else {\n                        return func;\n                    }\n                };\n            } else {\n                return function () {\n                    var scopeArgs = args.concat(argsToArray(arguments));\n                    return spreadArgs(method, scopeArgs, this);\n                };\n            }\n        }\n\n        function curryFunc(f, execute) {\n            return function () {\n                var args = argsToArray(arguments);\n                return execute ? spreadArgs(f, arguments, this) : function () {\n                    return spreadArgs(f, args.concat(argsToArray(arguments)), this);\n                };\n            };\n        }\n\n\n        function curry(depth, cb, scope) {\n            var f;\n            if (scope) {\n                f = hitch(scope, cb);\n            } else {\n                f = cb;\n            }\n            if (depth) {\n                var len = depth - 1;\n                for (var i = len; i >= 0; i--) {\n                    f = curryFunc(f, i === len);\n                }\n            }\n            return f;\n        }\n\n        return extended\n            .define(isObject, {\n                bind: hitch,\n                bindAll: hitchAll,\n                bindIgnore: hitchIgnore,\n                curry: function (scope, depth, fn) {\n                    return curry(depth, fn, scope);\n                }\n            })\n            .define(isFunction, {\n                bind: function (fn, obj) {\n                    return spreadArgs(hitch, [obj, fn].concat(argsToArray(arguments, 2)), this);\n                },\n                bindIgnore: function (fn, obj) {\n                    return spreadArgs(hitchIgnore, [obj, fn].concat(argsToArray(arguments, 2)), this);\n                },\n                partial: partial,\n                applyFirst: applyFirst,\n                curry: function (fn, num, scope) {\n                    return curry(num, fn, scope);\n                },\n                noWrap: {\n                    f: function () {\n                        return this.value();\n                    }\n                }\n            })\n            .define(isString, {\n                bind: function (str, scope) {\n                    return hitch(scope, str);\n                },\n                bindIgnore: function (str, scope) {\n                    return hitchIgnore(scope, str);\n                },\n                partial: partial,\n                applyFirst: applyFirst,\n                curry: function (fn, depth, scope) {\n                    return curry(depth, fn, scope);\n                }\n            })\n            .expose({\n                bind: hitch,\n                bindAll: hitchAll,\n                bindIgnore: hitchIgnore,\n                partial: partial,\n                applyFirst: applyFirst,\n                curry: curry\n            });\n\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineFunction(require(\"extended\"), require(\"is-extended\"), require(\"arguments-extended\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extended\", \"is-extended\", \"arguments-extended\"], function (extended, is, args) {\n            return defineFunction(extended, is, args);\n        });\n    } else {\n        this.functionExtended = defineFunction(this.extended, this.isExtended, this.argumentsExtended);\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"arguments-extended\":51,\"extended\":56,\"is-extended\":66}],60:[function(require,module,exports){\nvar process=require(\"__browserify_process\");if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (typeof emitter._events[type] === 'function')\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n},{\"__browserify_process\":64}],61:[function(require,module,exports){\n// nothing to see here... no file methods for the browser\n\n},{}],62:[function(require,module,exports){\nvar process=require(\"__browserify_process\");function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\n\n},{\"__browserify_process\":64}],63:[function(require,module,exports){\nrequire=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error(\"Cannot find module '\"+r+\"'\")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!==\"undefined\"&&require,{1:[function(require,module,exports){\n// UTILITY\nvar util = require('util');\nvar Buffer = require(\"buffer\").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return '' + value;\n  }\n  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === 'function' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + ':', this.message].join(' ');\n  } else {\n    return [\n      this.name + ':',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(' ');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail('Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail('Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n},{\"util\":2,\"buffer\":3}],2:[function(require,module,exports){\nvar events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{\"events\":4}],5:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],6:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}],4:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})(require(\"__browserify_process\"))\n},{\"__browserify_process\":6}],\"buffer-browserify\":[function(require,module,exports){\nmodule.exports=require('q9TxCC');\n},{}],\"q9TxCC\":[function(require,module,exports){\nfunction SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require('assert');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n    case 'binary':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<SlowBuffer ' + out.join(' ') + '>';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nSlowBuffer.prototype.fill = function(value, start, end) {\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this.parent[i + this.offset] = subject.readUInt8(i);\n        }\n        else {\n          this.parent[i + this.offset] = subject[i];\n        }\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== 'number') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case 'hex':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case 'utf8':\n    case 'utf-8':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case 'ascii':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case 'binary':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case 'base64':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case 'ucs2':\n    case 'ucs-2':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  if (typeof start == 'undefined' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == 'undefined' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case 'hex':\n      return this.parent.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.parent.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.parent.asciiSlice(start, end);\n\n    case 'binary':\n      return this.parent.binarySlice(start, end);\n\n    case 'base64':\n      return this.parent.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error('oob');\n  if (start > end) throw new Error('oob');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString('utf8', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString('binary', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString('ascii', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, 'utf8');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, 'binary');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, 'ascii');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1];\n    }\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer.parent[buffer.offset + offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n},{\"assert\":1,\"./buffer_ieee754\":5,\"base64-js\":7}],7:[function(require,module,exports){\n(function (exports) {\n\t'use strict';\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow 'Invalid string. Length must be a multiple of 4';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf('=');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],8:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],3:[function(require,module,exports){\nfunction SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require('assert');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<SlowBuffer ' + out.join(' ') + '>';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== 'number') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case 'hex':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case 'utf8':\n    case 'utf-8':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case 'ascii':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case 'binary':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case 'base64':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case 'ucs2':\n    case 'ucs-2':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  if (typeof start == 'undefined' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == 'undefined' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case 'hex':\n      return this.parent.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.parent.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.parent.asciiSlice(start, end);\n\n    case 'binary':\n      return this.parent.binarySlice(start, end);\n\n    case 'base64':\n      return this.parent.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error('oob');\n  if (start > end) throw new Error('oob');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString('utf8', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString('binary', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString('ascii', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, 'utf8');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, 'binary');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, 'ascii');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n},{\"assert\":1,\"./buffer_ieee754\":8,\"base64-js\":9}],9:[function(require,module,exports){\n(function (exports) {\n\t'use strict';\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow 'Invalid string. Length must be a multiple of 4';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf('=');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}]},{},[])\n;;module.exports=require(\"buffer-browserify\")\n\n},{}],64:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}],65:[function(require,module,exports){\n(function () {\n    \"use strict\";\n\n    function defineHt(_) {\n\n\n        var hashFunction = function (key) {\n            if (typeof key === \"string\") {\n                return key;\n            } else if (typeof key === \"object\") {\n                return  key.hashCode ? key.hashCode() : \"\" + key;\n            } else {\n                return \"\" + key;\n            }\n        };\n\n        var Bucket = _.declare({\n\n            instance: {\n\n                constructor: function () {\n                    this.__entries = [];\n                    this.__keys = [];\n                    this.__values = [];\n                },\n\n                pushValue: function (key, value) {\n                    this.__keys.push(key);\n                    this.__values.push(value);\n                    this.__entries.push({key: key, value: value});\n                    return value;\n                },\n\n                remove: function (key) {\n                    var ret = null, map = this.__entries, val, keys = this.__keys, vals = this.__values;\n                    var i = map.length - 1;\n                    for (; i >= 0; i--) {\n                        if (!!(val = map[i]) && val.key === key) {\n                            map.splice(i, 1);\n                            keys.splice(i, 1);\n                            vals.splice(i, 1);\n                            return val.value;\n                        }\n                    }\n                    return ret;\n                },\n\n                \"set\": function (key, value) {\n                    var ret = null, map = this.__entries, vals = this.__values;\n                    var i = map.length - 1;\n                    for (; i >= 0; i--) {\n                        var val = map[i];\n                        if (val && key === val.key) {\n                            vals[i] = value;\n                            val.value = value;\n                            ret = value;\n                            break;\n                        }\n                    }\n                    if (!ret) {\n                        map.push({key: key, value: value});\n                    }\n                    return ret;\n                },\n\n                find: function (key) {\n                    var ret = null, map = this.__entries, val;\n                    var i = map.length - 1;\n                    for (; i >= 0; i--) {\n                        val = map[i];\n                        if (val && key === val.key) {\n                            ret = val.value;\n                            break;\n                        }\n                    }\n                    return ret;\n                },\n\n                getEntrySet: function () {\n                    return this.__entries;\n                },\n\n                getKeys: function () {\n                    return this.__keys;\n                },\n\n                getValues: function (arr) {\n                    return this.__values;\n                }\n            }\n        });\n\n        return _.declare({\n\n            instance: {\n\n                constructor: function () {\n                    this.__map = {};\n                },\n\n                entrySet: function () {\n                    var ret = [], map = this.__map;\n                    for (var i in map) {\n                        if (map.hasOwnProperty(i)) {\n                            ret = ret.concat(map[i].getEntrySet());\n                        }\n                    }\n                    return ret;\n                },\n\n                put: function (key, value) {\n                    var hash = hashFunction(key);\n                    var bucket = null;\n                    if (!(bucket = this.__map[hash])) {\n                        bucket = (this.__map[hash] = new Bucket());\n                    }\n                    bucket.pushValue(key, value);\n                    return value;\n                },\n\n                remove: function (key) {\n                    var hash = hashFunction(key), ret = null;\n                    var bucket = this.__map[hash];\n                    if (bucket) {\n                        ret = bucket.remove(key);\n                    }\n                    return ret;\n                },\n\n                \"get\": function (key) {\n                    var hash = hashFunction(key), ret = null, bucket;\n                    if (!!(bucket = this.__map[hash])) {\n                        ret = bucket.find(key);\n                    }\n                    return ret;\n                },\n\n                \"set\": function (key, value) {\n                    var hash = hashFunction(key), ret = null, bucket = null, map = this.__map;\n                    if (!!(bucket = map[hash])) {\n                        ret = bucket.set(key, value);\n                    } else {\n                        ret = (map[hash] = new Bucket()).pushValue(key, value);\n                    }\n                    return ret;\n                },\n\n                contains: function (key) {\n                    var hash = hashFunction(key), ret = false, bucket = null;\n                    if (!!(bucket = this.__map[hash])) {\n                        ret = !!(bucket.find(key));\n                    }\n                    return ret;\n                },\n\n                concat: function (hashTable) {\n                    if (hashTable instanceof this._static) {\n                        var ret = new this._static();\n                        var otherEntrySet = hashTable.entrySet().concat(this.entrySet());\n                        for (var i = otherEntrySet.length - 1; i >= 0; i--) {\n                            var e = otherEntrySet[i];\n                            ret.put(e.key, e.value);\n                        }\n                        return ret;\n                    } else {\n                        throw new TypeError(\"When joining hashtables the joining arg must be a HashTable\");\n                    }\n                },\n\n                filter: function (cb, scope) {\n                    var es = this.entrySet(), ret = new this._static();\n                    es = _.filter(es, cb, scope);\n                    for (var i = es.length - 1; i >= 0; i--) {\n                        var e = es[i];\n                        ret.put(e.key, e.value);\n                    }\n                    return ret;\n                },\n\n                forEach: function (cb, scope) {\n                    var es = this.entrySet();\n                    _.forEach(es, cb, scope);\n                },\n\n                every: function (cb, scope) {\n                    var es = this.entrySet();\n                    return _.every(es, cb, scope);\n                },\n\n                map: function (cb, scope) {\n                    var es = this.entrySet();\n                    return _.map(es, cb, scope);\n                },\n\n                some: function (cb, scope) {\n                    var es = this.entrySet();\n                    return _.some(es, cb, scope);\n                },\n\n                reduce: function (cb, scope) {\n                    var es = this.entrySet();\n                    return _.reduce(es, cb, scope);\n                },\n\n                reduceRight: function (cb, scope) {\n                    var es = this.entrySet();\n                    return _.reduceRight(es, cb, scope);\n                },\n\n                clear: function () {\n                    this.__map = {};\n                },\n\n                keys: function () {\n                    var ret = [], map = this.__map;\n                    for (var i in map) {\n                        //if (map.hasOwnProperty(i)) {\n                        ret = ret.concat(map[i].getKeys());\n                        //}\n                    }\n                    return ret;\n                },\n\n                values: function () {\n                    var ret = [], map = this.__map;\n                    for (var i in map) {\n                        //if (map.hasOwnProperty(i)) {\n                        ret = ret.concat(map[i].getValues());\n                        //}\n                    }\n                    return ret;\n                },\n\n                isEmpty: function () {\n                    return this.keys().length === 0;\n                }\n            }\n\n        });\n\n\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineHt(require(\"extended\")().register(\"declare\", require(\"declare.js\")).register(require(\"is-extended\")).register(require(\"array-extended\")));\n\n        }\n    } else if (\"function\" === typeof define) {\n        define([\"extended\", \"declare\", \"is-extended\", \"array-extended\"], function (extended, declare, is, array) {\n            return defineHt(extended().register(\"declare\", declare).register(is).register(array));\n        });\n    } else {\n        this.Ht = defineHt(this.extended().register(\"declare\", this.declare).register(this.isExtended).register(this.arrayExtended));\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"array-extended\":52,\"declare.js\":55,\"extended\":56,\"is-extended\":66}],66:[function(require,module,exports){\nvar Buffer=require(\"__browserify_Buffer\").Buffer;(function () {\n    \"use strict\";\n\n    function defineIsa(extended) {\n\n        var pSlice = Array.prototype.slice;\n\n        var hasOwn = Object.prototype.hasOwnProperty;\n        var toStr = Object.prototype.toString;\n\n        function argsToArray(args, slice) {\n            var i = -1, j = 0, l = args.length, ret = [];\n            slice = slice || 0;\n            i += slice;\n            while (++i < l) {\n                ret[j++] = args[i];\n            }\n            return ret;\n        }\n\n        function keys(obj) {\n            var ret = [];\n            for (var i in obj) {\n                if (hasOwn.call(obj, i)) {\n                    ret.push(i);\n                }\n            }\n            return ret;\n        }\n\n        //taken from node js assert.js\n        //https://github.com/joyent/node/blob/master/lib/assert.js\n        function deepEqual(actual, expected) {\n            // 7.1. All identical values are equivalent, as determined by ===.\n            if (actual === expected) {\n                return true;\n\n            } else if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n                if (actual.length !== expected.length) {\n                    return false;\n                }\n                for (var i = 0; i < actual.length; i++) {\n                    if (actual[i] !== expected[i]) {\n                        return false;\n                    }\n                }\n                return true;\n\n                // 7.2. If the expected value is a Date object, the actual value is\n                // equivalent if it is also a Date object that refers to the same time.\n            } else if (isDate(actual) && isDate(expected)) {\n                return actual.getTime() === expected.getTime();\n\n                // 7.3 If the expected value is a RegExp object, the actual value is\n                // equivalent if it is also a RegExp object with the same source and\n                // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n            } else if (isRegExp(actual) && isRegExp(expected)) {\n                return actual.source === expected.source &&\n                    actual.global === expected.global &&\n                    actual.multiline === expected.multiline &&\n                    actual.lastIndex === expected.lastIndex &&\n                    actual.ignoreCase === expected.ignoreCase;\n\n                // 7.4. Other pairs that do not both pass typeof value == 'object',\n                // equivalence is determined by ==.\n            } else if (isString(actual) && isString(expected) && actual !== expected) {\n                return false;\n            } else if (typeof actual !== 'object' && typeof expected !== 'object') {\n                return actual === expected;\n\n                // 7.5 For all other Object pairs, including Array objects, equivalence is\n                // determined by having the same number of owned properties (as verified\n                // with Object.prototype.hasOwnProperty.call), the same set of keys\n                // (although not necessarily the same order), equivalent values for every\n                // corresponding key, and an identical 'prototype' property. Note: this\n                // accounts for both named and indexed properties on Arrays.\n            } else {\n                return objEquiv(actual, expected);\n            }\n        }\n\n\n        function objEquiv(a, b) {\n            var key;\n            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {\n                return false;\n            }\n            // an identical 'prototype' property.\n            if (a.prototype !== b.prototype) {\n                return false;\n            }\n            //~~~I've managed to break Object.keys through screwy arguments passing.\n            //   Converting to array solves the problem.\n            if (isArguments(a)) {\n                if (!isArguments(b)) {\n                    return false;\n                }\n                a = pSlice.call(a);\n                b = pSlice.call(b);\n                return deepEqual(a, b);\n            }\n            try {\n                var ka = keys(a),\n                    kb = keys(b),\n                    i;\n                // having the same number of owned properties (keys incorporates\n                // hasOwnProperty)\n                if (ka.length !== kb.length) {\n                    return false;\n                }\n                //the same set of keys (although not necessarily the same order),\n                ka.sort();\n                kb.sort();\n                //~~~cheap key test\n                for (i = ka.length - 1; i >= 0; i--) {\n                    if (ka[i] !== kb[i]) {\n                        return false;\n                    }\n                }\n                //equivalent values for every corresponding key, and\n                //~~~possibly expensive deep test\n                for (i = ka.length - 1; i >= 0; i--) {\n                    key = ka[i];\n                    if (!deepEqual(a[key], b[key])) {\n                        return false;\n                    }\n                }\n            } catch (e) {//happens when one is a string literal and the other isn't\n                return false;\n            }\n            return true;\n        }\n\n\n        var isFunction = function (obj) {\n            return toStr.call(obj) === '[object Function]';\n        };\n\n        //ie hack\n        if (\"undefined\" !== typeof window && !isFunction(window.alert)) {\n            (function (alert) {\n                isFunction = function (obj) {\n                    return toStr.call(obj) === '[object Function]' || obj === alert;\n                };\n            }(window.alert));\n        }\n\n        function isObject(obj) {\n            var undef;\n            return obj !== null && typeof obj === \"object\";\n        }\n\n        function isHash(obj) {\n            var ret = isObject(obj);\n            return ret && obj.constructor === Object && !obj.nodeType && !obj.setInterval;\n        }\n\n        function isEmpty(object) {\n            if (isArguments(object)) {\n                return object.length === 0;\n            } else if (isObject(object)) {\n                return keys(object).length === 0;\n            } else if (isString(object) || isArray(object)) {\n                return object.length === 0;\n            }\n            return true;\n        }\n\n        function isBoolean(obj) {\n            return obj === true || obj === false || toStr.call(obj) === \"[object Boolean]\";\n        }\n\n        function isUndefined(obj) {\n            return typeof obj === 'undefined';\n        }\n\n        function isDefined(obj) {\n            return !isUndefined(obj);\n        }\n\n        function isUndefinedOrNull(obj) {\n            return isUndefined(obj) || isNull(obj);\n        }\n\n        function isNull(obj) {\n            return obj === null;\n        }\n\n\n        var isArguments = function _isArguments(object) {\n            return toStr.call(object) === '[object Arguments]';\n        };\n\n        if (!isArguments(arguments)) {\n            isArguments = function _isArguments(obj) {\n                return !!(obj && hasOwn.call(obj, \"callee\"));\n            };\n        }\n\n\n        function isInstanceOf(obj, clazz) {\n            if (isFunction(clazz)) {\n                return obj instanceof clazz;\n            } else {\n                return false;\n            }\n        }\n\n        function isRegExp(obj) {\n            return toStr.call(obj) === '[object RegExp]';\n        }\n\n        var isArray = Array.isArray || function isArray(obj) {\n            return toStr.call(obj) === \"[object Array]\";\n        };\n\n        function isDate(obj) {\n            return toStr.call(obj) === '[object Date]';\n        }\n\n        function isString(obj) {\n            return toStr.call(obj) === '[object String]';\n        }\n\n        function isNumber(obj) {\n            return toStr.call(obj) === '[object Number]';\n        }\n\n        function isTrue(obj) {\n            return obj === true;\n        }\n\n        function isFalse(obj) {\n            return obj === false;\n        }\n\n        function isNotNull(obj) {\n            return !isNull(obj);\n        }\n\n        function isEq(obj, obj2) {\n            /*jshint eqeqeq:false*/\n            return obj == obj2;\n        }\n\n        function isNeq(obj, obj2) {\n            /*jshint eqeqeq:false*/\n            return obj != obj2;\n        }\n\n        function isSeq(obj, obj2) {\n            return obj === obj2;\n        }\n\n        function isSneq(obj, obj2) {\n            return obj !== obj2;\n        }\n\n        function isIn(obj, arr) {\n            if ((isArray(arr) && Array.prototype.indexOf) || isString(arr)) {\n                return arr.indexOf(obj) > -1;\n            } else if (isArray(arr)) {\n                for (var i = 0, l = arr.length; i < l; i++) {\n                    if (isEq(obj, arr[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        function isNotIn(obj, arr) {\n            return !isIn(obj, arr);\n        }\n\n        function isLt(obj, obj2) {\n            return obj < obj2;\n        }\n\n        function isLte(obj, obj2) {\n            return obj <= obj2;\n        }\n\n        function isGt(obj, obj2) {\n            return obj > obj2;\n        }\n\n        function isGte(obj, obj2) {\n            return obj >= obj2;\n        }\n\n        function isLike(obj, reg) {\n            if (isString(reg)) {\n                return (\"\" + obj).match(reg) !== null;\n            } else if (isRegExp(reg)) {\n                return reg.test(obj);\n            }\n            return false;\n        }\n\n        function isNotLike(obj, reg) {\n            return !isLike(obj, reg);\n        }\n\n        function contains(arr, obj) {\n            return isIn(obj, arr);\n        }\n\n        function notContains(arr, obj) {\n            return !isIn(obj, arr);\n        }\n\n        function containsAt(arr, obj, index) {\n            if (isArray(arr) && arr.length > index) {\n                return isEq(arr[index], obj);\n            }\n            return false;\n        }\n\n        function notContainsAt(arr, obj, index) {\n            if (isArray(arr)) {\n                return !isEq(arr[index], obj);\n            }\n            return false;\n        }\n\n        function has(obj, prop) {\n            return hasOwn.call(obj, prop);\n        }\n\n        function notHas(obj, prop) {\n            return !has(obj, prop);\n        }\n\n        function length(obj, l) {\n            if (has(obj, \"length\")) {\n                return obj.length === l;\n            }\n            return false;\n        }\n\n        function notLength(obj, l) {\n            if (has(obj, \"length\")) {\n                return obj.length !== l;\n            }\n            return false;\n        }\n\n        var isa = {\n            isFunction: isFunction,\n            isObject: isObject,\n            isEmpty: isEmpty,\n            isHash: isHash,\n            isNumber: isNumber,\n            isString: isString,\n            isDate: isDate,\n            isArray: isArray,\n            isBoolean: isBoolean,\n            isUndefined: isUndefined,\n            isDefined: isDefined,\n            isUndefinedOrNull: isUndefinedOrNull,\n            isNull: isNull,\n            isArguments: isArguments,\n            instanceOf: isInstanceOf,\n            isRegExp: isRegExp,\n            deepEqual: deepEqual,\n            isTrue: isTrue,\n            isFalse: isFalse,\n            isNotNull: isNotNull,\n            isEq: isEq,\n            isNeq: isNeq,\n            isSeq: isSeq,\n            isSneq: isSneq,\n            isIn: isIn,\n            isNotIn: isNotIn,\n            isLt: isLt,\n            isLte: isLte,\n            isGt: isGt,\n            isGte: isGte,\n            isLike: isLike,\n            isNotLike: isNotLike,\n            contains: contains,\n            notContains: notContains,\n            has: has,\n            notHas: notHas,\n            isLength: length,\n            isNotLength: notLength,\n            containsAt: containsAt,\n            notContainsAt: notContainsAt\n        };\n\n        var tester = {\n            constructor: function () {\n                this._testers = [];\n            },\n\n            noWrap: {\n                tester: function () {\n                    var testers = this._testers;\n                    return function tester(value) {\n                        var isa = false;\n                        for (var i = 0, l = testers.length; i < l && !isa; i++) {\n                            isa = testers[i](value);\n                        }\n                        return isa;\n                    };\n                }\n            }\n        };\n\n        var switcher = {\n            constructor: function () {\n                this._cases = [];\n                this.__default = null;\n            },\n\n            def: function (val, fn) {\n                this.__default = fn;\n            },\n\n            noWrap: {\n                switcher: function () {\n                    var testers = this._cases, __default = this.__default;\n                    return function tester() {\n                        var handled = false, args = argsToArray(arguments), caseRet;\n                        for (var i = 0, l = testers.length; i < l && !handled; i++) {\n                            caseRet = testers[i](args);\n                            if (caseRet.length > 1) {\n                                if (caseRet[1] || caseRet[0]) {\n                                    return caseRet[1];\n                                }\n                            }\n                        }\n                        if (!handled && __default) {\n                            return  __default.apply(this, args);\n                        }\n                    };\n                }\n            }\n        };\n\n        function addToTester(func) {\n            tester[func] = function isaTester() {\n                this._testers.push(isa[func]);\n            };\n        }\n\n        function addToSwitcher(func) {\n            switcher[func] = function isaTester() {\n                var args = argsToArray(arguments, 1), isFunc = isa[func], handler, doBreak = true;\n                if (args.length <= isFunc.length - 1) {\n                    throw new TypeError(\"A handler must be defined when calling using switch\");\n                } else {\n                    handler = args.pop();\n                    if (isBoolean(handler)) {\n                        doBreak = handler;\n                        handler = args.pop();\n                    }\n                }\n                if (!isFunction(handler)) {\n                    throw new TypeError(\"handler must be defined\");\n                }\n                this._cases.push(function (testArgs) {\n                    if (isFunc.apply(isa, testArgs.concat(args))) {\n                        return [doBreak, handler.apply(this, testArgs)];\n                    }\n                    return [false];\n                });\n            };\n        }\n\n        for (var i in isa) {\n            if (hasOwn.call(isa, i)) {\n                addToSwitcher(i);\n                addToTester(i);\n            }\n        }\n\n        var is = extended.define(isa).expose(isa);\n        is.tester = extended.define(tester);\n        is.switcher = extended.define(switcher);\n        return is;\n\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineIsa(require(\"extended\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extended\"], function (extended) {\n            return defineIsa(extended);\n        });\n    } else {\n        this.isExtended = defineIsa(this.extended);\n    }\n\n}).call(this);\n\n\n},{\"__browserify_Buffer\":63,\"extended\":56}],67:[function(require,module,exports){\n(function () {\n    \"use strict\";\n\n    function defineLeafy(_) {\n\n        function compare(a, b) {\n            var ret = 0;\n            if (a > b) {\n                return 1;\n            } else if (a < b) {\n                return -1;\n            } else if (!b) {\n                return 1;\n            }\n            return ret;\n        }\n\n        var multiply = _.multiply;\n\n        var Tree = _.declare({\n\n            instance: {\n\n                /**\n                 * Prints a node\n                 * @param node node to print\n                 * @param level the current level the node is at, Used for formatting\n                 */\n                __printNode: function (node, level) {\n                    //console.log(level);\n                    var str = [];\n                    if (_.isUndefinedOrNull(node)) {\n                        str.push(multiply('\\t', level));\n                        str.push(\"~\");\n                        console.log(str.join(\"\"));\n                    } else {\n                        this.__printNode(node.right, level + 1);\n                        str.push(multiply('\\t', level));\n                        str.push(node.data + \"\\n\");\n                        console.log(str.join(\"\"));\n                        this.__printNode(node.left, level + 1);\n                    }\n                },\n\n                constructor: function (options) {\n                    options = options || {};\n                    this.compare = options.compare || compare;\n                    this.__root = null;\n                },\n\n                insert: function () {\n                    throw new Error(\"Not Implemented\");\n                },\n\n                remove: function () {\n                    throw new Error(\"Not Implemented\");\n                },\n\n                clear: function () {\n                    this.__root = null;\n                },\n\n                isEmpty: function () {\n                    return !(this.__root);\n                },\n\n                traverseWithCondition: function (node, order, callback) {\n                    var cont = true;\n                    if (node) {\n                        order = order || Tree.PRE_ORDER;\n                        if (order === Tree.PRE_ORDER) {\n                            cont = callback(node.data);\n                            if (cont) {\n                                cont = this.traverseWithCondition(node.left, order, callback);\n                                if (cont) {\n                                    cont = this.traverseWithCondition(node.right, order, callback);\n                                }\n\n                            }\n                        } else if (order === Tree.IN_ORDER) {\n                            cont = this.traverseWithCondition(node.left, order, callback);\n                            if (cont) {\n                                cont = callback(node.data);\n                                if (cont) {\n                                    cont = this.traverseWithCondition(node.right, order, callback);\n                                }\n                            }\n                        } else if (order === Tree.POST_ORDER) {\n                            cont = this.traverseWithCondition(node.left, order, callback);\n                            if (cont) {\n                                if (cont) {\n                                    cont = this.traverseWithCondition(node.right, order, callback);\n                                }\n                                if (cont) {\n                                    cont = callback(node.data);\n                                }\n                            }\n                        } else if (order === Tree.REVERSE_ORDER) {\n                            cont = this.traverseWithCondition(node.right, order, callback);\n                            if (cont) {\n                                cont = callback(node.data);\n                                if (cont) {\n                                    cont = this.traverseWithCondition(node.left, order, callback);\n                                }\n                            }\n                        }\n                    }\n                    return cont;\n                },\n\n                traverse: function (node, order, callback) {\n                    if (node) {\n                        order = order || Tree.PRE_ORDER;\n                        if (order === Tree.PRE_ORDER) {\n                            callback(node.data);\n                            this.traverse(node.left, order, callback);\n                            this.traverse(node.right, order, callback);\n                        } else if (order === Tree.IN_ORDER) {\n                            this.traverse(node.left, order, callback);\n                            callback(node.data);\n                            this.traverse(node.right, order, callback);\n                        } else if (order === Tree.POST_ORDER) {\n                            this.traverse(node.left, order, callback);\n                            this.traverse(node.right, order, callback);\n                            callback(node.data);\n                        } else if (order === Tree.REVERSE_ORDER) {\n                            this.traverse(node.right, order, callback);\n                            callback(node.data);\n                            this.traverse(node.left, order, callback);\n\n                        }\n                    }\n                },\n\n                forEach: function (cb, scope, order) {\n                    if (typeof cb !== \"function\") {\n                        throw new TypeError();\n                    }\n                    order = order || Tree.IN_ORDER;\n                    scope = scope || this;\n                    this.traverse(this.__root, order, function (node) {\n                        cb.call(scope, node, this);\n                    });\n                },\n\n                map: function (cb, scope, order) {\n                    if (typeof cb !== \"function\") {\n                        throw new TypeError();\n                    }\n\n                    order = order || Tree.IN_ORDER;\n                    scope = scope || this;\n                    var ret = new this._static();\n                    this.traverse(this.__root, order, function (node) {\n                        ret.insert(cb.call(scope, node, this));\n                    });\n                    return ret;\n                },\n\n                filter: function (cb, scope, order) {\n                    if (typeof cb !== \"function\") {\n                        throw new TypeError();\n                    }\n\n                    order = order || Tree.IN_ORDER;\n                    scope = scope || this;\n                    var ret = new this._static();\n                    this.traverse(this.__root, order, function (node) {\n                        if (cb.call(scope, node, this)) {\n                            ret.insert(node);\n                        }\n                    });\n                    return ret;\n                },\n\n                reduce: function (fun, accumulator, order) {\n                    var arr = this.toArray(order);\n                    var args = [arr, fun];\n                    if (!_.isUndefinedOrNull(accumulator)) {\n                        args.push(accumulator);\n                    }\n                    return _.reduce.apply(_, args);\n                },\n\n                reduceRight: function (fun, accumulator, order) {\n                    var arr = this.toArray(order);\n                    var args = [arr, fun];\n                    if (!_.isUndefinedOrNull(accumulator)) {\n                        args.push(accumulator);\n                    }\n                    return _.reduceRight.apply(_, args);\n                },\n\n                every: function (cb, scope, order) {\n                    if (typeof cb !== \"function\") {\n                        throw new TypeError();\n                    }\n                    order = order || Tree.IN_ORDER;\n                    scope = scope || this;\n                    var ret = false;\n                    this.traverseWithCondition(this.__root, order, function (node) {\n                        ret = cb.call(scope, node, this);\n                        return ret;\n                    });\n                    return ret;\n                },\n\n                some: function (cb, scope, order) {\n                    if (typeof cb !== \"function\") {\n                        throw new TypeError();\n                    }\n\n                    order = order || Tree.IN_ORDER;\n                    scope = scope || this;\n                    var ret;\n                    this.traverseWithCondition(this.__root, order, function (node) {\n                        ret = cb.call(scope, node, this);\n                        return !ret;\n                    });\n                    return ret;\n                },\n\n                toArray: function (order) {\n                    order = order || Tree.IN_ORDER;\n                    var arr = [];\n                    this.traverse(this.__root, order, function (node) {\n                        arr.push(node);\n                    });\n                    return arr;\n                },\n\n                contains: function (value) {\n                    var ret = false;\n                    var root = this.__root;\n                    while (root !== null) {\n                        var cmp = this.compare(value, root.data);\n                        if (cmp) {\n                            root = root[(cmp === -1) ? \"left\" : \"right\"];\n                        } else {\n                            ret = true;\n                            root = null;\n                        }\n                    }\n                    return ret;\n                },\n\n                find: function (value) {\n                    var ret;\n                    var root = this.__root;\n                    while (root) {\n                        var cmp = this.compare(value, root.data);\n                        if (cmp) {\n                            root = root[(cmp === -1) ? \"left\" : \"right\"];\n                        } else {\n                            ret = root.data;\n                            break;\n                        }\n                    }\n                    return ret;\n                },\n\n                findLessThan: function (value, exclusive) {\n                    //find a better way!!!!\n                    var ret = [], compare = this.compare;\n                    this.traverseWithCondition(this.__root, Tree.IN_ORDER, function (v) {\n                        var cmp = compare(value, v);\n                        if ((!exclusive && cmp === 0) || cmp === 1) {\n                            ret.push(v);\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    });\n                    return ret;\n                },\n\n                findGreaterThan: function (value, exclusive) {\n                    //find a better way!!!!\n                    var ret = [], compare = this.compare;\n                    this.traverse(this.__root, Tree.REVERSE_ORDER, function (v) {\n                        var cmp = compare(value, v);\n                        if ((!exclusive && cmp === 0) || cmp === -1) {\n                            ret.push(v);\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    });\n                    return ret;\n                },\n\n                print: function () {\n                    this.__printNode(this.__root, 0);\n                }\n            },\n\n            \"static\": {\n                PRE_ORDER: \"pre_order\",\n                IN_ORDER: \"in_order\",\n                POST_ORDER: \"post_order\",\n                REVERSE_ORDER: \"reverse_order\"\n            }\n        });\n\n        var AVLTree = (function () {\n            var abs = Math.abs;\n\n\n            var makeNode = function (data) {\n                return {\n                    data: data,\n                    balance: 0,\n                    left: null,\n                    right: null\n                };\n            };\n\n            var rotateSingle = function (root, dir, otherDir) {\n                var save = root[otherDir];\n                root[otherDir] = save[dir];\n                save[dir] = root;\n                return save;\n            };\n\n\n            var rotateDouble = function (root, dir, otherDir) {\n                root[otherDir] = rotateSingle(root[otherDir], otherDir, dir);\n                return rotateSingle(root, dir, otherDir);\n            };\n\n            var adjustBalance = function (root, dir, bal) {\n                var otherDir = dir === \"left\" ? \"right\" : \"left\";\n                var n = root[dir], nn = n[otherDir];\n                if (nn.balance === 0) {\n                    root.balance = n.balance = 0;\n                } else if (nn.balance === bal) {\n                    root.balance = -bal;\n                    n.balance = 0;\n                } else { /* nn.balance == -bal */\n                    root.balance = 0;\n                    n.balance = bal;\n                }\n                nn.balance = 0;\n            };\n\n            var insertAdjustBalance = function (root, dir) {\n                var otherDir = dir === \"left\" ? \"right\" : \"left\";\n\n                var n = root[dir];\n                var bal = dir === \"right\" ? -1 : +1;\n\n                if (n.balance === bal) {\n                    root.balance = n.balance = 0;\n                    root = rotateSingle(root, otherDir, dir);\n                } else {\n                    adjustBalance(root, dir, bal);\n                    root = rotateDouble(root, otherDir, dir);\n                }\n\n                return root;\n\n            };\n\n            var removeAdjustBalance = function (root, dir, done) {\n                var otherDir = dir === \"left\" ? \"right\" : \"left\";\n                var n = root[otherDir];\n                var bal = dir === \"right\" ? -1 : 1;\n                if (n.balance === -bal) {\n                    root.balance = n.balance = 0;\n                    root = rotateSingle(root, dir, otherDir);\n                } else if (n.balance === bal) {\n                    adjustBalance(root, otherDir, -bal);\n                    root = rotateDouble(root, dir, otherDir);\n                } else { /* n.balance == 0 */\n                    root.balance = -bal;\n                    n.balance = bal;\n                    root = rotateSingle(root, dir, otherDir);\n                    done.done = true;\n                }\n                return root;\n            };\n\n            function insert(tree, data, cmp) {\n                /* Empty tree case */\n                var root = tree.__root;\n                if (root === null || root === undefined) {\n                    tree.__root = makeNode(data);\n                } else {\n                    var it = root, upd = [], up = [], top = 0, dir;\n                    while (true) {\n                        dir = upd[top] = cmp(data, it.data) === -1 ? \"left\" : \"right\";\n                        up[top++] = it;\n                        if (!it[dir]) {\n                            it[dir] = makeNode(data);\n                            break;\n                        }\n                        it = it[dir];\n                    }\n                    if (!it[dir]) {\n                        return null;\n                    }\n                    while (--top >= 0) {\n                        up[top].balance += upd[top] === \"right\" ? -1 : 1;\n                        if (up[top].balance === 0) {\n                            break;\n                        } else if (abs(up[top].balance) > 1) {\n                            up[top] = insertAdjustBalance(up[top], upd[top]);\n                            if (top !== 0) {\n                                up[top - 1][upd[top - 1]] = up[top];\n                            } else {\n                                tree.__root = up[0];\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n\n            function remove(tree, data, cmp) {\n                var root = tree.__root;\n                if (root !== null && root !== undefined) {\n                    var it = root, top = 0, up = [], upd = [], done = {done: false}, dir, compare;\n                    while (true) {\n                        if (!it) {\n                            return;\n                        } else if ((compare = cmp(data, it.data)) === 0) {\n                            break;\n                        }\n                        dir = upd[top] = compare === -1 ? \"left\" : \"right\";\n                        up[top++] = it;\n                        it = it[dir];\n                    }\n                    var l = it.left, r = it.right;\n                    if (!l || !r) {\n                        dir = !l ? \"right\" : \"left\";\n                        if (top !== 0) {\n                            up[top - 1][upd[top - 1]] = it[dir];\n                        } else {\n                            tree.__root = it[dir];\n                        }\n                    } else {\n                        var heir = l;\n                        upd[top] = \"left\";\n                        up[top++] = it;\n                        while (heir.right) {\n                            upd[top] = \"right\";\n                            up[top++] = heir;\n                            heir = heir.right;\n                        }\n                        it.data = heir.data;\n                        up[top - 1][up[top - 1] === it ? \"left\" : \"right\"] = heir.left;\n                    }\n                    while (--top >= 0 && !done.done) {\n                        up[top].balance += upd[top] === \"left\" ? -1 : +1;\n                        if (abs(up[top].balance) === 1) {\n                            break;\n                        } else if (abs(up[top].balance) > 1) {\n                            up[top] = removeAdjustBalance(up[top], upd[top], done);\n                            if (top !== 0) {\n                                up[top - 1][upd[top - 1]] = up[top];\n                            } else {\n                                tree.__root = up[0];\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            return Tree.extend({\n                instance: {\n\n                    insert: function (data) {\n                        insert(this, data, this.compare);\n                    },\n\n\n                    remove: function (data) {\n                        remove(this, data, this.compare);\n                    },\n\n                    __printNode: function (node, level) {\n                        var str = [];\n                        if (!node) {\n                            str.push(multiply('\\t', level));\n                            str.push(\"~\");\n                            console.log(str.join(\"\"));\n                        } else {\n                            this.__printNode(node.right, level + 1);\n                            str.push(multiply('\\t', level));\n                            str.push(node.data + \":\" + node.balance + \"\\n\");\n                            console.log(str.join(\"\"));\n                            this.__printNode(node.left, level + 1);\n                        }\n                    }\n\n                }\n            });\n        }());\n\n        var AnderssonTree = (function () {\n\n            var nil = {level: 0, data: null};\n\n            function makeNode(data, level) {\n                return {\n                    data: data,\n                    level: level,\n                    left: nil,\n                    right: nil\n                };\n            }\n\n            function skew(root) {\n                if (root.level !== 0 && root.left.level === root.level) {\n                    var save = root.left;\n                    root.left = save.right;\n                    save.right = root;\n                    root = save;\n                }\n                return root;\n            }\n\n            function split(root) {\n                if (root.level !== 0 && root.right.right.level === root.level) {\n                    var save = root.right;\n                    root.right = save.left;\n                    save.left = root;\n                    root = save;\n                    root.level++;\n                }\n                return root;\n            }\n\n            function insert(root, data, compare) {\n                if (root === nil) {\n                    root = makeNode(data, 1);\n                }\n                else {\n                    var dir = compare(data, root.data) === -1 ? \"left\" : \"right\";\n                    root[dir] = insert(root[dir], data, compare);\n                    root = skew(root);\n                    root = split(root);\n                }\n                return root;\n            }\n\n            var remove = function (root, data, compare) {\n                var rLeft, rRight;\n                if (root !== nil) {\n                    var cmp = compare(data, root.data);\n                    if (cmp === 0) {\n                        rLeft = root.left, rRight = root.right;\n                        if (rLeft !== nil && rRight !== nil) {\n                            var heir = rLeft;\n                            while (heir.right !== nil) {\n                                heir = heir.right;\n                            }\n                            root.data = heir.data;\n                            root.left = remove(rLeft, heir.data, compare);\n                        } else {\n                            root = root[rLeft === nil ? \"right\" : \"left\"];\n                        }\n                    } else {\n                        var dir = cmp === -1 ? \"left\" : \"right\";\n                        root[dir] = remove(root[dir], data, compare);\n                    }\n                }\n                if (root !== nil) {\n                    var rLevel = root.level;\n                    var rLeftLevel = root.left.level, rRightLevel = root.right.level;\n                    if (rLeftLevel < rLevel - 1 || rRightLevel < rLevel - 1) {\n                        if (rRightLevel > --root.level) {\n                            root.right.level = root.level;\n                        }\n                        root = skew(root);\n                        root = split(root);\n                    }\n                }\n                return root;\n            };\n\n            return Tree.extend({\n\n                instance: {\n\n                    isEmpty: function () {\n                        return this.__root === nil || this._super(arguments);\n                    },\n\n                    insert: function (data) {\n                        if (!this.__root) {\n                            this.__root = nil;\n                        }\n                        this.__root = insert(this.__root, data, this.compare);\n                    },\n\n                    remove: function (data) {\n                        this.__root = remove(this.__root, data, this.compare);\n                    },\n\n\n                    traverseWithCondition: function (node) {\n                        var cont = true;\n                        if (node !== nil) {\n                            return this._super(arguments);\n                        }\n                        return cont;\n                    },\n\n\n                    traverse: function (node) {\n                        if (node !== nil) {\n                            this._super(arguments);\n                        }\n                    },\n\n                    contains: function () {\n                        if (this.__root !== nil) {\n                            return this._super(arguments);\n                        }\n                        return false;\n                    },\n\n                    __printNode: function (node, level) {\n                        var str = [];\n                        if (!node || !node.data) {\n                            str.push(multiply('\\t', level));\n                            str.push(\"~\");\n                            console.log(str.join(\"\"));\n                        } else {\n                            this.__printNode(node.right, level + 1);\n                            str.push(multiply('\\t', level));\n                            str.push(node.data + \":\" + node.level + \"\\n\");\n                            console.log(str.join(\"\"));\n                            this.__printNode(node.left, level + 1);\n                        }\n                    }\n\n                }\n\n            });\n        }());\n\n        var BinaryTree = Tree.extend({\n            instance: {\n                insert: function (data) {\n                    if (!this.__root) {\n                        this.__root = {\n                            data: data,\n                            parent: null,\n                            left: null,\n                            right: null\n                        };\n                        return this.__root;\n                    }\n                    var compare = this.compare;\n                    var root = this.__root;\n                    while (root !== null) {\n                        var cmp = compare(data, root.data);\n                        if (cmp) {\n                            var leaf = (cmp === -1) ? \"left\" : \"right\";\n                            var next = root[leaf];\n                            if (!next) {\n                                return (root[leaf] = {data: data, parent: root, left: null, right: null});\n                            } else {\n                                root = next;\n                            }\n                        } else {\n                            return;\n                        }\n                    }\n                },\n\n                remove: function (data) {\n                    if (this.__root !== null) {\n                        var head = {right: this.__root}, it = head;\n                        var p, f = null;\n                        var dir = \"right\";\n                        while (it[dir] !== null) {\n                            p = it;\n                            it = it[dir];\n                            var cmp = this.compare(data, it.data);\n                            if (!cmp) {\n                                f = it;\n                            }\n                            dir = (cmp === -1 ? \"left\" : \"right\");\n                        }\n                        if (f !== null) {\n                            f.data = it.data;\n                            p[p.right === it ? \"right\" : \"left\"] = it[it.left === null ? \"right\" : \"left\"];\n                        }\n                        this.__root = head.right;\n                    }\n\n                }\n            }\n        });\n\n        var RedBlackTree = (function () {\n            var RED = \"RED\", BLACK = \"BLACK\";\n\n            var isRed = function (node) {\n                return node !== null && node.red;\n            };\n\n            var makeNode = function (data) {\n                return {\n                    data: data,\n                    red: true,\n                    left: null,\n                    right: null\n                };\n            };\n\n            var insert = function (root, data, compare) {\n                if (!root) {\n                    return makeNode(data);\n\n                } else {\n                    var cmp = compare(data, root.data);\n                    if (cmp) {\n                        var dir = cmp === -1 ? \"left\" : \"right\";\n                        var otherDir = dir === \"left\" ? \"right\" : \"left\";\n                        root[dir] = insert(root[dir], data, compare);\n                        var node = root[dir];\n\n                        if (isRed(node)) {\n\n                            var sibling = root[otherDir];\n                            if (isRed(sibling)) {\n                                /* Case 1 */\n                                root.red = true;\n                                node.red = false;\n                                sibling.red = false;\n                            } else {\n\n                                if (isRed(node[dir])) {\n\n                                    root = rotateSingle(root, otherDir);\n                                } else if (isRed(node[otherDir])) {\n\n                                    root = rotateDouble(root, otherDir);\n                                }\n                            }\n\n                        }\n                    }\n                }\n                return root;\n            };\n\n            var rotateSingle = function (root, dir) {\n                var otherDir = dir === \"left\" ? \"right\" : \"left\";\n                var save = root[otherDir];\n                root[otherDir] = save[dir];\n                save[dir] = root;\n                root.red = true;\n                save.red = false;\n                return save;\n            };\n\n            var rotateDouble = function (root, dir) {\n                var otherDir = dir === \"left\" ? \"right\" : \"left\";\n                root[otherDir] = rotateSingle(root[otherDir], otherDir);\n                return rotateSingle(root, dir);\n            };\n\n\n            var remove = function (root, data, done, compare) {\n                if (!root) {\n                    done.done = true;\n                } else {\n                    var dir;\n                    if (compare(data, root.data) === 0) {\n                        if (!root.left || !root.right) {\n                            var save = root[!root.left ? \"right\" : \"left\"];\n                            /* Case 0 */\n                            if (isRed(root)) {\n                                done.done = true;\n                            } else if (isRed(save)) {\n                                save.red = false;\n                                done.done = true;\n                            }\n                            return save;\n                        }\n                        else {\n                            var heir = root.right, p;\n                            while (heir.left !== null) {\n                                p = heir;\n                                heir = heir.left;\n                            }\n                            if (p) {\n                                p.left = null;\n                            }\n                            root.data = heir.data;\n                            data = heir.data;\n                        }\n                    }\n                    dir = compare(data, root.data) === -1 ? \"left\" : \"right\";\n                    root[dir] = remove(root[dir], data, done, compare);\n                    if (!done.done) {\n                        root = removeBalance(root, dir, done);\n                    }\n                }\n                return root;\n            };\n\n            var removeBalance = function (root, dir, done) {\n                var notDir = dir === \"left\" ? \"right\" : \"left\";\n                var p = root, s = p[notDir];\n                if (isRed(s)) {\n                    root = rotateSingle(root, dir);\n                    s = p[notDir];\n                }\n                if (s !== null) {\n                    if (!isRed(s.left) && !isRed(s.right)) {\n                        if (isRed(p)) {\n                            done.done = true;\n                        }\n                        p.red = 0;\n                        s.red = 1;\n                    } else {\n                        var save = p.red, newRoot = ( root === p );\n                        p = (isRed(s[notDir]) ? rotateSingle : rotateDouble)(p, dir);\n                        p.red = save;\n                        p.left.red = p.right.red = 0;\n                        if (newRoot) {\n                            root = p;\n                        } else {\n                            root[dir] = p;\n                        }\n                        done.done = true;\n                    }\n                }\n                return root;\n            };\n\n            return Tree.extend({\n                instance: {\n                    insert: function (data) {\n                        this.__root = insert(this.__root, data, this.compare);\n                        this.__root.red = false;\n                    },\n\n                    remove: function (data) {\n                        var done = {done: false};\n                        var root = remove(this.__root, data, done, this.compare);\n                        if (root !== null) {\n                            root.red = 0;\n                        }\n                        this.__root = root;\n                        return data;\n                    },\n\n\n                    __printNode: function (node, level) {\n                        var str = [];\n                        if (!node) {\n                            str.push(multiply('\\t', level));\n                            str.push(\"~\");\n                            console.log(str.join(\"\"));\n                        } else {\n                            this.__printNode(node.right, level + 1);\n                            str.push(multiply('\\t', level));\n                            str.push((node.red ? RED : BLACK) + \":\" + node.data + \"\\n\");\n                            console.log(str.join(\"\"));\n                            this.__printNode(node.left, level + 1);\n                        }\n                    }\n\n                }\n            });\n\n        }());\n\n\n        return {\n            Tree: Tree,\n            AVLTree: AVLTree,\n            AnderssonTree: AnderssonTree,\n            BinaryTree: BinaryTree,\n            RedBlackTree: RedBlackTree,\n            IN_ORDER: Tree.IN_ORDER,\n            PRE_ORDER: Tree.PRE_ORDER,\n            POST_ORDER: Tree.POST_ORDER,\n            REVERSE_ORDER: Tree.REVERSE_ORDER\n\n        };\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineLeafy(require(\"extended\")()\n                .register(\"declare\", require(\"declare.js\"))\n                .register(require(\"is-extended\"))\n                .register(require(\"array-extended\"))\n                .register(require(\"string-extended\"))\n            );\n\n        }\n    } else if (\"function\" === typeof define) {\n        define([\"extended\", \"declare.js\", \"is-extended\", \"array-extended\", \"string-extended\"], function (extended, declare, is, array, string) {\n            return defineLeafy(extended()\n                .register(\"declare\", declare)\n                .register(is)\n                .register(array)\n                .register(string)\n            );\n        });\n    } else {\n        this.leafy = defineLeafy(this.extended()\n            .register(\"declare\", this.declare)\n            .register(this.isExtended)\n            .register(this.arrayExtended)\n            .register(this.stringExtended));\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"array-extended\":52,\"declare.js\":55,\"extended\":56,\"is-extended\":66,\"string-extended\":70}],68:[function(require,module,exports){\n(function () {\n    \"use strict\";\n    /*global extended isExtended*/\n\n    function defineObject(extended, is, arr) {\n\n        var deepEqual = is.deepEqual,\n            isString = is.isString,\n            isHash = is.isHash,\n            difference = arr.difference,\n            hasOwn = Object.prototype.hasOwnProperty,\n            isFunction = is.isFunction;\n\n        function _merge(target, source) {\n            var name, s;\n            for (name in source) {\n                if (hasOwn.call(source, name)) {\n                    s = source[name];\n                    if (!(name in target) || (target[name] !== s)) {\n                        target[name] = s;\n                    }\n                }\n            }\n            return target;\n        }\n\n        function _deepMerge(target, source) {\n            var name, s, t;\n            for (name in source) {\n                if (hasOwn.call(source, name)) {\n                    s = source[name];\n                    t = target[name];\n                    if (!deepEqual(t, s)) {\n                        if (isHash(t) && isHash(s)) {\n                            target[name] = _deepMerge(t, s);\n                        } else if (isHash(s)) {\n                            target[name] = _deepMerge({}, s);\n                        } else {\n                            target[name] = s;\n                        }\n                    }\n                }\n            }\n            return target;\n        }\n\n\n        function merge(obj) {\n            if (!obj) {\n                obj = {};\n            }\n            for (var i = 1, l = arguments.length; i < l; i++) {\n                _merge(obj, arguments[i]);\n            }\n            return obj; // Object\n        }\n\n        function deepMerge(obj) {\n            if (!obj) {\n                obj = {};\n            }\n            for (var i = 1, l = arguments.length; i < l; i++) {\n                _deepMerge(obj, arguments[i]);\n            }\n            return obj; // Object\n        }\n\n\n        function extend(parent, child) {\n            var proto = parent.prototype || parent;\n            merge(proto, child);\n            return parent;\n        }\n\n        function forEach(hash, iterator, scope) {\n            if (!isHash(hash) || !isFunction(iterator)) {\n                throw new TypeError();\n            }\n            var objKeys = keys(hash), key;\n            for (var i = 0, len = objKeys.length; i < len; ++i) {\n                key = objKeys[i];\n                iterator.call(scope || hash, hash[key], key, hash);\n            }\n            return hash;\n        }\n\n        function filter(hash, iterator, scope) {\n            if (!isHash(hash) || !isFunction(iterator)) {\n                throw new TypeError();\n            }\n            var objKeys = keys(hash), key, value, ret = {};\n            for (var i = 0, len = objKeys.length; i < len; ++i) {\n                key = objKeys[i];\n                value = hash[key];\n                if (iterator.call(scope || hash, value, key, hash)) {\n                    ret[key] = value;\n                }\n            }\n            return ret;\n        }\n\n        function values(hash) {\n            if (!isHash(hash)) {\n                throw new TypeError();\n            }\n            var objKeys = keys(hash), ret = [];\n            for (var i = 0, len = objKeys.length; i < len; ++i) {\n                ret.push(hash[objKeys[i]]);\n            }\n            return ret;\n        }\n\n\n        function keys(hash) {\n            if (!isHash(hash)) {\n                throw new TypeError();\n            }\n            var ret = [];\n            for (var i in hash) {\n                if (hasOwn.call(hash, i)) {\n                    ret.push(i);\n                }\n            }\n            return ret;\n        }\n\n        function invert(hash) {\n            if (!isHash(hash)) {\n                throw new TypeError();\n            }\n            var objKeys = keys(hash), key, ret = {};\n            for (var i = 0, len = objKeys.length; i < len; ++i) {\n                key = objKeys[i];\n                ret[hash[key]] = key;\n            }\n            return ret;\n        }\n\n        function toArray(hash) {\n            if (!isHash(hash)) {\n                throw new TypeError();\n            }\n            var objKeys = keys(hash), key, ret = [];\n            for (var i = 0, len = objKeys.length; i < len; ++i) {\n                key = objKeys[i];\n                ret.push([key, hash[key]]);\n            }\n            return ret;\n        }\n\n        function omit(hash, omitted) {\n            if (!isHash(hash)) {\n                throw new TypeError();\n            }\n            if (isString(omitted)) {\n                omitted = [omitted];\n            }\n            var objKeys = difference(keys(hash), omitted), key, ret = {};\n            for (var i = 0, len = objKeys.length; i < len; ++i) {\n                key = objKeys[i];\n                ret[key] = hash[key];\n            }\n            return ret;\n        }\n\n        var hash = {\n            forEach: forEach,\n            filter: filter,\n            invert: invert,\n            values: values,\n            toArray: toArray,\n            keys: keys,\n            omit: omit\n        };\n\n\n        var obj = {\n            extend: extend,\n            merge: merge,\n            deepMerge: deepMerge,\n            omit: omit\n        };\n\n        var ret = extended.define(is.isObject, obj).define(isHash, hash).define(is.isFunction, {extend: extend}).expose({hash: hash}).expose(obj);\n        var orig = ret.extend;\n        ret.extend = function __extend() {\n            if (arguments.length === 1) {\n                return orig.extend.apply(ret, arguments);\n            } else {\n                extend.apply(null, arguments);\n            }\n        };\n        return ret;\n\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineObject(require(\"extended\"), require(\"is-extended\"), require(\"array-extended\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extended\", \"is-extended\", \"array-extended\"], function (extended, is, array) {\n            return defineObject(extended, is, array);\n        });\n    } else {\n        this.objectExtended = defineObject(this.extended, this.isExtended, this.arrayExtended);\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"array-extended\":52,\"extended\":56,\"is-extended\":66}],69:[function(require,module,exports){\nvar process=require(\"__browserify_process\");(function () {\n    \"use strict\";\n    /*global setImmediate, MessageChannel*/\n\n\n    function definePromise(declare, extended, array, is, fn, args) {\n\n        var forEach = array.forEach,\n            isUndefinedOrNull = is.isUndefinedOrNull,\n            isArray = is.isArray,\n            isFunction = is.isFunction,\n            isBoolean = is.isBoolean,\n            bind = fn.bind,\n            bindIgnore = fn.bindIgnore,\n            argsToArray = args.argsToArray;\n\n        function createHandler(fn, promise) {\n            return function _handler() {\n                try {\n                    when(fn.apply(null, arguments))\n                        .addCallback(promise)\n                        .addErrback(promise);\n                } catch (e) {\n                    promise.errback(e);\n                }\n            };\n        }\n\n        var nextTick;\n        if (typeof setImmediate === \"function\") {\n            // In IE10, or use https://github.com/NobleJS/setImmediate\n            if (typeof window !== \"undefined\") {\n                nextTick = setImmediate.bind(window);\n            } else {\n                nextTick = setImmediate;\n            }\n        } else if (typeof process !== \"undefined\") {\n            // node\n            nextTick = function (cb) {\n                process.nextTick(cb);\n            };\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // modern browsers\n            // http://www.nonblocking.io/2011/06/windownexttick.html\n            var channel = new MessageChannel();\n            // linked list of tasks (single, with head node)\n            var head = {}, tail = head;\n            channel.port1.onmessage = function () {\n                head = head.next;\n                var task = head.task;\n                delete head.task;\n                task();\n            };\n            nextTick = function (task) {\n                tail = tail.next = {task: task};\n                channel.port2.postMessage(0);\n            };\n        } else {\n            // old browsers\n            nextTick = function (task) {\n                setTimeout(task, 0);\n            };\n        }\n\n\n        //noinspection JSHint\n        var Promise = declare({\n            instance: {\n                __fired: false,\n\n                __results: null,\n\n                __error: null,\n\n                __errorCbs: null,\n\n                __cbs: null,\n\n                constructor: function () {\n                    this.__errorCbs = [];\n                    this.__cbs = [];\n                    fn.bindAll(this, [\"callback\", \"errback\", \"resolve\", \"classic\", \"__resolve\", \"addCallback\", \"addErrback\"]);\n                },\n\n                __resolve: function () {\n                    if (!this.__fired) {\n                        this.__fired = true;\n                        var cbs = this.__error ? this.__errorCbs : this.__cbs,\n                            len = cbs.length, i,\n                            results = this.__error || this.__results;\n                        for (i = 0; i < len; i++) {\n                            this.__callNextTick(cbs[i], results);\n                        }\n\n                    }\n                },\n\n                __callNextTick: function (cb, results) {\n                    nextTick(function () {\n                        cb.apply(this, results);\n                    });\n                },\n\n                addCallback: function (cb) {\n                    if (cb) {\n                        if (isPromiseLike(cb) && cb.callback) {\n                            cb = cb.callback;\n                        }\n                        if (this.__fired && this.__results) {\n                            this.__callNextTick(cb, this.__results);\n                        } else {\n                            this.__cbs.push(cb);\n                        }\n                    }\n                    return this;\n                },\n\n\n                addErrback: function (cb) {\n                    if (cb) {\n                        if (isPromiseLike(cb) && cb.errback) {\n                            cb = cb.errback;\n                        }\n                        if (this.__fired && this.__error) {\n                            this.__callNextTick(cb, this.__error);\n                        } else {\n                            this.__errorCbs.push(cb);\n                        }\n                    }\n                    return this;\n                },\n\n                callback: function (args) {\n                    if (!this.__fired) {\n                        this.__results = arguments;\n                        this.__resolve();\n                    }\n                    return this.promise();\n                },\n\n                errback: function (args) {\n                    if (!this.__fired) {\n                        this.__error = arguments;\n                        this.__resolve();\n                    }\n                    return this.promise();\n                },\n\n                resolve: function (err, args) {\n                    if (err) {\n                        this.errback(err);\n                    } else {\n                        this.callback.apply(this, argsToArray(arguments, 1));\n                    }\n                    return this;\n                },\n\n                classic: function (cb) {\n                    if (\"function\" === typeof cb) {\n                        this.addErrback(function (err) {\n                            cb(err);\n                        });\n                        this.addCallback(function () {\n                            cb.apply(this, [null].concat(argsToArray(arguments)));\n                        });\n                    }\n                    return this;\n                },\n\n                then: function (callback, errback) {\n\n                    var promise = new Promise(), errorHandler = promise;\n                    if (isFunction(errback)) {\n                        errorHandler = createHandler(errback, promise);\n                    }\n                    this.addErrback(errorHandler);\n                    if (isFunction(callback)) {\n                        this.addCallback(createHandler(callback, promise));\n                    } else {\n                        this.addCallback(promise);\n                    }\n\n                    return promise.promise();\n                },\n\n                both: function (callback) {\n                    return this.then(callback, callback);\n                },\n\n                promise: function () {\n                    var ret = {\n                        then: bind(this, \"then\"),\n                        both: bind(this, \"both\"),\n                        promise: function () {\n                            return ret;\n                        }\n                    };\n                    forEach([\"addCallback\", \"addErrback\", \"classic\"], function (action) {\n                        ret[action] = bind(this, function () {\n                            this[action].apply(this, arguments);\n                            return ret;\n                        });\n                    }, this);\n\n                    return ret;\n                }\n\n\n            }\n        });\n\n\n        var PromiseList = Promise.extend({\n            instance: {\n\n                /*@private*/\n                __results: null,\n\n                /*@private*/\n                __errors: null,\n\n                /*@private*/\n                __promiseLength: 0,\n\n                /*@private*/\n                __defLength: 0,\n\n                /*@private*/\n                __firedLength: 0,\n\n                normalizeResults: false,\n\n                constructor: function (defs, normalizeResults) {\n                    this.__errors = [];\n                    this.__results = [];\n                    this.normalizeResults = isBoolean(normalizeResults) ? normalizeResults : false;\n                    this._super(arguments);\n                    if (defs && defs.length) {\n                        this.__defLength = defs.length;\n                        forEach(defs, this.__addPromise, this);\n                    } else {\n                        this.__resolve();\n                    }\n                },\n\n                __addPromise: function (promise, i) {\n                    promise.then(\n                        bind(this, function () {\n                            var args = argsToArray(arguments);\n                            args.unshift(i);\n                            this.callback.apply(this, args);\n                        }),\n                        bind(this, function () {\n                            var args = argsToArray(arguments);\n                            args.unshift(i);\n                            this.errback.apply(this, args);\n                        })\n                    );\n                },\n\n                __resolve: function () {\n                    if (!this.__fired) {\n                        this.__fired = true;\n                        var cbs = this.__errors.length ? this.__errorCbs : this.__cbs,\n                            len = cbs.length, i,\n                            results = this.__errors.length ? this.__errors : this.__results;\n                        for (i = 0; i < len; i++) {\n                            this.__callNextTick(cbs[i], results);\n                        }\n\n                    }\n                },\n\n                __callNextTick: function (cb, results) {\n                    nextTick(function () {\n                        cb.apply(null, [results]);\n                    });\n                },\n\n                addCallback: function (cb) {\n                    if (cb) {\n                        if (isPromiseLike(cb) && cb.callback) {\n                            cb = bind(cb, \"callback\");\n                        }\n                        if (this.__fired && !this.__errors.length) {\n                            this.__callNextTick(cb, this.__results);\n                        } else {\n                            this.__cbs.push(cb);\n                        }\n                    }\n                    return this;\n                },\n\n                addErrback: function (cb) {\n                    if (cb) {\n                        if (isPromiseLike(cb) && cb.errback) {\n                            cb = bind(cb, \"errback\");\n                        }\n                        if (this.__fired && this.__errors.length) {\n                            this.__callNextTick(cb, this.__errors);\n                        } else {\n                            this.__errorCbs.push(cb);\n                        }\n                    }\n                    return this;\n                },\n\n\n                callback: function (i) {\n                    if (this.__fired) {\n                        throw new Error(\"Already fired!\");\n                    }\n                    var args = argsToArray(arguments);\n                    if (this.normalizeResults) {\n                        args = args.slice(1);\n                        args = args.length === 1 ? args.pop() : args;\n                    }\n                    this.__results[i] = args;\n                    this.__firedLength++;\n                    if (this.__firedLength === this.__defLength) {\n                        this.__resolve();\n                    }\n                    return this.promise();\n                },\n\n\n                errback: function (i) {\n                    if (this.__fired) {\n                        throw new Error(\"Already fired!\");\n                    }\n                    var args = argsToArray(arguments);\n                    if (this.normalizeResults) {\n                        args = args.slice(1);\n                        args = args.length === 1 ? args.pop() : args;\n                    }\n                    this.__errors[i] = args;\n                    this.__firedLength++;\n                    if (this.__firedLength === this.__defLength) {\n                        this.__resolve();\n                    }\n                    return this.promise();\n                }\n\n            }\n        });\n\n\n        function callNext(list, results, propogate) {\n            var ret = new Promise().callback();\n            forEach(list, function (listItem) {\n                ret = ret.then(propogate ? listItem : bindIgnore(null, listItem));\n                if (!propogate) {\n                    ret = ret.then(function (res) {\n                        results.push(res);\n                        return results;\n                    });\n                }\n            });\n            return ret;\n        }\n\n        function isPromiseLike(obj) {\n            return !isUndefinedOrNull(obj) && (isFunction(obj.then));\n        }\n\n        function wrapThenPromise(p) {\n            var ret = new Promise();\n            p.then(bind(ret, \"callback\"), bind(ret, \"errback\"));\n            return  ret.promise();\n        }\n\n        function when(args) {\n            var p;\n            args = argsToArray(arguments);\n            if (!args.length) {\n                p = new Promise().callback(args).promise();\n            } else if (args.length === 1) {\n                args = args.pop();\n                if (isPromiseLike(args)) {\n                    if (args.addCallback && args.addErrback) {\n                        p = new Promise();\n                        args.addCallback(p.callback);\n                        args.addErrback(p.errback);\n                    } else {\n                        p = wrapThenPromise(args);\n                    }\n                } else if (isArray(args) && array.every(args, isPromiseLike)) {\n                    p = new PromiseList(args, true).promise();\n                } else {\n                    p = new Promise().callback(args);\n                }\n            } else {\n                p = new PromiseList(array.map(args, function (a) {\n                    return when(a);\n                }), true).promise();\n            }\n            return p;\n\n        }\n\n        function wrap(fn, scope) {\n            return function _wrap() {\n                var ret = new Promise();\n                var args = argsToArray(arguments);\n                args.push(ret.resolve);\n                fn.apply(scope || this, args);\n                return ret.promise();\n            };\n        }\n\n        function serial(list) {\n            if (isArray(list)) {\n                return callNext(list, [], false);\n            } else {\n                throw new Error(\"When calling promise.serial the first argument must be an array\");\n            }\n        }\n\n\n        function chain(list) {\n            if (isArray(list)) {\n                return callNext(list, [], true);\n            } else {\n                throw new Error(\"When calling promise.serial the first argument must be an array\");\n            }\n        }\n\n\n        function wait(args, fn) {\n            args = argsToArray(arguments);\n            var resolved = false;\n            fn = args.pop();\n            var p = when(args);\n            return function waiter() {\n                if (!resolved) {\n                    args = arguments;\n                    return p.then(bind(this, function doneWaiting() {\n                        resolved = true;\n                        return fn.apply(this, args);\n                    }));\n                } else {\n                    return when(fn.apply(this, arguments));\n                }\n            };\n        }\n\n        function createPromise() {\n            return new Promise();\n        }\n\n        function createPromiseList(promises) {\n            return new PromiseList(promises, true).promise();\n        }\n\n        function createRejected(val) {\n            return createPromise().errback(val);\n        }\n\n        function createResolved(val) {\n            return createPromise().callback(val);\n        }\n\n\n        return extended\n            .define({\n                isPromiseLike: isPromiseLike\n            }).expose({\n                isPromiseLike: isPromiseLike,\n                when: when,\n                wrap: wrap,\n                wait: wait,\n                serial: serial,\n                chain: chain,\n                Promise: Promise,\n                PromiseList: PromiseList,\n                promise: createPromise,\n                defer: createPromise,\n                deferredList: createPromiseList,\n                reject: createRejected,\n                resolve: createResolved\n            });\n\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = definePromise(require(\"declare.js\"), require(\"extended\"), require(\"array-extended\"), require(\"is-extended\"), require(\"function-extended\"), require(\"arguments-extended\"));\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"declare\", \"extended\", \"array-extended\", \"is-extended\", \"function-extended\", \"arguments-extended\"], function (declare, extended, array, is, fn, args) {\n            return definePromise(declare, extended, array, is, fn, args);\n        });\n    } else {\n        this.promiseExtended = definePromise(this.declare, this.extended, this.arrayExtended, this.isExtended, this.functionExtended, this.argumentsExtended);\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"__browserify_process\":64,\"arguments-extended\":51,\"array-extended\":52,\"declare.js\":55,\"extended\":56,\"function-extended\":59,\"is-extended\":66}],70:[function(require,module,exports){\n(function () {\n    \"use strict\";\n\n    function defineString(extended, is, date, arr) {\n\n        var stringify;\n        if (typeof JSON === \"undefined\") {\n            /*\n             json2.js\n             2012-10-08\n\n             Public Domain.\n\n             NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n             */\n\n            (function () {\n                function f(n) {\n                    // Format integers to have at least two digits.\n                    return n < 10 ? '0' + n : n;\n                }\n\n                var isPrimitive = is.tester().isString().isNumber().isBoolean().tester();\n\n                function toJSON(obj) {\n                    if (is.isDate(obj)) {\n                        return isFinite(obj.valueOf()) ? obj.getUTCFullYear() + '-' +\n                            f(obj.getUTCMonth() + 1) + '-' +\n                            f(obj.getUTCDate()) + 'T' +\n                            f(obj.getUTCHours()) + ':' +\n                            f(obj.getUTCMinutes()) + ':' +\n                            f(obj.getUTCSeconds()) + 'Z'\n                            : null;\n                    } else if (isPrimitive(obj)) {\n                        return obj.valueOf();\n                    }\n                    return obj;\n                }\n\n                var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                    gap,\n                    indent,\n                    meta = {    // table of character substitutions\n                        '\\b': '\\\\b',\n                        '\\t': '\\\\t',\n                        '\\n': '\\\\n',\n                        '\\f': '\\\\f',\n                        '\\r': '\\\\r',\n                        '\"': '\\\\\"',\n                        '\\\\': '\\\\\\\\'\n                    },\n                    rep;\n\n\n                function quote(string) {\n                    escapable.lastIndex = 0;\n                    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n                        var c = meta[a];\n                        return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                    }) + '\"' : '\"' + string + '\"';\n                }\n\n\n                function str(key, holder) {\n\n                    var i, k, v, length, mind = gap, partial, value = holder[key];\n                    if (value) {\n                        value = toJSON(value);\n                    }\n                    if (typeof rep === 'function') {\n                        value = rep.call(holder, key, value);\n                    }\n                    switch (typeof value) {\n                    case 'string':\n                        return quote(value);\n                    case 'number':\n                        return isFinite(value) ? String(value) : 'null';\n                    case 'boolean':\n                    case 'null':\n                        return String(value);\n                    case 'object':\n                        if (!value) {\n                            return 'null';\n                        }\n                        gap += indent;\n                        partial = [];\n                        if (Object.prototype.toString.apply(value) === '[object Array]') {\n                            length = value.length;\n                            for (i = 0; i < length; i += 1) {\n                                partial[i] = str(i, value) || 'null';\n                            }\n                            v = partial.length === 0 ? '[]' : gap ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' : '[' + partial.join(',') + ']';\n                            gap = mind;\n                            return v;\n                        }\n                        if (rep && typeof rep === 'object') {\n                            length = rep.length;\n                            for (i = 0; i < length; i += 1) {\n                                if (typeof rep[i] === 'string') {\n                                    k = rep[i];\n                                    v = str(k, value);\n                                    if (v) {\n                                        partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                                    }\n                                }\n                            }\n                        } else {\n                            for (k in value) {\n                                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                                    v = str(k, value);\n                                    if (v) {\n                                        partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                                    }\n                                }\n                            }\n                        }\n                        v = partial.length === 0 ? '{}' : gap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' : '{' + partial.join(',') + '}';\n                        gap = mind;\n                        return v;\n                    }\n                }\n\n                stringify = function (value, replacer, space) {\n                    var i;\n                    gap = '';\n                    indent = '';\n                    if (typeof space === 'number') {\n                        for (i = 0; i < space; i += 1) {\n                            indent += ' ';\n                        }\n                    } else if (typeof space === 'string') {\n                        indent = space;\n                    }\n                    rep = replacer;\n                    if (replacer && typeof replacer !== 'function' &&\n                        (typeof replacer !== 'object' ||\n                            typeof replacer.length !== 'number')) {\n                        throw new Error('JSON.stringify');\n                    }\n                    return str('', {'': value});\n                };\n            }());\n        } else {\n            stringify = JSON.stringify;\n        }\n\n\n        var isHash = is.isHash, aSlice = Array.prototype.slice;\n\n        var FORMAT_REGEX = /%((?:-?\\+?.?\\d*)?|(?:\\[[^\\[|\\]]*\\]))?([sjdDZ])/g;\n        var INTERP_REGEX = /\\{(?:\\[([^\\[|\\]]*)\\])?(\\w+)\\}/g;\n        var STR_FORMAT = /(-?)(\\+?)([A-Z|a-z|\\W]?)([1-9][0-9]*)?$/;\n        var OBJECT_FORMAT = /([1-9][0-9]*)$/g;\n\n        function formatString(string, format) {\n            var ret = string;\n            if (STR_FORMAT.test(format)) {\n                var match = format.match(STR_FORMAT);\n                var isLeftJustified = match[1], padChar = match[3], width = match[4];\n                if (width) {\n                    width = parseInt(width, 10);\n                    if (ret.length < width) {\n                        ret = pad(ret, width, padChar, isLeftJustified);\n                    } else {\n                        ret = truncate(ret, width);\n                    }\n                }\n            }\n            return ret;\n        }\n\n        function formatNumber(number, format) {\n            var ret;\n            if (is.isNumber(number)) {\n                ret = \"\" + number;\n                if (STR_FORMAT.test(format)) {\n                    var match = format.match(STR_FORMAT);\n                    var isLeftJustified = match[1], signed = match[2], padChar = match[3], width = match[4];\n                    if (signed) {\n                        ret = (number > 0 ? \"+\" : \"\") + ret;\n                    }\n                    if (width) {\n                        width = parseInt(width, 10);\n                        if (ret.length < width) {\n                            ret = pad(ret, width, padChar || \"0\", isLeftJustified);\n                        } else {\n                            ret = truncate(ret, width);\n                        }\n                    }\n\n                }\n            } else {\n                throw new Error(\"stringExtended.format : when using %d the parameter must be a number!\");\n            }\n            return ret;\n        }\n\n        function formatObject(object, format) {\n            var ret, match = format.match(OBJECT_FORMAT), spacing = 0;\n            if (match) {\n                spacing = parseInt(match[0], 10);\n                if (isNaN(spacing)) {\n                    spacing = 0;\n                }\n            }\n            try {\n                ret = stringify(object, null, spacing);\n            } catch (e) {\n                throw new Error(\"stringExtended.format : Unable to parse json from \", object);\n            }\n            return ret;\n        }\n\n\n        var styles = {\n            //styles\n            bold: 1,\n            bright: 1,\n            italic: 3,\n            underline: 4,\n            blink: 5,\n            inverse: 7,\n            crossedOut: 9,\n\n            red: 31,\n            green: 32,\n            yellow: 33,\n            blue: 34,\n            magenta: 35,\n            cyan: 36,\n            white: 37,\n\n            redBackground: 41,\n            greenBackground: 42,\n            yellowBackground: 43,\n            blueBackground: 44,\n            magentaBackground: 45,\n            cyanBackground: 46,\n            whiteBackground: 47,\n\n            encircled: 52,\n            overlined: 53,\n            grey: 90,\n            black: 90\n        };\n\n        var characters = {\n            SMILEY: \"\",\n            SOLID_SMILEY: \"\",\n            HEART: \"\",\n            DIAMOND: \"\",\n            CLOVE: \"\",\n            SPADE: \"\",\n            DOT: \"\",\n            SQUARE_CIRCLE: \"\",\n            CIRCLE: \"\",\n            FILLED_SQUARE_CIRCLE: \"\",\n            MALE: \"\",\n            FEMALE: \"\",\n            EIGHT_NOTE: \"\",\n            DOUBLE_EIGHTH_NOTE: \"\",\n            SUN: \"\",\n            PLAY: \"\",\n            REWIND: \"\",\n            UP_DOWN: \"\",\n            PILCROW: \"\",\n            SECTION: \"\",\n            THICK_MINUS: \"\",\n            SMALL_UP_DOWN: \"\",\n            UP_ARROW: \"\",\n            DOWN_ARROW: \"\",\n            RIGHT_ARROW: \"\",\n            LEFT_ARROW: \"\",\n            RIGHT_ANGLE: \"\",\n            LEFT_RIGHT_ARROW: \"\",\n            TRIANGLE: \"\",\n            DOWN_TRIANGLE: \"\",\n            HOUSE: \"\",\n            C_CEDILLA: \"\",\n            U_UMLAUT: \"\",\n            E_ACCENT: \"\",\n            A_LOWER_CIRCUMFLEX: \"\",\n            A_LOWER_UMLAUT: \"\",\n            A_LOWER_GRAVE_ACCENT: \"\",\n            A_LOWER_CIRCLE_OVER: \"\",\n            C_LOWER_CIRCUMFLEX: \"\",\n            E_LOWER_CIRCUMFLEX: \"\",\n            E_LOWER_UMLAUT: \"\",\n            E_LOWER_GRAVE_ACCENT: \"\",\n            I_LOWER_UMLAUT: \"\",\n            I_LOWER_CIRCUMFLEX: \"\",\n            I_LOWER_GRAVE_ACCENT: \"\",\n            A_UPPER_UMLAUT: \"\",\n            A_UPPER_CIRCLE: \"\",\n            E_UPPER_ACCENT: \"\",\n            A_E_LOWER: \"\",\n            A_E_UPPER: \"\",\n            O_LOWER_CIRCUMFLEX: \"\",\n            O_LOWER_UMLAUT: \"\",\n            O_LOWER_GRAVE_ACCENT: \"\",\n            U_LOWER_CIRCUMFLEX: \"\",\n            U_LOWER_GRAVE_ACCENT: \"\",\n            Y_LOWER_UMLAUT: \"\",\n            O_UPPER_UMLAUT: \"\",\n            U_UPPER_UMLAUT: \"\",\n            CENTS: \"\",\n            POUND: \"\",\n            YEN: \"\",\n            CURRENCY: \"\",\n            PTS: \"\",\n            FUNCTION: \"\",\n            A_LOWER_ACCENT: \"\",\n            I_LOWER_ACCENT: \"\",\n            O_LOWER_ACCENT: \"\",\n            U_LOWER_ACCENT: \"\",\n            N_LOWER_TILDE: \"\",\n            N_UPPER_TILDE: \"\",\n            A_SUPER: \"\",\n            O_SUPER: \"\",\n            UPSIDEDOWN_QUESTION: \"\",\n            SIDEWAYS_L: \"\",\n            NEGATION: \"\",\n            ONE_HALF: \"\",\n            ONE_FOURTH: \"\",\n            UPSIDEDOWN_EXCLAMATION: \"\",\n            DOUBLE_LEFT: \"\",\n            DOUBLE_RIGHT: \"\",\n            LIGHT_SHADED_BOX: \"\",\n            MEDIUM_SHADED_BOX: \"\",\n            DARK_SHADED_BOX: \"\",\n            VERTICAL_LINE: \"\",\n            MAZE__SINGLE_RIGHT_T: \"\",\n            MAZE_SINGLE_RIGHT_TOP: \"\",\n            MAZE_SINGLE_RIGHT_BOTTOM_SMALL: \"\",\n            MAZE_SINGLE_LEFT_TOP_SMALL: \"\",\n            MAZE_SINGLE_LEFT_BOTTOM_SMALL: \"\",\n            MAZE_SINGLE_LEFT_T: \"\",\n            MAZE_SINGLE_BOTTOM_T: \"\",\n            MAZE_SINGLE_TOP_T: \"\",\n            MAZE_SINGLE_CENTER: \"\",\n            MAZE_SINGLE_HORIZONTAL_LINE: \"\",\n            MAZE_SINGLE_RIGHT_DOUBLECENTER_T: \"\",\n            MAZE_SINGLE_RIGHT_DOUBLE_BL: \"\",\n            MAZE_SINGLE_RIGHT_DOUBLE_T: \"\",\n            MAZE_SINGLE_RIGHT_DOUBLEBOTTOM_TOP: \"\",\n            MAZE_SINGLE_RIGHT_DOUBLELEFT_TOP: \"\",\n            MAZE_SINGLE_LEFT_DOUBLE_T: \"\",\n            MAZE_SINGLE_BOTTOM_DOUBLE_T: \"\",\n            MAZE_SINGLE_TOP_DOUBLE_T: \"\",\n            MAZE_SINGLE_TOP_DOUBLECENTER_T: \"\",\n            MAZE_SINGLE_BOTTOM_DOUBLECENTER_T: \"\",\n            MAZE_SINGLE_LEFT_DOUBLERIGHT_BOTTOM: \"\",\n            MAZE_SINGLE_LEFT_DOUBLERIGHT_TOP: \"\",\n            MAZE_SINGLE_LEFT_DOUBLEBOTTOM_TOP: \"\",\n            MAZE_SINGLE_LEFT_DOUBLETOP_BOTTOM: \"\",\n            MAZE_SINGLE_LEFT_TOP: \"\",\n            MAZE_SINGLE_RIGHT_BOTTOM: \"\",\n            MAZE_SINGLE_LEFT_CENTER: \"\",\n            MAZE_SINGLE_DOUBLECENTER_CENTER: \"\",\n            MAZE_SINGLE_DOUBLECROSS_CENTER: \"\",\n            MAZE_DOUBLE_LEFT_CENTER: \"\",\n            MAZE_DOUBLE_VERTICAL: \"\",\n            MAZE_DOUBLE_RIGHT_TOP: \"\",\n            MAZE_DOUBLE_RIGHT_BOTTOM: \"\",\n            MAZE_DOUBLE_LEFT_BOTTOM: \"\",\n            MAZE_DOUBLE_LEFT_TOP: \"\",\n            MAZE_DOUBLE_BOTTOM_T: \"\",\n            MAZE_DOUBLE_TOP_T: \"\",\n            MAZE_DOUBLE_LEFT_T: \"\",\n            MAZE_DOUBLE_HORIZONTAL: \"\",\n            MAZE_DOUBLE_CROSS: \"\",\n            SOLID_RECTANGLE: \"\",\n            THICK_LEFT_VERTICAL: \"\",\n            THICK_RIGHT_VERTICAL: \"\",\n            SOLID_SMALL_RECTANGLE_BOTTOM: \"\",\n            SOLID_SMALL_RECTANGLE_TOP: \"\",\n            PHI_UPPER: \"\",\n            INFINITY: \"\",\n            INTERSECTION: \"\",\n            DEFINITION: \"\",\n            PLUS_MINUS: \"\",\n            GT_EQ: \"\",\n            LT_EQ: \"\",\n            THEREFORE: \"\",\n            SINCE: \"\",\n            DOESNOT_EXIST: \"\",\n            EXISTS: \"\",\n            FOR_ALL: \"\",\n            EXCLUSIVE_OR: \"\",\n            BECAUSE: \"\",\n            DIVIDE: \"\",\n            APPROX: \"\",\n            DEGREE: \"\",\n            BOLD_DOT: \"\",\n            DOT_SMALL: \"\",\n            CHECK: \"\",\n            ITALIC_X: \"\",\n            SUPER_N: \"\",\n            SQUARED: \"\",\n            CUBED: \"\",\n            SOLID_BOX: \"\",\n            PERMILE: \"\",\n            REGISTERED_TM: \"\",\n            COPYRIGHT: \"\",\n            TRADEMARK: \"\",\n            BETA: \"\",\n            GAMMA: \"\",\n            ZETA: \"\",\n            ETA: \"\",\n            IOTA: \"\",\n            KAPPA: \"\",\n            LAMBDA: \"\",\n            NU: \"\",\n            XI: \"\",\n            OMICRON: \"\",\n            RHO: \"\",\n            UPSILON: \"\",\n            CHI_LOWER: \"\",\n            CHI_UPPER: \"\",\n            PSI: \"\",\n            ALPHA: \"\",\n            ESZETT: \"\",\n            PI: \"\",\n            SIGMA_UPPER: \"\",\n            SIGMA_LOWER: \"\",\n            MU: \"\",\n            TAU: \"\",\n            THETA: \"\",\n            OMEGA: \"\",\n            DELTA: \"\",\n            PHI_LOWER: \"\",\n            EPSILON: \"\"\n        };\n\n        function pad(string, length, ch, end) {\n            string = \"\" + string; //check for numbers\n            ch = ch || \" \";\n            var strLen = string.length;\n            while (strLen < length) {\n                if (end) {\n                    string += ch;\n                } else {\n                    string = ch + string;\n                }\n                strLen++;\n            }\n            return string;\n        }\n\n        function truncate(string, length, end) {\n            var ret = string;\n            if (is.isString(ret)) {\n                if (string.length > length) {\n                    if (end) {\n                        var l = string.length;\n                        ret = string.substring(l - length, l);\n                    } else {\n                        ret = string.substring(0, length);\n                    }\n                }\n            } else {\n                ret = truncate(\"\" + ret, length);\n            }\n            return ret;\n        }\n\n        function format(str, obj) {\n            if (obj instanceof Array) {\n                var i = 0, len = obj.length;\n                //find the matches\n                return str.replace(FORMAT_REGEX, function (m, format, type) {\n                    var replacer, ret;\n                    if (i < len) {\n                        replacer = obj[i++];\n                    } else {\n                        //we are out of things to replace with so\n                        //just return the match?\n                        return m;\n                    }\n                    if (m === \"%s\" || m === \"%d\" || m === \"%D\") {\n                        //fast path!\n                        ret = replacer + \"\";\n                    } else if (m === \"%Z\") {\n                        ret = replacer.toUTCString();\n                    } else if (m === \"%j\") {\n                        try {\n                            ret = stringify(replacer);\n                        } catch (e) {\n                            throw new Error(\"stringExtended.format : Unable to parse json from \", replacer);\n                        }\n                    } else {\n                        format = format.replace(/^\\[|\\]$/g, \"\");\n                        switch (type) {\n                        case \"s\":\n                            ret = formatString(replacer, format);\n                            break;\n                        case \"d\":\n                            ret = formatNumber(replacer, format);\n                            break;\n                        case \"j\":\n                            ret = formatObject(replacer, format);\n                            break;\n                        case \"D\":\n                            ret = date.format(replacer, format);\n                            break;\n                        case \"Z\":\n                            ret = date.format(replacer, format, true);\n                            break;\n                        }\n                    }\n                    return ret;\n                });\n            } else if (isHash(obj)) {\n                return str.replace(INTERP_REGEX, function (m, format, value) {\n                    value = obj[value];\n                    if (!is.isUndefined(value)) {\n                        if (format) {\n                            if (is.isString(value)) {\n                                return formatString(value, format);\n                            } else if (is.isNumber(value)) {\n                                return formatNumber(value, format);\n                            } else if (is.isDate(value)) {\n                                return date.format(value, format);\n                            } else if (is.isObject(value)) {\n                                return formatObject(value, format);\n                            }\n                        } else {\n                            return \"\" + value;\n                        }\n                    }\n                    return m;\n                });\n            } else {\n                var args = aSlice.call(arguments).slice(1);\n                return format(str, args);\n            }\n        }\n\n        function toArray(testStr, delim) {\n            var ret = [];\n            if (testStr) {\n                if (testStr.indexOf(delim) > 0) {\n                    ret = testStr.replace(/\\s+/g, \"\").split(delim);\n                }\n                else {\n                    ret.push(testStr);\n                }\n            }\n            return ret;\n        }\n\n        function multiply(str, times) {\n            var ret = [];\n            if (times) {\n                for (var i = 0; i < times; i++) {\n                    ret.push(str);\n                }\n            }\n            return ret.join(\"\");\n        }\n\n\n        function style(str, options) {\n            var ret, i, l;\n            if (options) {\n                if (is.isArray(str)) {\n                    ret = [];\n                    for (i = 0, l = str.length; i < l; i++) {\n                        ret.push(style(str[i], options));\n                    }\n                } else if (options instanceof Array) {\n                    ret = str;\n                    for (i = 0, l = options.length; i < l; i++) {\n                        ret = style(ret, options[i]);\n                    }\n                } else if (options in styles) {\n                    ret = '\\x1B[' + styles[options] + 'm' + str + '\\x1B[0m';\n                }\n            }\n            return ret;\n        }\n\n        function escape(str, except) {\n            return str.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function (ch) {\n                if (except && arr.indexOf(except, ch) !== -1) {\n                    return ch;\n                }\n                return \"\\\\\" + ch;\n            });\n        }\n\n        function trim(str) {\n            return str.replace(/^\\s*|\\s*$/g, \"\");\n        }\n\n        function trimLeft(str) {\n            return str.replace(/^\\s*/, \"\");\n        }\n\n        function trimRight(str) {\n            return str.replace(/\\s*$/, \"\");\n        }\n\n        function isEmpty(str) {\n            return str.length === 0;\n        }\n\n\n        var string = {\n            toArray: toArray,\n            pad: pad,\n            truncate: truncate,\n            multiply: multiply,\n            format: format,\n            style: style,\n            escape: escape,\n            trim: trim,\n            trimLeft: trimLeft,\n            trimRight: trimRight,\n            isEmpty: isEmpty\n        };\n        return extended.define(is.isString, string).define(is.isArray, {style: style}).expose(string).expose({characters: characters});\n    }\n\n    if (\"undefined\" !== typeof exports) {\n        if (\"undefined\" !== typeof module && module.exports) {\n            module.exports = defineString(require(\"extended\"), require(\"is-extended\"), require(\"date-extended\"), require(\"array-extended\"));\n\n        }\n    } else if (\"function\" === typeof define && define.amd) {\n        define([\"extended\", \"is-extended\", \"date-extended\", \"array-extended\"], function (extended, is, date, arr) {\n            return defineString(extended, is, date, arr);\n        });\n    } else {\n        this.stringExtended = defineString(this.extended, this.isExtended, this.dateExtended, this.arrayExtended);\n    }\n\n}).call(this);\n\n\n\n\n\n\n\n},{\"array-extended\":52,\"date-extended\":53,\"extended\":56,\"is-extended\":66}]},{},[1])\n;","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/benchmark/manners/benchmark.js":"\"use strict\";\nvar data = require(\"./data\"),\n    nools = require(\"../../index\");\n\nvar flow = nools.compile(__dirname + \"/manners.nools\");\nvar guests = data.load(flow).manners64;\nvar session = flow.getSession.apply(flow, guests);\nsession.assert(new (flow.getDefined(\"count\"))({value: 1}));\nvar start = new Date();\n\nmodule.exports = session.match().then(function () {\n    console.log(\"Duration %dms\", new Date() - start);\n    session.dispose();\n}, function (err) {\n    session.dispose();\n    console.log(err.stack);\n});","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/benchmark/manners/data/index.js":"(function () {\n    \"use strict\";\n\n    var fs = require(\"fs\"), path = require(\"path\");\n\n    var FILE_REG = /(.*)\\.dat$/, files = {};\n    fs.readdirSync(__dirname).filter(function (file) {\n        return FILE_REG.test(file);\n    }).forEach(function (f) {\n            var name = f.match(FILE_REG)[1];\n            files[name] = fs.readFileSync(path.resolve(__dirname, f), \"utf8\");\n        });\n\n    exports.load = function (flow) {\n        var ret = {};\n        Object.keys(files).forEach(function (name) {\n            var data = files[name];\n            var arr = ret[name] = [];\n            data.split(\"\\n\").map(function (line) {\n                return line.replace(/^\\(|\\)$/g, \"\");\n            }).forEach(function (line) {\n                    if (line) {\n                        var parts = line.split(/\\(/),\n                            type = parts.shift();\n                        var Cls = flow.getDefined(type.trim());\n                        if (type) {\n                            var args = {};\n                            parts.forEach(function (p) {\n                                var prop = p.trim().replace(/\\)$/, \"\").split(/\\s+/),\n                                    name = prop[0].trim(),\n                                    value = prop[1].trim();\n                                args[name] = name == \"seat\" ? parseInt(value) : value;\n                            });\n                            arr.push(new Cls(args));\n                        }\n                    }\n                });\n        });\n        return ret;\n    };\n\n})();","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/constraint/grammar.js":"var Parser = require(\"jison\").Parser, fs = require(\"fs\");\n\nvar grammar = {\n    \"lex\": {\n        \"rules\": [\n            [\"\\\\s+in\\\\b\", \"return 'in';\"],\n            [\"\\\\s+notIn\\\\b\", \"return 'notIn';\"],\n            [\"\\\\s+from\\\\b\", \"return 'from';\"],\n            [\"\\\\s+(eq|EQ)\\\\b\", \"return '==';\"],\n            [\"\\\\s+(seq|SEQ)\\\\b\", \"return '===';\"],\n            [\"\\\\s+(neq|NEQ)\\\\b\", \"return '!=';\"],\n            [\"\\\\s+(sneq|SNEQ)\\\\b\", \"return '!==';\"],\n            [\"\\\\s+(lte|LTE)\\\\b\", \"return '<=';\"],\n            [\"\\\\s+(lt|LT)\\\\b\", \"return '<';\"],\n            [\"\\\\s+(gte|GTE)\\\\b\", \"return '>=';\"],\n            [\"\\\\s+(gt|GT)\\\\b\", \"return '>';\"],\n            [\"\\\\s+(like|LIKE)\\\\b\", \"return '=~';\"],\n            [\"\\\\s+(notLike|NOT_LIKE)\\\\b\", \"return '!=~';\"],\n            [\"\\\\s+(and|AND)\\\\b\", \"return '&&';\"],\n            [\"\\\\s+(or|OR)\\\\b\", \"return '||';\"],\n            [\"\\\\s*(null)\\\\b\", \"return 'NULL';\"],\n            [\"\\\\s*(true|false)\\\\b\", \"return 'BOOLEAN';\"],\n            [\"\\\\s+\", \"/* skip whitespace */\"],\n            [\"-?[0-9]+(?:\\\\.[0-9]+)?\\\\b\", \"return 'NUMBER';\"],\n            [\"\\'[^\\']*\\'\", \"return 'STRING';\"],\n            ['\\\"[^\\\"]*\\\"', \"return 'STRING';\"],\n            [\"([a-zA-Z_$][0-9a-zA-Z_$]*)\", \"return 'IDENTIFIER';\"],\n            [\"^\\\\/((?![\\\\s=])[^[\\\\/\\\\n\\\\\\\\]*(?:(?:\\\\\\\\[\\\\s\\\\S]|\\\\[[^\\\\]\\\\n\\\\\\\\]*(?:\\\\\\\\[\\\\s\\\\S][^\\\\]\\\\n\\\\\\\\]*)*])[^[\\\\/\\\\n\\\\\\\\]*)*\\\\/[imgy]{0,4})(?!\\\\w)\", \"return 'REGEXP';\"],\n            [\"\\\\.\", \"return '.';\"],\n            [\"\\\\*\", \"return '*';\"],\n            [\"\\\\/\", \"return '/';\"],\n            [\"\\\\%\", \"return '%';\"],\n            [\",\", \"return ',';\"],\n            [\"-\", \"return '-';\"],\n            [\"=~\", \"return '=~';\"],\n            [\"!=~\", \"return '!=~';\"],\n            [\"===\", \"return '===';\"],\n            [\"==\", \"return '==';\"],\n            [\"!==\", \"return '!==';\"],\n            [\"!=\", \"return '!=';\"],\n            [\"<=\", \"return '<=';\"],\n            [\">=\", \"return '>=';\"],\n            [\">\", \"return '>';\"],\n            [\"<\", \"return '<';\"],\n            [\"&&\", \"return '&&';\"],\n            [\"\\\\|\\\\|\", \"return '||';\"],\n            [\"\\\\+\", \"return '+';\"],\n            [\"\\\\^\", \"return '^';\"],\n            [\"\\\\(\", \"return '(';\"],\n            [\"\\\\]\", \"return ']';\"],\n            [\"\\\\[\", \"return '[';\"],\n            [\"\\\\)\", \"return ')';\"],\n            [\"!\", \"return '!';\"],\n            [\"$\", \"return 'EOF';\"]\n        ]\n    },\n\n    \"bnf\": {\n        \"expressions\": [\n            [ \"EXPRESSION EOF\", \"return $1;\"  ]\n        ],\n\n        \"UNARY_EXPRESSION\": [\n            \"LITERAL_EXPRESSION\",\n            [ \"- UNARY_EXPRESSION\", \"$$ = [$2, null, 'unary'];\"],\n            [ \"! UNARY_EXPRESSION\", \"$$ = [$2, null, 'logicalNot'];\"]\n        ],\n\n        \"MULTIPLICATIVE_EXPRESSION\": [\n            \"UNARY_EXPRESSION\",\n            [ \"MULTIPLICATIVE_EXPRESSION * UNARY_EXPRESSION\", \"$$ = [$1, $3, 'mult'];\" ],\n            [ \"MULTIPLICATIVE_EXPRESSION / UNARY_EXPRESSION\", \"$$ = [$1, $3, 'div'];\" ],\n            [ \"MULTIPLICATIVE_EXPRESSION % UNARY_EXPRESSION\", \"$$ = [$1, $3, 'mod'];\" ]\n        ],\n\n        \"ADDITIVE_EXPRESSION\": [\n            \"MULTIPLICATIVE_EXPRESSION\",\n            [ \"ADDITIVE_EXPRESSION + MULTIPLICATIVE_EXPRESSION\", \"$$ = [$1, $3, 'plus'];\" ],\n            [ \"ADDITIVE_EXPRESSION - MULTIPLICATIVE_EXPRESSION\", \"$$ = [$1, $3, 'minus'];\" ]\n        ],\n\n        \"EXPONENT_EXPRESSION\": [\n            \"ADDITIVE_EXPRESSION\",\n            [ \"EXPONENT_EXPRESSION ^ ADDITIVE_EXPRESSION\", \"$$ = [$1, $3, 'pow'];\" ]\n        ],\n\n        \"RELATIONAL_EXPRESSION\": [\n            \"EXPONENT_EXPRESSION\",\n            [ \"RELATIONAL_EXPRESSION < EXPONENT_EXPRESSION\", \"$$ = [$1, $3, 'lt'];\" ],\n            [ \"RELATIONAL_EXPRESSION > EXPONENT_EXPRESSION\", \"$$ = [$1, $3, 'gt'];\" ],\n            [ \"RELATIONAL_EXPRESSION <= EXPONENT_EXPRESSION\", \"$$ = [$1, $3, 'lte'];\" ],\n            [ \"RELATIONAL_EXPRESSION >= EXPONENT_EXPRESSION\", \"$$ = [$1, $3, 'gte'];\" ]\n        ],\n\n        \"EQUALITY_EXPRESSION\": [\n            \"RELATIONAL_EXPRESSION\",\n            [ \"EQUALITY_EXPRESSION == RELATIONAL_EXPRESSION\", \"$$ = [$1, $3, 'eq'];\" ],\n            [ \"EQUALITY_EXPRESSION === RELATIONAL_EXPRESSION\", \"$$ = [$1, $3, 'seq'];\" ],\n            [ \"EQUALITY_EXPRESSION != RELATIONAL_EXPRESSION\", \"$$ = [$1, $3, 'neq'];\" ],\n            [ \"EQUALITY_EXPRESSION !== RELATIONAL_EXPRESSION\", \"$$ = [$1, $3, 'sneq'];\" ],\n            [ \"EQUALITY_EXPRESSION =~ RELATIONAL_EXPRESSION\", \"$$ = [$1, $3, 'like'];\" ],\n            [ \"EQUALITY_EXPRESSION !=~ RELATIONAL_EXPRESSION\", \"$$ = [$1, $3, 'notLike'];\" ]\n        ],\n\n        \"IN_EXPRESSION\": [\n            \"EQUALITY_EXPRESSION\",\n            [ \"LITERAL_EXPRESSION in ARRAY_EXPRESSION\", \"$$ = [$1, $3, 'in'];\" ],\n            [ \"LITERAL_EXPRESSION notIn ARRAY_EXPRESSION\", \"$$ = [$1, $3, 'notIn'];\" ],\n            [ \"LITERAL_EXPRESSION in OBJECT_EXPRESSION\", \"$$ = [$1, $3, 'in'];\" ],\n            [ \"LITERAL_EXPRESSION notIn OBJECT_EXPRESSION\", \"$$ = [$1, $3, 'notIn'];\" ]\n        ],\n\n        \"AND_EXPRESSION\": [\n            \"IN_EXPRESSION\",\n            [ \"AND_EXPRESSION && IN_EXPRESSION\", \"$$ = [$1, $3, 'and'];\" ]\n        ],\n\n        \"OR_EXPRESSION\": [\n            \"AND_EXPRESSION\",\n            [ \"OR_EXPRESSION || AND_EXPRESSION\", \"$$ = [$1, $3, 'or'];\" ]\n        ],\n\n        \"ARGUMENT_LIST\": [\n            \"LITERAL_EXPRESSION\",\n            [\"ARGUMENT_LIST , LITERAL_EXPRESSION\", \"$$ = [$1, $3, 'arguments']\"]\n        ],\n\n        \"IDENTIFIER_EXPRESSION\": [\n            [ \"IDENTIFIER\", \"$$ = [String(yytext), null, 'identifier'];\" ]\n        ],\n\n        \"OBJECT_EXPRESSION\": [\n            \"IDENTIFIER_EXPRESSION\",\n            [ \"OBJECT_EXPRESSION . IDENTIFIER_EXPRESSION\", \"$$ = [$1,$3, 'prop'];\" ],\n            [ \"OBJECT_EXPRESSION [ STRING_EXPRESSION ]\", \"$$ = [$1,$3, 'propLookup'];\" ],\n            [ \"OBJECT_EXPRESSION [ NUMBER_EXPRESSION ]\", \"$$ = [$1,$3, 'propLookup'];\" ],\n            [ \"OBJECT_EXPRESSION [ OBJECT_EXPRESSION ]\", \"$$ = [$1,$3, 'propLookup'];\" ],\n            [ \"OBJECT_EXPRESSION ( )\", \"$$ = [$1, [null, null, 'arguments'], 'function']\"],\n            [ \"OBJECT_EXPRESSION ( ARGUMENT_LIST )\", \"$$ = [$1, $3, 'function']\"]\n        ],\n\n        \"STRING_EXPRESSION\": [\n            [ \"STRING\", \"$$ = [String(yytext.replace(/^['|\\\"]|['|\\\"]$/g, '')), null, 'string'];\" ]\n        ],\n\n        \"NUMBER_EXPRESSION\": [\n            [ \"NUMBER\", \"$$ = [Number(yytext), null, 'number'];\"]\n        ],\n\n        \"REGEXP_EXPRESSION\": [\n            [ \"REGEXP\", \"$$ = [yytext, null, 'regexp'];\" ]\n        ],\n\n        \"BOOLEAN_EXPRESSION\": [\n            [ \"BOOLEAN\", \"$$ = [yytext.replace(/^\\\\s+/, '') == 'true', null, 'boolean'];\" ]\n        ],\n\n        \"NULL_EXPRESSION\": [\n            [ \"NULL\", \"$$ = [null, null, 'null'];\" ]\n        ],\n\n        \"ARRAY_EXPRESSION\": [\n            [ \"[ ]\", \"$$ = [null, null, 'array'];\" ],\n            [ \"[ ARGUMENT_LIST ]\", \"$$ = [$2, null, 'array'];\" ]\n        ],\n\n\n        \"LITERAL_EXPRESSION\": [\n            \"STRING_EXPRESSION\",\n            \"NUMBER_EXPRESSION\",\n            \"REGEXP_EXPRESSION\",\n            \"BOOLEAN_EXPRESSION\",\n            \"NULL_EXPRESSION\",\n            \"OBJECT_EXPRESSION\",\n            \"ARRAY_EXPRESSION\",\n            [ \"( EXPRESSION )\", \"$$ = [$2, null, 'composite']\" ]\n        ],\n\n        \"EXPRESSION\": [\n            \"OR_EXPRESSION\"\n        ]\n    }\n};\n\nvar parser = new Parser(grammar);\nfs.writeFileSync(__dirname + '/parser.js', parser.generate());\n"}
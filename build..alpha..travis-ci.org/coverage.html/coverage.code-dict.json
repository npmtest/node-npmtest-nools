{"/home/travis/build/npmtest/node-npmtest-nools/test.js":"/* istanbul instrument in package npmtest_nools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nools/lib.npmtest_nools.js":"/* istanbul instrument in package npmtest_nools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nools = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nools = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nools/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nools && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nools\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nools.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_nools.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nools.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_nools.__dirname +\n                    '/lib.npmtest_nools.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/index.js":"module.exports = exports = require(\"./lib\");","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/index.js":"/**\n *\n * @projectName nools\n * @github https://github.com/C2FO/nools\n * @includeDoc [Examples] ../docs-md/examples.md\n * @includeDoc [Change Log] ../history.md\n * @header [../readme.md]\n */\n\n\"use strict\";\nvar extd = require(\"./extended\"),\n    fs = require(\"fs\"),\n    path = require(\"path\"),\n    compile = require(\"./compile\"),\n    FlowContainer = require(\"./flowContainer\");\n\nfunction isNoolsFile(file) {\n    return (/\\.nools$/).test(file);\n}\n\nfunction parse(source) {\n    var ret;\n    if (isNoolsFile(source)) {\n        ret = compile.parse(fs.readFileSync(source, \"utf8\"), source);\n    } else {\n        ret = compile.parse(source);\n    }\n    return ret;\n}\n\nexports.Flow = FlowContainer;\n\nexports.getFlow = FlowContainer.getFlow;\nexports.hasFlow = FlowContainer.hasFlow;\n\nexports.deleteFlow = function (name) {\n    FlowContainer.deleteFlow(name);\n    return this;\n};\n\nexports.deleteFlows = function () {\n    FlowContainer.deleteFlows();\n    return this;\n};\n\nexports.flow = FlowContainer.create;\n\nexports.compile = function (file, options, cb) {\n    if (extd.isFunction(options)) {\n        cb = options;\n        options = {};\n    } else {\n        options = options || {};\n    }\n    if (extd.isString(file)) {\n        options.name = options.name || (isNoolsFile(file) ? path.basename(file, path.extname(file)) : null);\n        file = parse(file);\n    }\n    if (!options.name) {\n        throw new Error(\"Name required when compiling nools source\");\n    }\n    return  compile.compile(file, options, cb, FlowContainer);\n};\n\nexports.transpile = function (file, options) {\n    options = options || {};\n    if (extd.isString(file)) {\n        options.name = options.name || (isNoolsFile(file) ? path.basename(file, path.extname(file)) : null);\n        file = parse(file);\n    }\n    return compile.transpile(file, options);\n};\n\nexports.parse = parse;","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/extended.js":"var arr = require(\"array-extended\"),\n    unique = arr.unique,\n    indexOf = arr.indexOf,\n    map = arr.map,\n    pSlice = Array.prototype.slice,\n    pSplice = Array.prototype.splice;\n\nfunction plucked(prop) {\n    var exec = prop.match(/(\\w+)\\(\\)$/);\n    if (exec) {\n        prop = exec[1];\n        return function (item) {\n            return item[prop]();\n        };\n    } else {\n        return function (item) {\n            return item[prop];\n        };\n    }\n}\n\nfunction plucker(prop) {\n    prop = prop.split(\".\");\n    if (prop.length === 1) {\n        return plucked(prop[0]);\n    } else {\n        var pluckers = map(prop, function (prop) {\n            return plucked(prop);\n        });\n        var l = pluckers.length;\n        return function (item) {\n            var i = -1, res = item;\n            while (++i < l) {\n                res = pluckers[i](res);\n            }\n            return res;\n        };\n    }\n}\n\nfunction intersection(a, b) {\n    a = pSlice.call(a);\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) === -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction inPlaceIntersection(a, b) {\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) === -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction inPlaceDifference(a, b) {\n    var aOne, i = -1, l;\n    l = a.length;\n    while (++i < l) {\n        aOne = a[i];\n        if (indexOf(b, aOne) !== -1) {\n            pSplice.call(a, i--, 1);\n            l--;\n        }\n    }\n    return a;\n}\n\nfunction diffArr(arr1, arr2) {\n    var ret = [], i = -1, j, l2 = arr2.length, l1 = arr1.length, a, found;\n    if (l2 > l1) {\n        ret = arr1.slice();\n        while (++i < l2) {\n            a = arr2[i];\n            j = -1;\n            l1 = ret.length;\n            while (++j < l1) {\n                if (ret[j] === a) {\n                    ret.splice(j, 1);\n                    break;\n                }\n            }\n        }\n    } else {\n        while (++i < l1) {\n            a = arr1[i];\n            j = -1;\n            found = false;\n            while (++j < l2) {\n                if (arr2[j] === a) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ret.push(a);\n            }\n        }\n    }\n    return ret;\n}\n\nfunction diffHash(h1, h2) {\n    var ret = {};\n    for (var i in h1) {\n        if (!hasOwnProperty.call(h2, i)) {\n            ret[i] = h1[i];\n        }\n    }\n    return ret;\n}\n\n\nfunction union(arr1, arr2) {\n    return unique(arr1.concat(arr2));\n}\n\nmodule.exports = require(\"extended\")()\n    .register(require(\"date-extended\"))\n    .register(arr)\n    .register(require(\"object-extended\"))\n    .register(require(\"string-extended\"))\n    .register(require(\"promise-extended\"))\n    .register(require(\"function-extended\"))\n    .register(require(\"is-extended\"))\n    .register(\"intersection\", intersection)\n    .register(\"inPlaceIntersection\", inPlaceIntersection)\n    .register(\"inPlaceDifference\", inPlaceDifference)\n    .register(\"diffArr\", diffArr)\n    .register(\"diffHash\", diffHash)\n    .register(\"unionArr\", union)\n    .register(\"plucker\", plucker)\n    .register(\"HashTable\", require(\"ht\"))\n    .register(\"declare\", require(\"declare.js\"))\n    .register(require(\"leafy\"))\n    .register(\"LinkedList\", require(\"./linkedList\"));\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/linkedList.js":"var declare = require(\"declare.js\");\ndeclare({\n\n    instance: {\n        constructor: function () {\n            this.head = null;\n            this.tail = null;\n            this.length = null;\n        },\n\n        push: function (data) {\n            var tail = this.tail, head = this.head, node = {data: data, prev: tail, next: null};\n            if (tail) {\n                this.tail.next = node;\n            }\n            this.tail = node;\n            if (!head) {\n                this.head = node;\n            }\n            this.length++;\n            return node;\n        },\n\n        remove: function (node) {\n            if (node.prev) {\n                node.prev.next = node.next;\n            } else {\n                this.head = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            } else {\n                this.tail = node.prev;\n            }\n            //node.data = node.prev = node.next = null;\n            this.length--;\n        },\n\n        forEach: function (cb) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                cb(head.data);\n            }\n        },\n\n        toArray: function () {\n            var head = {next: this.head}, ret = [];\n            while ((head = head.next)) {\n                ret.push(head);\n            }\n            return ret;\n        },\n\n        removeByData: function (data) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                if (head.data === data) {\n                    this.remove(head);\n                    break;\n                }\n            }\n        },\n\n        getByData: function (data) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                if (head.data === data) {\n                    return head;\n                }\n            }\n        },\n\n        clear: function () {\n            this.head = this.tail = null;\n            this.length = 0;\n        }\n\n    }\n\n}).as(module);\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/compile/index.js":"/*jshint evil:true*/\n\"use strict\";\nvar extd = require(\"../extended\"),\n    parser = require(\"../parser\"),\n    constraintMatcher = require(\"../constraintMatcher.js\"),\n    indexOf = extd.indexOf,\n    forEach = extd.forEach,\n    removeDuplicates = extd.removeDuplicates,\n    map = extd.map,\n    obj = extd.hash,\n    keys = obj.keys,\n    merge = extd.merge,\n    rules = require(\"../rule\"),\n    common = require(\"./common\"),\n    modifiers = common.modifiers,\n    createDefined = common.createDefined,\n    createFunction = common.createFunction;\n\n\n/**\n * @private\n * Parses an action from a rule definition\n * @param {String} action the body of the action to execute\n * @param {Array} identifiers array of identifiers collected\n * @param {Object} defined an object of defined\n * @param scope\n * @return {Object}\n */\nvar parseAction = function (action, identifiers, defined, scope) {\n    var declares = [];\n    forEach(identifiers, function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= facts.\" + i + \";\");\n        }\n    });\n    extd(defined).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    extd(scope).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    extd(modifiers).forEach(function (i) {\n        if (action.indexOf(i) !== -1) {\n            declares.push(\"if(!\" + i + \"){ var \" + i + \"= flow.\" + i + \";}\");\n        }\n    });\n    var params = [\"facts\", 'flow'];\n    if (/next\\(.*\\)/.test(action)) {\n        params.push(\"next\");\n    }\n    action = declares.join(\"\") + action;\n    try {\n        return new Function(\"defined, scope\", \"return \" + new Function(params.join(\",\"), action).toString())(defined, scope);\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + action + \"\\n\" + e.message);\n    }\n};\n\nvar createRuleFromObject = (function () {\n    var __resolveRule = function (rule, identifiers, conditions, defined, name) {\n        var condition = [], definedClass = rule[0], alias = rule[1], constraint = rule[2], refs = rule[3];\n        if (extd.isHash(constraint)) {\n            refs = constraint;\n            constraint = null;\n        }\n        if (definedClass && !!(definedClass = defined[definedClass])) {\n            condition.push(definedClass);\n        } else {\n            throw new Error(\"Invalid class \" + rule[0] + \" for rule \" + name);\n        }\n        condition.push(alias, constraint, refs);\n        conditions.push(condition);\n        identifiers.push(alias);\n        if (constraint) {\n            forEach(constraintMatcher.getIdentifiers(parser.parseConstraint(constraint)), function (i) {\n                identifiers.push(i);\n            });\n        }\n        if (extd.isObject(refs)) {\n            for (var j in refs) {\n                var ident = refs[j];\n                if (indexOf(identifiers, ident) === -1) {\n                    identifiers.push(ident);\n                }\n            }\n        }\n    };\n\n    function parseRule(rule, conditions, identifiers, defined, name) {\n        if (rule.length) {\n            var r0 = rule[0];\n            if (r0 === \"not\" || r0 === \"exists\") {\n                var temp = [];\n                rule.shift();\n                __resolveRule(rule, identifiers, temp, defined, name);\n                var cond = temp[0];\n                cond.unshift(r0);\n                conditions.push(cond);\n            } else if (r0 === \"or\") {\n                var conds = [r0];\n                rule.shift();\n                forEach(rule, function (cond) {\n                    parseRule(cond, conds, identifiers, defined, name);\n                });\n                conditions.push(conds);\n            } else {\n                __resolveRule(rule, identifiers, conditions, defined, name);\n                identifiers = removeDuplicates(identifiers);\n            }\n        }\n\n    }\n\n    return function (obj, defined, scope) {\n        var name = obj.name;\n        if (extd.isEmpty(obj)) {\n            throw new Error(\"Rule is empty\");\n        }\n        var options = obj.options || {};\n        options.scope = scope;\n        var constraints = obj.constraints || [], l = constraints.length;\n        if (!l) {\n            constraints = [\"true\"];\n        }\n        var action = obj.action;\n        if (extd.isUndefined(action)) {\n            throw new Error(\"No action was defined for rule \" + name);\n        }\n        var conditions = [], identifiers = [];\n        forEach(constraints, function (rule) {\n            parseRule(rule, conditions, identifiers, defined, name);\n        });\n        return rules.createRule(name, options, conditions, parseAction(action, identifiers, defined, scope));\n    };\n})();\n\nexports.parse = function (src, file) {\n    //parse flow from file\n    return parser.parseRuleSet(src, file);\n\n};\nexports.compile = function (flowObj, options, cb, Container) {\n    if (extd.isFunction(options)) {\n        cb = options;\n        options = {};\n    } else {\n        options = options || {};\n    }\n    var name = flowObj.name || options.name;\n    //if !name throw an error\n    if (!name) {\n        throw new Error(\"Name must be present in JSON or options\");\n    }\n    var flow = new Container(name);\n    var defined = merge({Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, options.define || {});\n    if (typeof Buffer !== \"undefined\") {\n        defined.Buffer = Buffer;\n    }\n    var scope = merge({console: console}, options.scope);\n    //add the anything added to the scope as a property\n    forEach(flowObj.scope, function (s) {\n        scope[s.name] = true;\n    });\n    //add any defined classes in the parsed flowObj to defined\n    forEach(flowObj.define, function (d) {\n        defined[d.name] = createDefined(d, defined, scope);\n    });\n\n    //expose any defined classes to the flow.\n    extd(defined).forEach(function (cls, name) {\n        flow.addDefined(name, cls);\n    });\n\n    var scopeNames = extd(flowObj.scope).pluck(\"name\").union(extd(scope).keys().value()).value();\n    var definedNames = map(keys(defined), function (s) {\n        return s;\n    });\n    forEach(flowObj.scope, function (s) {\n        scope[s.name] = createFunction(s.body, defined, scope, scopeNames, definedNames);\n    });\n    var rules = flowObj.rules;\n    if (rules.length) {\n        forEach(rules, function (rule) {\n            flow.__rules = flow.__rules.concat(createRuleFromObject(rule, defined, scope));\n        });\n    }\n    if (cb) {\n        cb.call(flow, flow);\n    }\n    return flow;\n};\n\nexports.transpile = require(\"./transpile\").transpile;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/index.js":"(function () {\n    \"use strict\";\n    var constraintParser = require(\"./constraint/parser\"),\n        noolParser = require(\"./nools/nool.parser\");\n\n    exports.parseConstraint = function (expression) {\n        try {\n            return constraintParser.parse(expression);\n        } catch (e) {\n            throw new Error(\"Invalid expression '\" + expression + \"'\");\n        }\n    };\n\n    exports.parseRuleSet = function (source, file) {\n        return noolParser.parse(source, file);\n    };\n})();","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/constraint/parser.js":"/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,29],$V1=[1,30],$V2=[1,26],$V3=[1,24],$V4=[1,16],$V5=[1,18],$V6=[1,19],$V7=[1,20],$V8=[1,21],$V9=[1,22],$Va=[5,38,49],$Vb=[1,33],$Vc=[5,36,38,49],$Vd=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Ve=[2,2],$Vf=[5,24,25,26,27,28,29,36,38,49],$Vg=[1,42],$Vh=[1,43],$Vi=[1,44],$Vj=[1,45],$Vk=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,31,33,36,38,40,46,49],$Vl=[1,46],$Vm=[1,47],$Vn=[1,48],$Vo=[5,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vp=[1,50],$Vq=[5,8,11,12,13,15,17,19,20,21,22,24,25,26,27,28,29,31,33,36,38,40,43,44,46,48,49],$Vr=[5,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vs=[1,55],$Vt=[1,54],$Vu=[5,8,15,17,19,20,21,22,24,25,26,27,28,29,36,38,49],$Vv=[1,56],$Vw=[1,57],$Vx=[1,58],$Vy=[1,87],$Vz=[40,46,49];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"EXPRESSION\":4,\"EOF\":5,\"UNARY_EXPRESSION\":6,\"LITERAL_EXPRESSION\":7,\"-\":8,\"!\":9,\"MULTIPLICATIVE_EXPRESSION\":10,\"*\":11,\"/\":12,\"%\":13,\"ADDITIVE_EXPRESSION\":14,\"+\":15,\"EXPONENT_EXPRESSION\":16,\"^\":17,\"RELATIONAL_EXPRESSION\":18,\"<\":19,\">\":20,\"<=\":21,\">=\":22,\"EQUALITY_EXPRESSION\":23,\"==\":24,\"===\":25,\"!=\":26,\"!==\":27,\"=~\":28,\"!=~\":29,\"IN_EXPRESSION\":30,\"in\":31,\"ARRAY_EXPRESSION\":32,\"notIn\":33,\"OBJECT_EXPRESSION\":34,\"AND_EXPRESSION\":35,\"&&\":36,\"OR_EXPRESSION\":37,\"||\":38,\"ARGUMENT_LIST\":39,\",\":40,\"IDENTIFIER_EXPRESSION\":41,\"IDENTIFIER\":42,\".\":43,\"[\":44,\"STRING_EXPRESSION\":45,\"]\":46,\"NUMBER_EXPRESSION\":47,\"(\":48,\")\":49,\"STRING\":50,\"NUMBER\":51,\"REGEXP_EXPRESSION\":52,\"REGEXP\":53,\"BOOLEAN_EXPRESSION\":54,\"BOOLEAN\":55,\"NULL_EXPRESSION\":56,\"NULL\":57,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",8:\"-\",9:\"!\",11:\"*\",12:\"/\",13:\"%\",15:\"+\",17:\"^\",19:\"<\",20:\">\",21:\"<=\",22:\">=\",24:\"==\",25:\"===\",26:\"!=\",27:\"!==\",28:\"=~\",29:\"!=~\",31:\"in\",33:\"notIn\",36:\"&&\",38:\"||\",40:\",\",42:\"IDENTIFIER\",43:\".\",44:\"[\",46:\"]\",48:\"(\",49:\")\",50:\"STRING\",51:\"NUMBER\",53:\"REGEXP\",55:\"BOOLEAN\",57:\"NULL\"},\nproductions_: [0,[3,2],[6,1],[6,2],[6,2],[10,1],[10,3],[10,3],[10,3],[14,1],[14,3],[14,3],[16,1],[16,3],[18,1],[18,3],[18,3],[18,3],[18,3],[23,1],[23,3],[23,3],[23,3],[23,3],[23,3],[23,3],[30,1],[30,3],[30,3],[30,3],[30,3],[35,1],[35,3],[37,1],[37,3],[39,1],[39,3],[41,1],[34,1],[34,3],[34,4],[34,4],[34,4],[34,3],[34,4],[45,1],[47,1],[52,1],[54,1],[56,1],[32,2],[32,3],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,3],[4,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\nreturn $$[$0-1];\nbreak;\ncase 3:\nthis.$ = [$$[$0], null, 'unary'];\nbreak;\ncase 4:\nthis.$ = [$$[$0], null, 'logicalNot'];\nbreak;\ncase 6:\nthis.$ = [$$[$0-2], $$[$0], 'mult'];\nbreak;\ncase 7:\nthis.$ = [$$[$0-2], $$[$0], 'div'];\nbreak;\ncase 8:\nthis.$ = [$$[$0-2], $$[$0], 'mod'];\nbreak;\ncase 10:\nthis.$ = [$$[$0-2], $$[$0], 'plus'];\nbreak;\ncase 11:\nthis.$ = [$$[$0-2], $$[$0], 'minus'];\nbreak;\ncase 13:\nthis.$ = [$$[$0-2], $$[$0], 'pow'];\nbreak;\ncase 15:\nthis.$ = [$$[$0-2], $$[$0], 'lt'];\nbreak;\ncase 16:\nthis.$ = [$$[$0-2], $$[$0], 'gt'];\nbreak;\ncase 17:\nthis.$ = [$$[$0-2], $$[$0], 'lte'];\nbreak;\ncase 18:\nthis.$ = [$$[$0-2], $$[$0], 'gte'];\nbreak;\ncase 20:\nthis.$ = [$$[$0-2], $$[$0], 'eq'];\nbreak;\ncase 21:\nthis.$ = [$$[$0-2], $$[$0], 'seq'];\nbreak;\ncase 22:\nthis.$ = [$$[$0-2], $$[$0], 'neq'];\nbreak;\ncase 23:\nthis.$ = [$$[$0-2], $$[$0], 'sneq'];\nbreak;\ncase 24:\nthis.$ = [$$[$0-2], $$[$0], 'like'];\nbreak;\ncase 25:\nthis.$ = [$$[$0-2], $$[$0], 'notLike'];\nbreak;\ncase 27: case 29:\nthis.$ = [$$[$0-2], $$[$0], 'in'];\nbreak;\ncase 28: case 30:\nthis.$ = [$$[$0-2], $$[$0], 'notIn'];\nbreak;\ncase 32:\nthis.$ = [$$[$0-2], $$[$0], 'and'];\nbreak;\ncase 34:\nthis.$ = [$$[$0-2], $$[$0], 'or'];\nbreak;\ncase 36:\nthis.$ = [$$[$0-2], $$[$0], 'arguments']\nbreak;\ncase 37:\nthis.$ = [String(yytext), null, 'identifier'];\nbreak;\ncase 39:\nthis.$ = [$$[$0-2],$$[$0], 'prop'];\nbreak;\ncase 40: case 41: case 42:\nthis.$ = [$$[$0-3],$$[$0-1], 'propLookup'];\nbreak;\ncase 43:\nthis.$ = [$$[$0-2], [null, null, 'arguments'], 'function']\nbreak;\ncase 44:\nthis.$ = [$$[$0-3], $$[$0-1], 'function']\nbreak;\ncase 45:\nthis.$ = [String(yytext.replace(/^['|\"]|['|\"]$/g, '')), null, 'string'];\nbreak;\ncase 46:\nthis.$ = [Number(yytext), null, 'number'];\nbreak;\ncase 47:\nthis.$ = [yytext, null, 'regexp'];\nbreak;\ncase 48:\nthis.$ = [yytext.replace(/^\\s+/, '') == 'true', null, 'boolean'];\nbreak;\ncase 49:\nthis.$ = [null, null, 'null'];\nbreak;\ncase 50:\nthis.$ = [null, null, 'array'];\nbreak;\ncase 51:\nthis.$ = [$$[$0-1], null, 'array'];\nbreak;\ncase 59:\nthis.$ = [$$[$0-1], null, 'composite']\nbreak;\n}\n},\ntable: [{3:1,4:2,6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:4,37:3,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{1:[3]},{5:[1,31]},o([5,49],[2,60],{38:[1,32]}),o($Va,[2,33],{36:$Vb}),o($Vc,[2,31]),o($Vc,[2,26],{24:[1,34],25:[1,35],26:[1,36],27:[1,37],28:[1,38],29:[1,39]}),o($Vd,$Ve,{31:[1,40],33:[1,41]}),o($Vf,[2,19],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vk,[2,52]),o($Vk,[2,53]),o($Vk,[2,54]),o($Vk,[2,55]),o($Vk,[2,56]),o($Vk,[2,57],{43:$Vl,44:$Vm,48:$Vn}),o($Vk,[2,58]),{4:49,6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:4,37:3,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vo,[2,14],{17:$Vp}),o($Vk,[2,45]),o($Vk,[2,46]),o($Vk,[2,47]),o($Vk,[2,48]),o($Vk,[2,49]),o($Vq,[2,38]),{7:53,32:15,34:14,39:52,41:23,42:$V2,44:$V3,45:9,46:[1,51],47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vr,[2,12],{8:$Vs,15:$Vt}),o($Vq,[2,37]),o($Vu,[2,9],{11:$Vv,12:$Vw,13:$Vx}),o($Vd,[2,5]),{6:59,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:61,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{1:[2,1]},{6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:5,32:15,34:14,35:62,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:7,8:$V0,9:$V1,10:27,14:25,16:17,18:8,23:6,30:63,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:64,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:65,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:66,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:67,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:68,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:17,18:69,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{32:70,34:71,41:23,42:$V2,44:$V3},{32:72,34:73,41:23,42:$V2,44:$V3},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:74,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:75,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:76,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:27,14:25,16:77,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{41:78,42:$V2},{34:81,41:23,42:$V2,45:79,47:80,50:$V5,51:$V6},{7:53,32:15,34:14,39:83,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,49:[1,82],50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{49:[1,84]},{6:28,7:60,8:$V0,9:$V1,10:27,14:85,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vk,[2,50]),{40:$Vy,46:[1,86]},o($Vz,[2,35]),{6:28,7:60,8:$V0,9:$V1,10:88,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:28,7:60,8:$V0,9:$V1,10:89,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:90,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:91,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},{6:92,7:60,8:$V0,9:$V1,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vd,[2,3]),o($Vd,$Ve),o($Vd,[2,4]),o($Va,[2,34],{36:$Vb}),o($Vc,[2,32]),o($Vf,[2,20],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,21],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,22],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,23],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,24],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vf,[2,25],{19:$Vg,20:$Vh,21:$Vi,22:$Vj}),o($Vc,[2,27]),o($Vc,[2,29],{43:$Vl,44:$Vm,48:$Vn}),o($Vc,[2,28]),o($Vc,[2,30],{43:$Vl,44:$Vm,48:$Vn}),o($Vo,[2,15],{17:$Vp}),o($Vo,[2,16],{17:$Vp}),o($Vo,[2,17],{17:$Vp}),o($Vo,[2,18],{17:$Vp}),o($Vq,[2,39]),{46:[1,93]},{46:[1,94]},{43:$Vl,44:$Vm,46:[1,95],48:$Vn},o($Vq,[2,43]),{40:$Vy,49:[1,96]},o($Vk,[2,59]),o($Vr,[2,13],{8:$Vs,15:$Vt}),o($Vk,[2,51]),{7:97,32:15,34:14,41:23,42:$V2,44:$V3,45:9,47:10,48:$V4,50:$V5,51:$V6,52:11,53:$V7,54:12,55:$V8,56:13,57:$V9},o($Vu,[2,10],{11:$Vv,12:$Vw,13:$Vx}),o($Vu,[2,11],{11:$Vv,12:$Vw,13:$Vx}),o($Vd,[2,6]),o($Vd,[2,7]),o($Vd,[2,8]),o($Vq,[2,40]),o($Vq,[2,41]),o($Vq,[2,42]),o($Vq,[2,44]),o($Vz,[2,36])],\ndefaultActions: {31:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return 31;\nbreak;\ncase 1:return 33;\nbreak;\ncase 2:return 'from';\nbreak;\ncase 3:return 24;\nbreak;\ncase 4:return 25;\nbreak;\ncase 5:return 26;\nbreak;\ncase 6:return 27;\nbreak;\ncase 7:return 21;\nbreak;\ncase 8:return 19;\nbreak;\ncase 9:return 22;\nbreak;\ncase 10:return 20;\nbreak;\ncase 11:return 28;\nbreak;\ncase 12:return 29;\nbreak;\ncase 13:return 36;\nbreak;\ncase 14:return 38;\nbreak;\ncase 15:return 57;\nbreak;\ncase 16:return 55;\nbreak;\ncase 17:/* skip whitespace */\nbreak;\ncase 18:return 51;\nbreak;\ncase 19:return 50;\nbreak;\ncase 20:return 50;\nbreak;\ncase 21:return 42;\nbreak;\ncase 22:return 53;\nbreak;\ncase 23:return 43;\nbreak;\ncase 24:return 11;\nbreak;\ncase 25:return 12;\nbreak;\ncase 26:return 13;\nbreak;\ncase 27:return 40;\nbreak;\ncase 28:return 8;\nbreak;\ncase 29:return 28;\nbreak;\ncase 30:return 29;\nbreak;\ncase 31:return 25;\nbreak;\ncase 32:return 24;\nbreak;\ncase 33:return 27;\nbreak;\ncase 34:return 26;\nbreak;\ncase 35:return 21;\nbreak;\ncase 36:return 22;\nbreak;\ncase 37:return 20;\nbreak;\ncase 38:return 19;\nbreak;\ncase 39:return 36;\nbreak;\ncase 40:return 38;\nbreak;\ncase 41:return 15;\nbreak;\ncase 42:return 17;\nbreak;\ncase 43:return 48;\nbreak;\ncase 44:return 46;\nbreak;\ncase 45:return 44;\nbreak;\ncase 46:return 49;\nbreak;\ncase 47:return 9;\nbreak;\ncase 48:return 5;\nbreak;\n}\n},\nrules: [/^(?:\\s+in\\b)/,/^(?:\\s+notIn\\b)/,/^(?:\\s+from\\b)/,/^(?:\\s+(eq|EQ)\\b)/,/^(?:\\s+(seq|SEQ)\\b)/,/^(?:\\s+(neq|NEQ)\\b)/,/^(?:\\s+(sneq|SNEQ)\\b)/,/^(?:\\s+(lte|LTE)\\b)/,/^(?:\\s+(lt|LT)\\b)/,/^(?:\\s+(gte|GTE)\\b)/,/^(?:\\s+(gt|GT)\\b)/,/^(?:\\s+(like|LIKE)\\b)/,/^(?:\\s+(notLike|NOT_LIKE)\\b)/,/^(?:\\s+(and|AND)\\b)/,/^(?:\\s+(or|OR)\\b)/,/^(?:\\s*(null)\\b)/,/^(?:\\s*(true|false)\\b)/,/^(?:\\s+)/,/^(?:-?[0-9]+(?:\\.[0-9]+)?\\b)/,/^(?:'[^']*')/,/^(?:\"[^\"]*\")/,/^(?:([a-zA-Z_$][0-9a-zA-Z_$]*))/,/^(?:^\\/((?![\\s=])[^[\\/\\n\\\\]*(?:(?:\\\\[\\s\\S]|\\[[^\\]\\n\\\\]*(?:\\\\[\\s\\S][^\\]\\n\\\\]*)*])[^[\\/\\n\\\\]*)*\\/[imgy]{0,4})(?!\\w))/,/^(?:\\.)/,/^(?:\\*)/,/^(?:\\/)/,/^(?:\\%)/,/^(?:,)/,/^(?:-)/,/^(?:=~)/,/^(?:!=~)/,/^(?:===)/,/^(?:==)/,/^(?:!==)/,/^(?:!=)/,/^(?:<=)/,/^(?:>=)/,/^(?:>)/,/^(?:<)/,/^(?:&&)/,/^(?:\\|\\|)/,/^(?:\\+)/,/^(?:\\^)/,/^(?:\\()/,/^(?:\\])/,/^(?:\\[)/,/^(?:\\))/,/^(?:!)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/nools/nool.parser.js":"\"use strict\";\n\nvar tokens = require(\"./tokens.js\"),\n    extd = require(\"../../extended\"),\n    keys = extd.hash.keys,\n    utils = require(\"./util.js\");\n\nvar parse = function (src, keywords, context) {\n    var orig = src;\n    src = src.replace(/\\/\\/(.*)/g, \"\").replace(/\\r\\n|\\r|\\n/g, \" \");\n\n    var blockTypes = new RegExp(\"^(\" + keys(keywords).join(\"|\") + \")\"), index;\n    while (src && (index = utils.findNextTokenIndex(src)) !== -1) {\n        src = src.substr(index);\n        var blockType = src.match(blockTypes);\n        if (blockType !== null) {\n            blockType = blockType[1];\n            if (blockType in keywords) {\n                try {\n                    src = keywords[blockType](src, context, parse).replace(/^\\s*|\\s*$/g, \"\");\n                } catch (e) {\n                    throw new Error(\"Invalid \" + blockType + \" definition \\n\" + e.message + \"; \\nstarting at : \" + orig);\n                }\n            } else {\n                throw new Error(\"Unknown token\" + blockType);\n            }\n        } else {\n            throw new Error(\"Error parsing \" + src);\n        }\n    }\n};\n\nexports.parse = function (src, file) {\n    var context = {define: [], rules: [], scope: [], loaded: [], file: file};\n    parse(src, tokens, context);\n    return context;\n};\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/nools/tokens.js":"\"use strict\";\n\nvar utils = require(\"./util.js\"),\n    fs = require(\"fs\"),\n    extd = require(\"../../extended\"),\n    filter = extd.filter,\n    indexOf = extd.indexOf,\n    predicates = [\"not\", \"or\", \"exists\"],\n    predicateRegExp = new RegExp(\"^(\" + predicates.join(\"|\") + \") *\\\\((.*)\\\\)$\", \"m\"),\n    predicateBeginExp = new RegExp(\" *(\" + predicates.join(\"|\") + \") *\\\\(\", \"g\");\n\nvar isWhiteSpace = function (str) {\n    return str.replace(/[\\s|\\n|\\r|\\t]/g, \"\").length === 0;\n};\n\nvar joinFunc = function (m, str) {\n    return \"; \" + str;\n};\n\nvar splitRuleLineByPredicateExpressions = function (ruleLine) {\n    var str = ruleLine.replace(/,\\s*(\\$?\\w+\\s*:)/g, joinFunc);\n    var parts = filter(str.split(predicateBeginExp), function (str) {\n            return str !== \"\";\n        }),\n        l = parts.length, ret = [];\n\n    if (l) {\n        for (var i = 0; i < l; i++) {\n            if (indexOf(predicates, parts[i]) !== -1) {\n                ret.push([parts[i], \"(\", parts[++i].replace(/, *$/, \"\")].join(\"\"));\n            } else {\n                ret.push(parts[i].replace(/, *$/, \"\"));\n            }\n        }\n    } else {\n        return str;\n    }\n    return ret.join(\";\");\n};\n\nvar ruleTokens = {\n\n    salience: (function () {\n        var salienceRegexp = /^(salience|priority)\\s*:\\s*(-?\\d+)\\s*[,;]?/;\n        return function (src, context) {\n            if (salienceRegexp.test(src)) {\n                var parts = src.match(salienceRegexp),\n                    priority = parseInt(parts[2], 10);\n                if (!isNaN(priority)) {\n                    context.options.priority = priority;\n                } else {\n                    throw new Error(\"Invalid salience/priority \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    agendaGroup: (function () {\n        var agendaGroupRegexp = /^(agenda-group|agendaGroup)\\s*:\\s*([a-zA-Z_$][0-9a-zA-Z_$]*|\"[^\"]*\"|'[^']*')\\s*[,;]?/;\n        return function (src, context) {\n            if (agendaGroupRegexp.test(src)) {\n                var parts = src.match(agendaGroupRegexp),\n                    agendaGroup = parts[2];\n                if (agendaGroup) {\n                    context.options.agendaGroup = agendaGroup.replace(/^[\"']|[\"']$/g, \"\");\n                } else {\n                    throw new Error(\"Invalid agenda-group \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    autoFocus: (function () {\n        var autoFocusRegexp = /^(auto-focus|autoFocus)\\s*:\\s*(true|false)\\s*[,;]?/;\n        return function (src, context) {\n            if (autoFocusRegexp.test(src)) {\n                var parts = src.match(autoFocusRegexp),\n                    autoFocus = parts[2];\n                if (autoFocus) {\n                    context.options.autoFocus = autoFocus === \"true\" ? true : false;\n                } else {\n                    throw new Error(\"Invalid auto-focus \" + parts[2]);\n                }\n                return src.replace(parts[0], \"\");\n            } else {\n                throw new Error(\"invalid format\");\n            }\n        };\n    })(),\n\n    \"agenda-group\": function () {\n        return this.agendaGroup.apply(this, arguments);\n    },\n\n    \"auto-focus\": function () {\n        return this.autoFocus.apply(this, arguments);\n    },\n\n    priority: function () {\n        return this.salience.apply(this, arguments);\n    },\n\n    when: (function () {\n        /*jshint evil:true*/\n\n        var ruleRegExp = /^(\\$?\\w+) *: *(\\w+)(.*)/;\n\n        var constraintRegExp = /(\\{ *(?:[\"']?\\$?\\w+[\"']?\\s*:\\s*[\"']?\\$?\\w+[\"']? *(?:, *[\"']?\\$?\\w+[\"']?\\s*:\\s*[\"']?\\$?\\w+[\"']?)*)+ *\\})/;\n        var fromRegExp = /(\\bfrom\\s+.*)/;\n        var parseRules = function (str) {\n            var rules = [];\n            var ruleLines = str.split(\";\"), l = ruleLines.length, ruleLine;\n            for (var i = 0; i < l && (ruleLine = ruleLines[i].replace(/^\\s*|\\s*$/g, \"\").replace(/\\n/g, \"\")); i++) {\n                if (!isWhiteSpace(ruleLine)) {\n                    var rule = [];\n                    if (predicateRegExp.test(ruleLine)) {\n                        var m = ruleLine.match(predicateRegExp);\n                        var pred = m[1].replace(/^\\s*|\\s*$/g, \"\");\n                        rule.push(pred);\n                        ruleLine = m[2].replace(/^\\s*|\\s*$/g, \"\");\n                        if (pred === \"or\") {\n                            rule = rule.concat(parseRules(splitRuleLineByPredicateExpressions(ruleLine)));\n                            rules.push(rule);\n                            continue;\n                        }\n\n                    }\n                    var parts = ruleLine.match(ruleRegExp);\n                    if (parts && parts.length) {\n                        rule.push(parts[2], parts[1]);\n                        var constraints = parts[3].replace(/^\\s*|\\s*$/g, \"\");\n                        var hashParts = constraints.match(constraintRegExp), from = null, fromMatch;\n                        if (hashParts) {\n                            var hash = hashParts[1], constraint = constraints.replace(hash, \"\");\n                            if (fromRegExp.test(constraint)) {\n                                fromMatch = constraint.match(fromRegExp);\n                                from = fromMatch[0];\n                                constraint = constraint.replace(fromMatch[0], \"\");\n                            }\n                            if (constraint) {\n                                rule.push(constraint.replace(/^\\s*|\\s*$/g, \"\"));\n                            }\n                            if (hash) {\n                                rule.push(eval(\"(\" + hash.replace(/(\\$?\\w+)\\s*:\\s*(\\$?\\w+)/g, '\"$1\" : \"$2\"') + \")\"));\n                            }\n                        } else if (constraints && !isWhiteSpace(constraints)) {\n                            if (fromRegExp.test(constraints)) {\n                                fromMatch = constraints.match(fromRegExp);\n                                from = fromMatch[0];\n                                constraints = constraints.replace(fromMatch[0], \"\");\n                            }\n                            rule.push(constraints);\n                        }\n                        if (from) {\n                            rule.push(from);\n                        }\n                        rules.push(rule);\n                    } else {\n                        throw new Error(\"Invalid constraint \" + ruleLine);\n                    }\n                }\n            }\n            return rules;\n        };\n\n        return function (orig, context) {\n            var src = orig.replace(/^when\\s*/, \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                context.constraints = parseRules(body.replace(/^\\{\\s*|\\}\\s*$/g, \"\"));\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        };\n    })(),\n\n    then: (function () {\n        return function (orig, context) {\n            if (!context.action) {\n                var src = orig.replace(/^then\\s*/, \"\").replace(/^\\s*|\\s*$/g, \"\");\n                if (utils.findNextToken(src) === \"{\") {\n                    var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                    src = src.replace(body, \"\");\n                    if (!context.action) {\n                        context.action = body.replace(/^\\{\\s*|\\}\\s*$/g, \"\");\n                    }\n                    if (!isWhiteSpace(src)) {\n                        throw new Error(\"Error parsing then block \" + orig);\n                    }\n                    return src;\n                } else {\n                    throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n                }\n            } else {\n                throw new Error(\"action already defined for rule\" + context.name);\n            }\n\n        };\n    })()\n};\n\nvar topLevelTokens = {\n    \"/\": function (orig) {\n        if (orig.match(/^\\/\\*/)) {\n            // Block Comment parse\n            return orig.replace(/\\/\\*.*?\\*\\//, \"\");\n        } else {\n            return orig;\n        }\n    },\n\n    \"define\": function (orig, context) {\n        var src = orig.replace(/^define\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*)/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                name = name[1];\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                //should\n                context.define.push({name: name, properties: \"(\" + body + \")\"});\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    \"import\": function (orig, context, parse) {\n        if (typeof window !== 'undefined') {\n            throw new Error(\"import cannot be used in a browser\");\n        }\n        var src = orig.replace(/^import\\s*/, \"\");\n        if (utils.findNextToken(src) === \"(\") {\n            var file = utils.getParamList(src);\n            src = src.replace(file, \"\").replace(/^\\s*|\\s*$/g, \"\");\n            utils.findNextToken(src) === \";\" && (src = src.replace(/\\s*;/, \"\"));\n            file = file.replace(/[\\(|\\)]/g, \"\").split(\",\");\n            if (file.length === 1) {\n                file = utils.resolve(context.file || process.cwd(), file[0].replace(/[\"|']/g, \"\"));\n                if (indexOf(context.loaded, file) === -1) {\n                    var origFile = context.file;\n                    context.file = file;\n                    parse(fs.readFileSync(file, \"utf8\"), topLevelTokens, context);\n                    context.loaded.push(file);\n                    context.file = origFile;\n                }\n                return src;\n            } else {\n                throw new Error(\"import accepts a single file\");\n            }\n        } else {\n            throw new Error(\"unexpected token : expected : '(' found : '\" + utils.findNextToken(src) + \"'\");\n        }\n\n    },\n\n    //define a global\n    \"global\": function (orig, context) {\n        var src = orig.replace(/^global\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*\\s*)/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"=\") {\n                name = name[1].replace(/^\\s+|\\s+$/g, '');\n                var fullbody = utils.getTokensBetween(src, \"=\", \";\", true).join(\"\");\n                var body = fullbody.substring(1, fullbody.length - 1);\n                body = body.replace(/^\\s+|\\s+$/g, '');\n                if (/^require\\(/.test(body)) {\n                    var file = utils.getParamList(body.replace(\"require\")).replace(/[\\(|\\)]/g, \"\").split(\",\");\n                    if (file.length === 1) {\n                        //handle relative require calls\n                        file = file[0].replace(/[\"|']/g, \"\");\n                        body = [\"require('\", utils.resolve(context.file || process.cwd(), file) , \"')\"].join(\"\");\n                    }\n                }\n                context.scope.push({name: name, body: body});\n                src = src.replace(fullbody, \"\");\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '=' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    //define a function\n    \"function\": function (orig, context) {\n        var src = orig.replace(/^function\\s*/, \"\");\n        //parse the function name\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*)\\s*/);\n        if (name) {\n            src = src.replace(name[0], \"\");\n            if (utils.findNextToken(src) === \"(\") {\n                name = name[1];\n                var params = utils.getParamList(src);\n                src = src.replace(params, \"\").replace(/^\\s*|\\s*$/g, \"\");\n                if (utils.findNextToken(src) === \"{\") {\n                    var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                    src = src.replace(body, \"\");\n                    //should\n                    context.scope.push({name: name, body: \"function\" + params + body});\n                    return src;\n                } else {\n                    throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n                }\n            } else {\n                throw new Error(\"unexpected token : expected : '(' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n    },\n\n    \"rule\": function (orig, context, parse) {\n        var src = orig.replace(/^rule\\s*/, \"\");\n        var name = src.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*|\"[^\"]*\"|'[^']*')/);\n        if (name) {\n            src = src.replace(name[0], \"\").replace(/^\\s*|\\s*$/g, \"\");\n            if (utils.findNextToken(src) === \"{\") {\n                name = name[1].replace(/^[\"']|[\"']$/g, \"\");\n                var rule = {name: name, options: {}, constraints: null, action: null};\n                var body = utils.getTokensBetween(src, \"{\", \"}\", true).join(\"\");\n                src = src.replace(body, \"\");\n                parse(body.replace(/^\\{\\s*|\\}\\s*$/g, \"\"), ruleTokens, rule);\n                context.rules.push(rule);\n                return src;\n            } else {\n                throw new Error(\"unexpected token : expected : '{' found : '\" + utils.findNextToken(src) + \"'\");\n            }\n        } else {\n            throw new Error(\"missing name\");\n        }\n\n    }\n};\nmodule.exports = topLevelTokens;\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/parser/nools/util.js":"\"use strict\";\n\nvar path = require(\"path\");\nvar WHITE_SPACE_REG = /[\\s|\\n|\\r|\\t]/,\n    pathSep = path.sep || ( process.platform === 'win32' ? '\\\\' : '/' );\n\nvar TOKEN_INVERTS = {\n    \"{\": \"}\",\n    \"}\": \"{\",\n    \"(\": \")\",\n    \")\": \"(\",\n    \"[\": \"]\"\n};\n\nvar getTokensBetween = exports.getTokensBetween = function (str, start, stop, includeStartEnd) {\n    var depth = 0, ret = [];\n    if (!start) {\n        start = TOKEN_INVERTS[stop];\n        depth = 1;\n    }\n    if (!stop) {\n        stop = TOKEN_INVERTS[start];\n    }\n    str = Object(str);\n    var startPushing = false, token, cursor = 0, found = false;\n    while ((token = str.charAt(cursor++))) {\n        if (token === start) {\n            depth++;\n            if (!startPushing) {\n                startPushing = true;\n                if (includeStartEnd) {\n                    ret.push(token);\n                }\n            } else {\n                ret.push(token);\n            }\n        } else if (token === stop && cursor) {\n            depth--;\n            if (depth === 0) {\n                if (includeStartEnd) {\n                    ret.push(token);\n                }\n                found = true;\n                break;\n            }\n            ret.push(token);\n        } else if (startPushing) {\n            ret.push(token);\n        }\n    }\n    if (!found) {\n        throw new Error(\"Unable to match \" + start + \" in \" + str);\n    }\n    return ret;\n};\n\nexports.getParamList = function (str) {\n    return  getTokensBetween(str, \"(\", \")\", true).join(\"\");\n};\n\nexports.resolve = function (from, to) {\n    if (process.platform === 'win32') {\n        to = to.replace(/\\//g, '\\\\');\n    }\n    if (path.extname(from) !== '') {\n        from = path.dirname(from);\n    }\n    if (to.split(pathSep).length === 1) {\n        return to;\n    }\n    return path.resolve(from, to).replace(/\\\\/g, '/');\n\n};\n\nvar findNextTokenIndex = exports.findNextTokenIndex = function (str, startIndex, endIndex) {\n    startIndex = startIndex || 0;\n    endIndex = endIndex || str.length;\n    var ret = -1, l = str.length;\n    if (!endIndex || endIndex > l) {\n        endIndex = l;\n    }\n    for (; startIndex < endIndex; startIndex++) {\n        var c = str.charAt(startIndex);\n        if (!WHITE_SPACE_REG.test(c)) {\n            ret = startIndex;\n            break;\n        }\n    }\n    return ret;\n};\n\nexports.findNextToken = function (str, startIndex, endIndex) {\n    return str.charAt(findNextTokenIndex(str, startIndex, endIndex));\n};","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/constraintMatcher.js":"\"use strict\";\n\nvar extd = require(\"./extended\"),\n    isArray = extd.isArray,\n    forEach = extd.forEach,\n    some = extd.some,\n    indexOf = extd.indexOf,\n    isNumber = extd.isNumber,\n    removeDups = extd.removeDuplicates,\n    atoms = require(\"./constraint\");\n\nfunction getProps(val) {\n    return extd(val).map(function mapper(val) {\n        return isArray(val) ? isArray(val[0]) ? getProps(val).value() : val.reverse().join(\".\") : val;\n    }).flatten().filter(function (v) {\n        return !!v;\n    });\n}\n\nvar definedFuncs = {\n    indexOf: extd.indexOf,\n    now: function () {\n        return new Date();\n    },\n\n    Date: function (y, m, d, h, min, s, ms) {\n        var date = new Date();\n        if (isNumber(y)) {\n            date.setYear(y);\n        }\n        if (isNumber(m)) {\n            date.setMonth(m);\n        }\n        if (isNumber(d)) {\n            date.setDate(d);\n        }\n        if (isNumber(h)) {\n            date.setHours(h);\n        }\n        if (isNumber(min)) {\n            date.setMinutes(min);\n        }\n        if (isNumber(s)) {\n            date.setSeconds(s);\n        }\n        if (isNumber(ms)) {\n            date.setMilliseconds(ms);\n        }\n        return date;\n    },\n\n    lengthOf: function (arr, length) {\n        return arr.length === length;\n    },\n\n    isTrue: function (val) {\n        return val === true;\n    },\n\n    isFalse: function (val) {\n        return val === false;\n    },\n\n    isNotNull: function (actual) {\n        return actual !== null;\n    },\n\n    dateCmp: function (dt1, dt2) {\n        return extd.compare(dt1, dt2);\n    }\n\n};\n\nforEach([\"years\", \"days\", \"months\", \"hours\", \"minutes\", \"seconds\"], function (k) {\n    definedFuncs[k + \"FromNow\"] = extd[k + \"FromNow\"];\n    definedFuncs[k + \"Ago\"] = extd[k + \"Ago\"];\n});\n\n\nforEach([\"isArray\", \"isNumber\", \"isHash\", \"isObject\", \"isDate\", \"isBoolean\", \"isString\", \"isRegExp\", \"isNull\", \"isEmpty\",\n    \"isUndefined\", \"isDefined\", \"isUndefinedOrNull\", \"isPromiseLike\", \"isFunction\", \"deepEqual\"], function (k) {\n    var m = extd[k];\n    definedFuncs[k] = function () {\n        return m.apply(extd, arguments);\n    };\n});\n\n\nvar lang = {\n\n    equal: function (c1, c2) {\n        var ret = false;\n        if (c1 === c2) {\n            ret = true;\n        } else {\n            if (c1[2] === c2[2]) {\n                if (indexOf([\"string\", \"number\", \"boolean\", \"regexp\", \"identifier\", \"null\"], c1[2]) !== -1) {\n                    ret = c1[0] === c2[0];\n                } else if (c1[2] === \"unary\" || c1[2] === \"logicalNot\") {\n                    ret = this.equal(c1[0], c2[0]);\n                } else {\n                    ret = this.equal(c1[0], c2[0]) && this.equal(c1[1], c2[1]);\n                }\n            }\n        }\n        return ret;\n    },\n\n    __getProperties: function (rule) {\n        var ret = [];\n        if (rule) {\n            var rule2 = rule[2];\n            if (!rule2) {\n                return ret;\n            }\n            if (rule2 !== \"prop\" &&\n                rule2 !== \"identifier\" &&\n                rule2 !== \"string\" &&\n                rule2 !== \"number\" &&\n                rule2 !== \"boolean\" &&\n                rule2 !== \"regexp\" &&\n                rule2 !== \"unary\" &&\n                rule2 !== \"unary\") {\n                ret[0] = this.__getProperties(rule[0]);\n                ret[1] = this.__getProperties(rule[1]);\n            } else if (rule2 === \"identifier\") {\n                //at the bottom\n                ret = [rule[0]];\n            } else {\n                ret = lang.__getProperties(rule[1]).concat(lang.__getProperties(rule[0]));\n            }\n        }\n        return ret;\n    },\n\n    getIndexableProperties: function (rule) {\n        if (rule[2] === \"composite\") {\n            return this.getIndexableProperties(rule[0]);\n        } else if (/^(\\w+(\\['[^']*'])*) *([!=]==?|[<>]=?) (\\w+(\\['[^']*'])*)$/.test(this.parse(rule))) {\n            return getProps(this.__getProperties(rule)).flatten().value();\n        } else {\n            return [];\n        }\n    },\n\n    getIdentifiers: function (rule) {\n        var ret = [];\n        var rule2 = rule[2];\n\n        if (rule2 === \"identifier\") {\n            //its an identifier so stop\n            return [rule[0]];\n        } else if (rule2 === \"function\") {\n            ret = ret.concat(this.getIdentifiers(rule[0])).concat(this.getIdentifiers(rule[1]));\n        } else if (rule2 !== \"string\" &&\n            rule2 !== \"number\" &&\n            rule2 !== \"boolean\" &&\n            rule2 !== \"regexp\" &&\n            rule2 !== \"unary\" &&\n            rule2 !== \"unary\") {\n            //its an expression so keep going\n            if (rule2 === \"prop\") {\n                ret = ret.concat(this.getIdentifiers(rule[0]));\n                if (rule[1]) {\n                    var propChain = rule[1];\n                    //go through the member variables and collect any identifiers that may be in functions\n                    while (isArray(propChain)) {\n                        if (propChain[2] === \"function\") {\n                            ret = ret.concat(this.getIdentifiers(propChain[1]));\n                            break;\n                        } else {\n                            propChain = propChain[1];\n                        }\n                    }\n                }\n\n            } else {\n                if (rule[0]) {\n                    ret = ret.concat(this.getIdentifiers(rule[0]));\n                }\n                if (rule[1]) {\n                    ret = ret.concat(this.getIdentifiers(rule[1]));\n                }\n            }\n        }\n        //remove dups and return\n        return removeDups(ret);\n    },\n\n    toConstraints: function (rule, options) {\n        var ret = [],\n            alias = options.alias,\n            scope = options.scope || {};\n\n        var rule2 = rule[2];\n\n\n        if (rule2 === \"and\") {\n            ret = ret.concat(this.toConstraints(rule[0], options)).concat(this.toConstraints(rule[1], options));\n        } else if (\n            rule2 === \"composite\" ||\n            rule2 === \"or\" ||\n            rule2 === \"lt\" ||\n            rule2 === \"gt\" ||\n            rule2 === \"lte\" ||\n            rule2 === \"gte\" ||\n            rule2 === \"like\" ||\n            rule2 === \"notLike\" ||\n            rule2 === \"eq\" ||\n            rule2 === \"neq\" ||\n            rule2 === \"seq\" ||\n            rule2 === \"sneq\" ||\n            rule2 === \"in\" ||\n            rule2 === \"notIn\" ||\n            rule2 === \"prop\" ||\n            rule2 === \"propLookup\" ||\n            rule2 === \"function\" ||\n            rule2 === \"logicalNot\") {\n            var isReference = some(this.getIdentifiers(rule), function (i) {\n                return i !== alias && !(i in definedFuncs) && !(i in scope);\n            });\n            switch (rule2) {\n            case \"eq\":\n                ret.push(new atoms[isReference ? \"ReferenceEqualityConstraint\" : \"EqualityConstraint\"](rule, options));\n                break;\n            case \"seq\":\n                ret.push(new atoms[isReference ? \"ReferenceEqualityConstraint\" : \"EqualityConstraint\"](rule, options));\n                break;\n            case \"neq\":\n                ret.push(new atoms[isReference ? \"ReferenceInequalityConstraint\" : \"InequalityConstraint\"](rule, options));\n                break;\n            case \"sneq\":\n                ret.push(new atoms[isReference ? \"ReferenceInequalityConstraint\" : \"InequalityConstraint\"](rule, options));\n                break;\n            case \"gt\":\n                ret.push(new atoms[isReference ? \"ReferenceGTConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"gte\":\n                ret.push(new atoms[isReference ? \"ReferenceGTEConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"lt\":\n                ret.push(new atoms[isReference ? \"ReferenceLTConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            case \"lte\":\n                ret.push(new atoms[isReference ? \"ReferenceLTEConstraint\" : \"ComparisonConstraint\"](rule, options));\n                break;\n            default:\n                ret.push(new atoms[isReference ? \"ReferenceConstraint\" : \"ComparisonConstraint\"](rule, options));\n            }\n\n        }\n        return ret;\n    },\n\n\n    parse: function (rule) {\n        return this[rule[2]](rule[0], rule[1]);\n    },\n\n    composite: function (lhs) {\n        return this.parse(lhs);\n    },\n\n    and: function (lhs, rhs) {\n        return [\"(\", this.parse(lhs), \"&&\", this.parse(rhs), \")\"].join(\" \");\n    },\n\n    or: function (lhs, rhs) {\n        return [\"(\", this.parse(lhs), \"||\", this.parse(rhs), \")\"].join(\" \");\n    },\n\n    prop: function (name, prop) {\n        if (prop[2] === \"function\") {\n            return [this.parse(name), this.parse(prop)].join(\".\");\n        } else {\n            return [this.parse(name), \"['\", this.parse(prop), \"']\"].join(\"\");\n        }\n    },\n\n    propLookup: function (name, prop) {\n        if (prop[2] === \"function\") {\n            return [this.parse(name), this.parse(prop)].join(\".\");\n        } else {\n            return [this.parse(name), \"[\", this.parse(prop), \"]\"].join(\"\");\n        }\n    },\n\n    unary: function (lhs) {\n        return -1 * this.parse(lhs);\n    },\n\n    plus: function (lhs, rhs) {\n        return [this.parse(lhs), \"+\", this.parse(rhs)].join(\" \");\n    },\n    minus: function (lhs, rhs) {\n        return [this.parse(lhs), \"-\", this.parse(rhs)].join(\" \");\n    },\n\n    mult: function (lhs, rhs) {\n        return [this.parse(lhs), \"*\", this.parse(rhs)].join(\" \");\n    },\n\n    div: function (lhs, rhs) {\n        return [this.parse(lhs), \"/\", this.parse(rhs)].join(\" \");\n    },\n\n    mod: function (lhs, rhs) {\n        return [this.parse(lhs), \"%\", this.parse(rhs)].join(\" \");\n    },\n\n    lt: function (lhs, rhs) {\n        return [this.parse(lhs), \"<\", this.parse(rhs)].join(\" \");\n    },\n    gt: function (lhs, rhs) {\n        return [this.parse(lhs), \">\", this.parse(rhs)].join(\" \");\n    },\n    lte: function (lhs, rhs) {\n        return [this.parse(lhs), \"<=\", this.parse(rhs)].join(\" \");\n    },\n    gte: function (lhs, rhs) {\n        return [this.parse(lhs), \">=\", this.parse(rhs)].join(\" \");\n    },\n    like: function (lhs, rhs) {\n        return [this.parse(rhs), \".test(\", this.parse(lhs), \")\"].join(\"\");\n    },\n    notLike: function (lhs, rhs) {\n        return [\"!\", this.parse(rhs), \".test(\", this.parse(lhs), \")\"].join(\"\");\n    },\n    eq: function (lhs, rhs) {\n        return [this.parse(lhs), \"==\", this.parse(rhs)].join(\" \");\n    },\n\n    seq: function (lhs, rhs) {\n        return [this.parse(lhs), \"===\", this.parse(rhs)].join(\" \");\n    },\n\n    neq: function (lhs, rhs) {\n        return [this.parse(lhs), \"!=\", this.parse(rhs)].join(\" \");\n    },\n\n    sneq: function (lhs, rhs) {\n        return [this.parse(lhs), \"!==\", this.parse(rhs)].join(\" \");\n    },\n\n    \"in\": function (lhs, rhs) {\n        return [\"(indexOf(\", this.parse(rhs), \",\", this.parse(lhs), \")) != -1\"].join(\"\");\n    },\n\n    \"notIn\": function (lhs, rhs) {\n        return [\"(indexOf(\", this.parse(rhs), \",\", this.parse(lhs), \")) == -1\"].join(\"\");\n    },\n\n    \"arguments\": function (lhs, rhs) {\n        var ret = [];\n        if (lhs) {\n            ret.push(this.parse(lhs));\n        }\n        if (rhs) {\n            ret.push(this.parse(rhs));\n        }\n        return ret.join(\",\");\n    },\n\n    \"array\": function (lhs) {\n        var args = [];\n        if (lhs) {\n            args = this.parse(lhs);\n            if (isArray(args)) {\n                return args;\n            } else {\n                return [\"[\", args, \"]\"].join(\"\");\n            }\n        }\n        return [\"[\", args.join(\",\"), \"]\"].join(\"\");\n    },\n\n    \"function\": function (lhs, rhs) {\n        var args = this.parse(rhs);\n        return [this.parse(lhs), \"(\", args, \")\"].join(\"\");\n    },\n\n    \"string\": function (lhs) {\n        return \"'\" + lhs + \"'\";\n    },\n\n    \"number\": function (lhs) {\n        return lhs;\n    },\n\n    \"boolean\": function (lhs) {\n        return lhs;\n    },\n\n    regexp: function (lhs) {\n        return lhs;\n    },\n\n    identifier: function (lhs) {\n        return lhs;\n    },\n\n    \"null\": function () {\n        return \"null\";\n    },\n\n    logicalNot: function (lhs) {\n        return [\"!(\", this.parse(lhs), \")\"].join(\"\");\n    }\n};\n\nvar matcherCount = 0;\nvar toJs = exports.toJs = function (rule, scope, alias, equality, wrap) {\n    /*jshint evil:true*/\n    var js = lang.parse(rule);\n    scope = scope || {};\n    var vars = lang.getIdentifiers(rule);\n    var closureVars = [\"var indexOf = definedFuncs.indexOf; var hasOwnProperty = Object.prototype.hasOwnProperty;\"], funcVars = [];\n    extd(vars).filter(function (v) {\n        var ret = [\"var \", v, \" = \"];\n        if (definedFuncs.hasOwnProperty(v)) {\n            ret.push(\"definedFuncs['\", v, \"']\");\n        } else if (scope.hasOwnProperty(v)) {\n            ret.push(\"scope['\", v, \"']\");\n        } else {\n            return true;\n        }\n        ret.push(\";\");\n        closureVars.push(ret.join(\"\"));\n        return false;\n    }).forEach(function (v) {\n        var ret = [\"var \", v, \" = \"];\n        if (equality || v !== alias) {\n            ret.push(\"fact.\" + v);\n        } else if (v === alias) {\n            ret.push(\"hash.\", v, \"\");\n        }\n        ret.push(\";\");\n        funcVars.push(ret.join(\"\"));\n    });\n    var closureBody = closureVars.join(\"\") + \"return function matcher\" + (matcherCount++) + (!equality ? \"(fact, hash){\" : \"(fact){\") + funcVars.join(\"\") + \" return \" + (wrap ? wrap(js) : js) + \";}\";\n    var f = new Function(\"definedFuncs, scope\", closureBody)(definedFuncs, scope);\n    //console.log(f.toString());\n    return f;\n};\n\nexports.getMatcher = function (rule, options, equality) {\n    options = options || {};\n    return toJs(rule, options.scope, options.alias, equality, function (src) {\n        return \"!!(\" + src + \")\";\n    });\n};\n\nexports.getSourceMatcher = function (rule, options, equality) {\n    options = options || {};\n    return toJs(rule, options.scope, options.alias, equality, function (src) {\n        return src;\n    });\n};\n\nexports.toConstraints = function (constraint, options) {\n    if (typeof constraint === 'function') {\n        return [new atoms.CustomConstraint(constraint, options)];\n    }\n    //constraint.split(\"&&\")\n    return lang.toConstraints(constraint, options);\n};\n\nexports.equal = function (c1, c2) {\n    return lang.equal(c1, c2);\n};\n\nexports.getIdentifiers = function (constraint) {\n    return lang.getIdentifiers(constraint);\n};\n\nexports.getIndexableProperties = function (constraint) {\n    return lang.getIndexableProperties(constraint);\n};","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/constraint.js":"\"use strict\";\n\nvar extd = require(\"./extended\"),\n    deepEqual = extd.deepEqual,\n    merge = extd.merge,\n    instanceOf = extd.instanceOf,\n    filter = extd.filter,\n    declare = extd.declare,\n    constraintMatcher;\n\nvar id = 0;\nvar Constraint = declare({\n\n    type: null,\n\n    instance: {\n        constructor: function (constraint) {\n            if (!constraintMatcher) {\n                constraintMatcher = require(\"./constraintMatcher\");\n            }\n            this.id = id++;\n            this.constraint = constraint;\n            extd.bindAll(this, [\"assert\"]);\n        },\n        \"assert\": function () {\n            throw new Error(\"not implemented\");\n        },\n\n        getIndexableProperties: function () {\n            return [];\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n        getters: {\n            variables: function () {\n                return [this.get(\"alias\")];\n            }\n        }\n\n\n    }\n});\n\nConstraint.extend({\n    instance: {\n\n        type: \"object\",\n\n        constructor: function (type) {\n            this._super([type]);\n        },\n\n        \"assert\": function (param) {\n            return param instanceof this.constraint || param.constructor === this.constraint;\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.constraint === constraint.constraint;\n        }\n    }\n}).as(exports, \"ObjectConstraint\");\n\nvar EqualityConstraint = Constraint.extend({\n\n    instance: {\n\n        type: \"equality\",\n\n        constructor: function (constraint, options) {\n            this._super([constraint]);\n            options = options || {};\n            this.pattern = options.pattern;\n            this._matcher = constraintMatcher.getMatcher(constraint, options, true);\n        },\n\n        \"assert\": function (values) {\n            return this._matcher(values);\n        }\n    }\n}).as(exports, \"EqualityConstraint\");\n\nEqualityConstraint.extend({instance: {type: \"inequality\"}}).as(exports, \"InequalityConstraint\");\nEqualityConstraint.extend({instance: {type: \"comparison\"}}).as(exports, \"ComparisonConstraint\");\n\nConstraint.extend({\n\n    instance: {\n\n        type: \"equality\",\n\n        constructor: function () {\n            this._super([\n                [true]\n            ]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\");\n        },\n\n\n        \"assert\": function () {\n            return true;\n        }\n    }\n}).as(exports, \"TrueConstraint\");\n\nvar ReferenceConstraint = Constraint.extend({\n\n    instance: {\n\n        type: \"reference\",\n\n        constructor: function (constraint, options) {\n            this.cache = {};\n            this._super([constraint]);\n            options = options || {};\n            this.values = [];\n            this.pattern = options.pattern;\n            this._options = options;\n            this._matcher = constraintMatcher.getMatcher(constraint, options, false);\n        },\n\n        \"assert\": function (fact, fh) {\n            try {\n                return this._matcher(fact, fh);\n            } catch (e) {\n                throw new Error(\"Error with evaluating pattern \" + this.pattern + \" \" + e.message);\n            }\n\n        },\n\n        merge: function (that) {\n            var ret = this;\n            if (that instanceof ReferenceConstraint) {\n                ret = new this._static([this.constraint, that.constraint, \"and\"], merge({}, this._options, this._options));\n                ret._alias = this._alias || that._alias;\n                ret.vars = this.vars.concat(that.vars);\n            }\n            return ret;\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n\n        getters: {\n            variables: function () {\n                return this.vars;\n            },\n\n            alias: function () {\n                return this._alias;\n            }\n        },\n\n        setters: {\n            alias: function (alias) {\n                this._alias = alias;\n                this.vars = filter(constraintMatcher.getIdentifiers(this.constraint), function (v) {\n                    return v !== alias;\n                });\n            }\n        }\n    }\n\n}).as(exports, \"ReferenceConstraint\");\n\n\nReferenceConstraint.extend({\n    instance: {\n        type: \"reference_equality\",\n        op: \"eq\",\n        getIndexableProperties: function () {\n            return constraintMatcher.getIndexableProperties(this.constraint);\n        }\n    }\n}).as(exports, \"ReferenceEqualityConstraint\")\n    .extend({instance: {type: \"reference_inequality\", op: \"neq\"}}).as(exports, \"ReferenceInequalityConstraint\")\n    .extend({instance: {type: \"reference_gt\", op: \"gt\"}}).as(exports, \"ReferenceGTConstraint\")\n    .extend({instance: {type: \"reference_gte\", op: \"gte\"}}).as(exports, \"ReferenceGTEConstraint\")\n    .extend({instance: {type: \"reference_lt\", op: \"lt\"}}).as(exports, \"ReferenceLTConstraint\")\n    .extend({instance: {type: \"reference_lte\", op: \"lte\"}}).as(exports, \"ReferenceLTEConstraint\");\n\n\nConstraint.extend({\n    instance: {\n\n        type: \"hash\",\n\n        constructor: function (hash) {\n            this._super([hash]);\n        },\n\n        equal: function (constraint) {\n            return extd.instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && extd.deepEqual(this.constraint, constraint.constraint);\n        },\n\n        \"assert\": function () {\n            return true;\n        },\n\n        getters: {\n            variables: function () {\n                return this.constraint;\n            }\n        }\n\n    }\n}).as(exports, \"HashConstraint\");\n\nConstraint.extend({\n    instance: {\n        constructor: function (constraints, options) {\n            this.type = \"from\";\n            this.constraints = constraintMatcher.getSourceMatcher(constraints, (options || {}), true);\n            extd.bindAll(this, [\"assert\"]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.get(\"alias\") === constraint.get(\"alias\") && deepEqual(this.constraints, constraint.constraints);\n        },\n\n        \"assert\": function (fact, fh) {\n            return this.constraints(fact, fh);\n        },\n\n        getters: {\n            variables: function () {\n                return this.constraint;\n            }\n        }\n\n    }\n}).as(exports, \"FromConstraint\");\n\nConstraint.extend({\n    instance: {\n        constructor: function (func, options) {\n            this.type = \"custom\";\n            this.fn = func;\n            this.options = options;\n            extd.bindAll(this, [\"assert\"]);\n        },\n\n        equal: function (constraint) {\n            return instanceOf(constraint, this._static) && this.fn === constraint.constraint;\n        },\n\n        \"assert\": function (fact, fh) {\n            return this.fn(fact, fh);\n        }\n    }\n}).as(exports, \"CustomConstraint\");\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/rule.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    isArray = extd.isArray,\n    Promise = extd.Promise,\n    declare = extd.declare,\n    isHash = extd.isHash,\n    isString = extd.isString,\n    format = extd.format,\n    parser = require(\"./parser\"),\n    pattern = require(\"./pattern\"),\n    ObjectPattern = pattern.ObjectPattern,\n    FromPattern = pattern.FromPattern,\n    NotPattern = pattern.NotPattern,\n    ExistsPattern = pattern.ExistsPattern,\n    FromNotPattern = pattern.FromNotPattern,\n    FromExistsPattern = pattern.FromExistsPattern,\n    CompositePattern = pattern.CompositePattern;\n\nvar parseConstraint = function (constraint) {\n    if (typeof constraint === 'function') {\n        // No parsing is needed for constraint functions\n        return constraint;\n    }\n    return parser.parseConstraint(constraint);\n};\n\nvar parseExtra = extd\n    .switcher()\n    .isUndefinedOrNull(function () {\n        return null;\n    })\n    .isLike(/^from +/, function (s) {\n        return {from: s.replace(/^from +/, \"\").replace(/^\\s*|\\s*$/g, \"\")};\n    })\n    .def(function (o) {\n        throw new Error(\"invalid rule constraint option \" + o);\n    })\n    .switcher();\n\nvar normailizeConstraint = extd\n    .switcher()\n    .isLength(1, function (c) {\n        throw new Error(\"invalid rule constraint \" + format(\"%j\", [c]));\n    })\n    .isLength(2, function (c) {\n        c.push(\"true\");\n        return c;\n    })\n    //handle case where c[2] is a hash rather than a constraint string\n    .isLength(3, function (c) {\n        if (isString(c[2]) && /^from +/.test(c[2])) {\n            var extra = c[2];\n            c.splice(2, 0, \"true\");\n            c[3] = null;\n            c[4] = parseExtra(extra);\n        } else if (isHash(c[2])) {\n            c.splice(2, 0, \"true\");\n        }\n        return c;\n    })\n    //handle case where c[3] is a from clause rather than a hash for references\n    .isLength(4, function (c) {\n        if (isString(c[3])) {\n            c.splice(3, 0, null);\n            c[4] = parseExtra(c[4]);\n        }\n        return c;\n    })\n    .def(function (c) {\n        if (c.length === 5) {\n            c[4] = parseExtra(c[4]);\n        }\n        return c;\n    })\n    .switcher();\n\nvar getParamType = function getParamType(type, scope) {\n    scope = scope || {};\n    var getParamTypeSwitch = extd\n        .switcher()\n        .isEq(\"string\", function () {\n            return String;\n        })\n        .isEq(\"date\", function () {\n            return Date;\n        })\n        .isEq(\"array\", function () {\n            return Array;\n        })\n        .isEq(\"boolean\", function () {\n            return Boolean;\n        })\n        .isEq(\"regexp\", function () {\n            return RegExp;\n        })\n        .isEq(\"number\", function () {\n            return Number;\n        })\n        .isEq(\"object\", function () {\n            return Object;\n        })\n        .isEq(\"hash\", function () {\n            return Object;\n        })\n        .def(function (param) {\n            throw new TypeError(\"invalid param type \" + param);\n        })\n        .switcher();\n\n    var _getParamType = extd\n        .switcher()\n        .isString(function (param) {\n            var t = scope[param];\n            if (!t) {\n                return getParamTypeSwitch(param.toLowerCase());\n            } else {\n                return t;\n            }\n        })\n        .isFunction(function (func) {\n            return func;\n        })\n        .deepEqual([], function () {\n            return Array;\n        })\n        .def(function (param) {\n            throw  new Error(\"invalid param type \" + param);\n        })\n        .switcher();\n\n    return _getParamType(type);\n};\n\nvar parsePattern = extd\n    .switcher()\n    .containsAt(\"or\", 0, function (condition) {\n        condition.shift();\n        return extd(condition).map(function (cond) {\n            cond.scope = condition.scope;\n            return parsePattern(cond);\n        }).flatten().value();\n    })\n    .containsAt(\"not\", 0, function (condition) {\n        condition.shift();\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromNotPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new NotPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    })\n    .containsAt(\"exists\", 0, function (condition) {\n        condition.shift();\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromExistsPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new ExistsPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    })\n    .def(function (condition) {\n        if (typeof condition === 'function') {\n            return [condition];\n        }\n        condition = normailizeConstraint(condition);\n        if (condition[4] && condition[4].from) {\n            return [\n                new FromPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    parseConstraint(condition[4].from),\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        } else {\n            return [\n                new ObjectPattern(\n                    getParamType(condition[0], condition.scope),\n                    condition[1] || \"m\",\n                    parseConstraint(condition[2] || \"true\"),\n                    condition[3] || {},\n                    {scope: condition.scope, pattern: condition[2]}\n                )\n            ];\n        }\n    }).switcher();\n\nvar Rule = declare({\n    instance: {\n        constructor: function (name, options, pattern, cb) {\n            this.name = name;\n            this.pattern = pattern;\n            this.cb = cb;\n            if (options.agendaGroup) {\n                this.agendaGroup = options.agendaGroup;\n                this.autoFocus = extd.isBoolean(options.autoFocus) ? options.autoFocus : false;\n            }\n            this.priority = options.priority || options.salience || 0;\n        },\n\n        fire: function (flow, match) {\n            var ret = new Promise(), cb = this.cb;\n            try {\n                if (cb.length === 3) {\n                    cb.call(flow, match.factHash, flow, ret.resolve);\n                } else {\n                    ret = cb.call(flow, match.factHash, flow);\n                }\n            } catch (e) {\n                ret.errback(e);\n            }\n            return ret;\n        }\n    }\n});\n\nfunction createRule(name, options, conditions, cb) {\n    if (isArray(options)) {\n        cb = conditions;\n        conditions = options;\n    } else {\n        options = options || {};\n    }\n    var isRules = extd.every(conditions, function (cond) {\n        return isArray(cond);\n    });\n    if (isRules && conditions.length === 1) {\n        conditions = conditions[0];\n        isRules = false;\n    }\n    var rules = [];\n    var scope = options.scope || {};\n    conditions.scope = scope;\n    if (isRules) {\n        var _mergePatterns = function (patt, i) {\n            if (!patterns[i]) {\n                patterns[i] = i === 0 ? [] : patterns[i - 1].slice();\n                //remove dup\n                if (i !== 0) {\n                    patterns[i].pop();\n                }\n                patterns[i].push(patt);\n            } else {\n                extd(patterns).forEach(function (p) {\n                    p.push(patt);\n                });\n            }\n\n        };\n        var l = conditions.length, patterns = [], condition;\n        for (var i = 0; i < l; i++) {\n            condition = conditions[i];\n            condition.scope = scope;\n            extd.forEach(parsePattern(condition), _mergePatterns);\n\n        }\n        rules = extd.map(patterns, function (patterns) {\n            var compPat = null;\n            for (var i = 0; i < patterns.length; i++) {\n                if (compPat === null) {\n                    compPat = new CompositePattern(patterns[i++], patterns[i]);\n                } else {\n                    compPat = new CompositePattern(compPat, patterns[i]);\n                }\n            }\n            return new Rule(name, options, compPat, cb);\n        });\n    } else {\n        rules = extd.map(parsePattern(conditions), function (cond) {\n            return new Rule(name, options, cond, cb);\n        });\n    }\n    return rules;\n}\n\nexports.createRule = createRule;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/pattern.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    isEmpty = extd.isEmpty,\n    merge = extd.merge,\n    forEach = extd.forEach,\n    declare = extd.declare,\n    constraintMatcher = require(\"./constraintMatcher\"),\n    constraint = require(\"./constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    FromConstraint = constraint.FromConstraint;\n\nvar id = 0;\nvar Pattern = declare({});\n\nvar ObjectPattern = Pattern.extend({\n    instance: {\n        constructor: function (type, alias, conditions, store, options) {\n            options = options || {};\n            this.id = id++;\n            this.type = type;\n            this.alias = alias;\n            this.conditions = conditions;\n            this.pattern = options.pattern;\n            var constraints = [new constraint.ObjectConstraint(type)];\n            var constrnts = constraintMatcher.toConstraints(conditions, merge({alias: alias}, options));\n            if (constrnts.length) {\n                constraints = constraints.concat(constrnts);\n            } else {\n                var cnstrnt = new constraint.TrueConstraint();\n                constraints.push(cnstrnt);\n            }\n            if (store && !isEmpty(store)) {\n                var atm = new constraint.HashConstraint(store);\n                constraints.push(atm);\n            }\n\n            forEach(constraints, function (constraint) {\n                constraint.set(\"alias\", alias);\n            });\n            this.constraints = constraints;\n        },\n\n        getSpecificity: function () {\n            var constraints = this.constraints, specificity = 0;\n            for (var i = 0, l = constraints.length; i < l; i++) {\n                if (constraints[i] instanceof EqualityConstraint) {\n                    specificity++;\n                }\n            }\n            return specificity;\n        },\n\n        hasConstraint: function (type) {\n            return extd.some(this.constraints, function (c) {\n                return c instanceof type;\n            });\n        },\n\n        hashCode: function () {\n            return [this.type, this.alias, extd.format(\"%j\", this.conditions)].join(\":\");\n        },\n\n        toString: function () {\n            return extd.format(\"%j\", this.constraints);\n        }\n    }\n}).as(exports, \"ObjectPattern\");\n\nvar FromPattern = ObjectPattern.extend({\n    instance: {\n        constructor: function (type, alias, conditions, store, from, options) {\n            this._super([type, alias, conditions, store, options]);\n            this.from = new FromConstraint(from, options);\n        },\n\n        hasConstraint: function (type) {\n            return extd.some(this.constraints, function (c) {\n                return c instanceof type;\n            });\n        },\n\n        getSpecificity: function () {\n            return this._super(arguments) + 1;\n        },\n\n        hashCode: function () {\n            return [this.type, this.alias, extd.format(\"%j\", this.conditions), this.from.from].join(\":\");\n        },\n\n        toString: function () {\n            return extd.format(\"%j from %s\", this.constraints, this.from.from);\n        }\n    }\n}).as(exports, \"FromPattern\");\n\n\nFromPattern.extend().as(exports, \"FromNotPattern\");\nObjectPattern.extend().as(exports, \"NotPattern\");\nObjectPattern.extend().as(exports, \"ExistsPattern\");\nFromPattern.extend().as(exports, \"FromExistsPattern\");\n\nPattern.extend({\n\n    instance: {\n        constructor: function (left, right) {\n            this.id = id++;\n            this.leftPattern = left;\n            this.rightPattern = right;\n        },\n\n        hashCode: function () {\n            return [this.leftPattern.hashCode(), this.rightPattern.hashCode()].join(\":\");\n        },\n\n        getSpecificity: function () {\n            return this.rightPattern.getSpecificity() + this.leftPattern.getSpecificity();\n        },\n\n        getters: {\n            constraints: function () {\n                return this.leftPattern.constraints.concat(this.rightPattern.constraints);\n            }\n        }\n    }\n\n}).as(exports, \"CompositePattern\");\n\n\nvar InitialFact = declare({\n    instance: {\n        constructor: function () {\n            this.id = id++;\n            this.recency = 0;\n        }\n    }\n}).as(exports, \"InitialFact\");\n\nObjectPattern.extend({\n    instance: {\n        constructor: function () {\n            this._super([InitialFact, \"__i__\", [], {}]);\n        },\n\n        assert: function () {\n            return true;\n        }\n    }\n}).as(exports, \"InitialFactPattern\");\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/compile/common.js":"/*jshint evil:true*/\n\"use strict\";\nvar extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    isString = extd.isString;\n\nexports.modifiers = [\"assert\", \"modify\", \"retract\", \"emit\", \"halt\", \"focus\", \"getFacts\"];\n\nvar createFunction = function (body, defined, scope, scopeNames, definedNames) {\n    var declares = [];\n    forEach(definedNames, function (i) {\n        if (body.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    forEach(scopeNames, function (i) {\n        if (body.indexOf(i) !== -1) {\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    body = [\"((function(){\", declares.join(\"\"), \"\\n\\treturn \", body, \"\\n})())\"].join(\"\");\n    try {\n        return eval(body);\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + body + \"\\n\" + e.message);\n    }\n};\n\nvar createDefined = (function () {\n\n    var _createDefined = function (action, defined, scope) {\n        if (isString(action)) {\n            var declares = [];\n            extd(defined).keys().forEach(function (i) {\n                if (action.indexOf(i) !== -1) {\n                    declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n                }\n            });\n\n            extd(scope).keys().forEach(function (i) {\n                if (action.indexOf(i) !== -1) {\n                    declares.push(\"var \" + i + \"= function(){var prop = scope.\" + i + \"; return __objToStr__.call(prop) === '[object Function]' ? prop.apply(void 0, arguments) : prop;};\");\n                }\n            });\n            if (declares.length) {\n                declares.unshift(\"var __objToStr__ = Object.prototype.toString;\");\n            }\n            action = [declares.join(\"\"), \"return \", action, \";\"].join(\"\");\n            action = new Function(\"defined\", \"scope\", action)(defined, scope);\n        }\n        var ret = action.hasOwnProperty(\"constructor\") && \"function\" === typeof action.constructor ? action.constructor : function (opts) {\n            opts = opts || {};\n            for (var i in opts) {\n                if (i in action) {\n                    this[i] = opts[i];\n                }\n            }\n        };\n        var proto = ret.prototype;\n        for (var i in action) {\n            proto[i] = action[i];\n        }\n        return ret;\n\n    };\n\n    return function (options, defined, scope) {\n        return _createDefined(options.properties, defined, scope);\n    };\n})();\n\nexports.createFunction = createFunction;\nexports.createDefined = createDefined;","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/compile/transpile.js":"var extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    indexOf = extd.indexOf,\n    merge = extd.merge,\n    isString = extd.isString,\n    modifiers = require(\"./common\").modifiers,\n    constraintMatcher = require(\"../constraintMatcher\"),\n    parser = require(\"../parser\");\n\nfunction definedToJs(options) {\n    /*jshint evil:true*/\n    options = isString(options) ? new Function(\"return \" + options + \";\")() : options;\n    var ret = [\"(function(){\"], value;\n\n    if (options.hasOwnProperty(\"constructor\") && \"function\" === typeof options.constructor) {\n        ret.push(\"var Defined = \" + options.constructor.toString() + \";\");\n    } else {\n        ret.push(\"var Defined = function(opts){ for(var i in opts){if(opts.hasOwnProperty(i)){this[i] = opts[i];}}};\");\n    }\n    ret.push(\"var proto = Defined.prototype;\");\n    for (var key in options) {\n        if (options.hasOwnProperty(key)) {\n            value = options[key];\n            ret.push(\"proto.\" + key + \" = \" + (extd.isFunction(value) ? value.toString() : extd.format(\"%j\", value)) + \";\");\n        }\n    }\n    ret.push(\"return Defined;\");\n    ret.push(\"}())\");\n    return ret.join(\"\");\n\n}\n\nfunction actionToJs(action, identifiers, defined, scope) {\n    var declares = [], usedVars = {};\n    forEach(identifiers, function (i) {\n        if (action.indexOf(i) !== -1) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= facts.\" + i + \";\");\n        }\n    });\n    extd(defined).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= defined.\" + i + \";\");\n        }\n    });\n\n    extd(scope).keys().forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            usedVars[i] = true;\n            declares.push(\"var \" + i + \"= scope.\" + i + \";\");\n        }\n    });\n    extd(modifiers).forEach(function (i) {\n        if (action.indexOf(i) !== -1 && !usedVars[i]) {\n            declares.push(\"var \" + i + \"= flow.\" + i + \";\");\n        }\n    });\n    var params = [\"facts\", 'flow'];\n    if (/next\\(.*\\)/.test(action)) {\n        params.push(\"next\");\n    }\n    action = declares.join(\"\") + action;\n    try {\n        return [\"function(\", params.join(\",\"), \"){\", action, \"}\"].join(\"\");\n    } catch (e) {\n        throw new Error(\"Invalid action : \" + action + \"\\n\" + e.message);\n    }\n}\n\nfunction parseConstraintModifier(constraint, ret) {\n    if (constraint.length && extd.isString(constraint[0])) {\n        var modifier = constraint[0].match(\" *(from)\");\n        if (modifier) {\n            modifier = modifier[0];\n            switch (modifier) {\n            case \"from\":\n                ret.push(', \"', constraint.shift(), '\"');\n                break;\n            default:\n                throw new Error(\"Unrecognized modifier \" + modifier);\n            }\n        }\n    }\n}\n\nfunction parseConstraintHash(constraint, ret, identifiers) {\n    if (constraint.length && extd.isHash(constraint[0])) {\n        //ret of options\n        var refs = constraint.shift();\n        extd(refs).values().forEach(function (ident) {\n            if (indexOf(identifiers, ident) === -1) {\n                identifiers.push(ident);\n            }\n        });\n        ret.push(',' + extd.format('%j', [refs]));\n    }\n}\n\nfunction constraintsToJs(constraint, identifiers) {\n    constraint = constraint.slice(0);\n    var ret = [];\n    if (constraint[0] === \"or\") {\n        ret.push('[\"' + constraint.shift() + '\"');\n        ret.push(extd.map(constraint,function (c) {\n            return constraintsToJs(c, identifiers);\n        }).join(\",\") + \"]\");\n        return ret;\n    } else if (constraint[0] === \"not\" || constraint[0] === \"exists\") {\n        ret.push('\"', constraint.shift(), '\", ');\n    }\n    identifiers.push(constraint[1]);\n    ret.push(constraint[0], ', \"' + constraint[1].replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + '\"');\n    constraint.splice(0, 2);\n    if (constraint.length) {\n        //constraint\n        var c = constraint.shift();\n        if (extd.isString(c) && c) {\n            ret.push(',\"' + c.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\"), '\"');\n            forEach(constraintMatcher.getIdentifiers(parser.parseConstraint(c)), function (i) {\n                identifiers.push(i);\n            });\n        } else {\n            ret.push(',\"true\"');\n            constraint.unshift(c);\n        }\n    }\n    parseConstraintModifier(constraint, ret);\n    parseConstraintHash(constraint, ret, identifiers);\n    return '[' + ret.join(\"\") + ']';\n}\n\nexports.transpile = function (flowObj, options) {\n    options = options || {};\n    var ret = [];\n    ret.push(\"(function(){\");\n    ret.push(\"return function(options){\");\n    ret.push(\"options = options || {};\");\n    ret.push(\"var bind = function(scope, fn){return function(){return fn.apply(scope, arguments);};}, defined = {Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, scope = options.scope || {};\");\n    ret.push(\"var optDefined = options.defined || {}; for(var i in optDefined){defined[i] = optDefined[i];}\");\n    var defined = merge({Array: Array, String: String, Number: Number, Boolean: Boolean, RegExp: RegExp, Date: Date, Object: Object}, options.define || {});\n    if (typeof Buffer !== \"undefined\") {\n        defined.Buffer = Buffer;\n    }\n    var scope = merge({console: console}, options.scope);\n    ret.push([\"return nools.flow('\", options.name, \"', function(){\"].join(\"\"));\n    //add any defined classes in the parsed flowObj to defined\n    ret.push(extd(flowObj.define || []).map(function (defined) {\n        var name = defined.name;\n        defined[name] = {};\n        return [\"var\", name, \"= defined.\" + name, \"= this.addDefined('\" + name + \"',\", definedToJs(defined.properties) + \");\"].join(\" \");\n    }).value().join(\"\\n\"));\n    ret.push(extd(flowObj.scope || []).map(function (s) {\n        var name = s.name;\n        scope[name] = {};\n        return [\"var\", name, \"= scope.\" + name, \"= \", s.body, \";\"].join(\" \");\n    }).value().join(\"\\n\"));\n    ret.push(\"scope.console = console;\\n\");\n\n\n    ret.push(extd(flowObj.rules || []).map(function (rule) {\n        var identifiers = [], ret = [\"this.rule('\", rule.name.replace(/'/g, \"\\\\'\"), \"'\"], options = extd.merge(rule.options || {}, {scope: \"scope\"});\n        ret.push(\",\", extd.format(\"%j\", [options]).replace(/(:\"scope\")/, \":scope\"));\n        if (rule.constraints && !extd.isEmpty(rule.constraints)) {\n            ret.push(\", [\");\n            ret.push(extd(rule.constraints).map(function (c) {\n                return constraintsToJs(c, identifiers);\n            }).value().join(\",\"));\n            ret.push(\"]\");\n        }\n        ret.push(\",\", actionToJs(rule.action, identifiers, defined, scope));\n        ret.push(\");\");\n        return ret.join(\"\");\n    }).value().join(\"\"));\n    ret.push(\"});\");\n    ret.push(\"};\");\n    ret.push(\"}());\");\n    return ret.join(\"\");\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/flowContainer.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    instanceOf = extd.instanceOf,\n    forEach = extd.forEach,\n    declare = extd.declare,\n    InitialFact = require(\"./pattern\").InitialFact,\n    conflictStrategies = require(\"./conflict\"),\n    conflictResolution = conflictStrategies.strategy([\"salience\", \"activationRecency\"]),\n    rule = require(\"./rule\"),\n    Flow = require(\"./flow\");\n\nvar flows = {};\nvar FlowContainer = declare({\n\n    instance: {\n\n        constructor: function (name, cb) {\n            this.name = name;\n            this.cb = cb;\n            this.__rules = [];\n            this.__defined = {};\n            this.conflictResolutionStrategy = conflictResolution;\n            if (cb) {\n                cb.call(this, this);\n            }\n            if (!flows.hasOwnProperty(name)) {\n                flows[name] = this;\n            } else {\n                throw new Error(\"Flow with \" + name + \" already defined\");\n            }\n        },\n\n        conflictResolution: function (strategies) {\n            this.conflictResolutionStrategy = conflictStrategies.strategy(strategies);\n            return this;\n        },\n\n        getDefined: function (name) {\n            var ret = this.__defined[name.toLowerCase()];\n            if (!ret) {\n                throw new Error(name + \" flow class is not defined\");\n            }\n            return ret;\n        },\n\n        addDefined: function (name, cls) {\n            //normalize\n            this.__defined[name.toLowerCase()] = cls;\n            return cls;\n        },\n\n        rule: function () {\n            this.__rules = this.__rules.concat(rule.createRule.apply(rule, arguments));\n            return this;\n        },\n\n        getSession: function () {\n            var flow = new Flow(this.name, this.conflictResolutionStrategy);\n            forEach(this.__rules, function (rule) {\n                flow.rule(rule);\n            });\n            flow.assert(new InitialFact());\n            for (var i = 0, l = arguments.length; i < l; i++) {\n                flow.assert(arguments[i]);\n            }\n            return flow;\n        },\n\n        containsRule: function (name) {\n            return extd.some(this.__rules, function (rule) {\n                return rule.name === name;\n            });\n        }\n\n    },\n\n    \"static\": {\n        getFlow: function (name) {\n            return flows[name];\n        },\n\n        hasFlow: function (name) {\n            return extd.has(flows, name);\n        },\n\n        deleteFlow: function (name) {\n            if (instanceOf(name, FlowContainer)) {\n                name = name.name;\n            }\n            delete flows[name];\n            return FlowContainer;\n        },\n\n        deleteFlows: function () {\n            for (var name in flows) {\n                if (name in flows) {\n                    delete flows[name];\n                }\n            }\n            return FlowContainer;\n        },\n\n        create: function (name, cb) {\n            return new FlowContainer(name, cb);\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/conflict.js":"var map = require(\"./extended\").map;\n\nfunction salience(a, b) {\n    return a.rule.priority - b.rule.priority;\n}\n\nfunction bucketCounter(a, b) {\n    return a.counter - b.counter;\n}\n\nfunction factRecency(a, b) {\n    /*jshint noempty: false*/\n\n    var i = 0;\n    var aMatchRecency = a.match.recency,\n        bMatchRecency = b.match.recency, aLength = aMatchRecency.length - 1, bLength = bMatchRecency.length - 1;\n    while (aMatchRecency[i] === bMatchRecency[i] && i < aLength && i < bLength && i++) {\n    }\n    var ret = aMatchRecency[i] - bMatchRecency[i];\n    if (!ret) {\n        ret = aLength - bLength;\n    }\n    return ret;\n}\n\nfunction activationRecency(a, b) {\n    return a.recency - b.recency;\n}\n\nvar strategies = {\n    salience: salience,\n    bucketCounter: bucketCounter,\n    factRecency: factRecency,\n    activationRecency: activationRecency\n};\n\nexports.strategies = strategies;\nexports.strategy = function (strats) {\n    strats = map(strats, function (s) {\n        return strategies[s];\n    });\n    var stratsLength = strats.length;\n\n    return function (a, b) {\n        var i = -1, ret = 0;\n        var equal = (a === b) || (a.name === b.name && a.hashCode === b.hashCode);\n        if (!equal) {\n            while (++i < stratsLength && !ret) {\n                ret = strats[i](a, b);\n            }\n            ret = ret > 0 ? 1 : -1;\n        }\n        return ret;\n    };\n};","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/flow.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    bind = extd.bind,\n    declare = extd.declare,\n    nodes = require(\"./nodes\"),\n    EventEmitter = require(\"events\").EventEmitter,\n    wm = require(\"./workingMemory\"),\n    WorkingMemory = wm.WorkingMemory,\n    ExecutionStragegy = require(\"./executionStrategy\"),\n    AgendaTree = require(\"./agenda\");\n\nmodule.exports = declare(EventEmitter, {\n\n    instance: {\n\n        name: null,\n\n        executionStrategy: null,\n\n        constructor: function (name, conflictResolutionStrategy) {\n            this.env = null;\n            this.name = name;\n            this.__rules = {};\n            this.conflictResolutionStrategy = conflictResolutionStrategy;\n            this.workingMemory = new WorkingMemory();\n            this.agenda = new AgendaTree(this, conflictResolutionStrategy);\n            this.agenda.on(\"fire\", bind(this, \"emit\", \"fire\"));\n            this.agenda.on(\"focused\", bind(this, \"emit\", \"focused\"));\n            this.rootNode = new nodes.RootNode(this.workingMemory, this.agenda);\n            extd.bindAll(this, \"halt\", \"assert\", \"retract\", \"modify\", \"focus\",\n              \"emit\", \"getFacts\", \"getFact\");\n        },\n\n        getFacts: function (Type) {\n            var ret;\n            if (Type) {\n                ret = this.workingMemory.getFactsByType(Type);\n            } else {\n                ret = this.workingMemory.getFacts();\n            }\n            return ret;\n        },\n\n        getFact: function (Type) {\n            var ret;\n            if (Type) {\n                ret = this.workingMemory.getFactsByType(Type);\n            } else {\n                ret = this.workingMemory.getFacts();\n            }\n            return ret && ret[0];\n        },\n\n        focus: function (focused) {\n            this.agenda.setFocus(focused);\n            return this;\n        },\n\n        halt: function () {\n            this.executionStrategy.halt();\n            return this;\n        },\n\n        dispose: function () {\n            this.workingMemory.dispose();\n            this.agenda.dispose();\n            this.rootNode.dispose();\n        },\n\n        assert: function (fact) {\n            this.rootNode.assertFact(this.workingMemory.assertFact(fact));\n            this.emit(\"assert\", fact);\n            return fact;\n        },\n\n        // This method is called to remove an existing fact from working memory\n        retract: function (fact) {\n            //fact = this.workingMemory.getFact(fact);\n            this.rootNode.retractFact(this.workingMemory.retractFact(fact));\n            this.emit(\"retract\", fact);\n            return fact;\n        },\n\n        // This method is called to alter an existing fact.  It is essentially a\n        // retract followed by an assert.\n        modify: function (fact, cb) {\n            //fact = this.workingMemory.getFact(fact);\n            if (\"function\" === typeof cb) {\n                cb.call(fact, fact);\n            }\n            this.rootNode.modifyFact(this.workingMemory.modifyFact(fact));\n            this.emit(\"modify\", fact);\n            return fact;\n        },\n\n        print: function () {\n            this.rootNode.print();\n        },\n\n        containsRule: function (name) {\n            return this.rootNode.containsRule(name);\n        },\n\n        rule: function (rule) {\n            this.rootNode.assertRule(rule);\n        },\n\n        matchUntilHalt: function (cb) {\n            return (this.executionStrategy = new ExecutionStragegy(this, true)).execute().classic(cb).promise();\n        },\n\n        match: function (cb) {\n            return (this.executionStrategy = new ExecutionStragegy(this)).execute().classic(cb).promise();\n        }\n\n    }\n});","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/index.js":"\"use strict\";\nvar extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    some = extd.some,\n    declare = extd.declare,\n    pattern = require(\"../pattern.js\"),\n    ObjectPattern = pattern.ObjectPattern,\n    FromPattern = pattern.FromPattern,\n    FromNotPattern = pattern.FromNotPattern,\n    ExistsPattern = pattern.ExistsPattern,\n    FromExistsPattern = pattern.FromExistsPattern,\n    NotPattern = pattern.NotPattern,\n    CompositePattern = pattern.CompositePattern,\n    InitialFactPattern = pattern.InitialFactPattern,\n    constraints = require(\"../constraint\"),\n    HashConstraint = constraints.HashConstraint,\n    ReferenceConstraint = constraints.ReferenceConstraint,\n    AliasNode = require(\"./aliasNode\"),\n    EqualityNode = require(\"./equalityNode\"),\n    JoinNode = require(\"./joinNode\"),\n    BetaNode = require(\"./betaNode\"),\n    NotNode = require(\"./notNode\"),\n    FromNode = require(\"./fromNode\"),\n    FromNotNode = require(\"./fromNotNode\"),\n    ExistsNode = require(\"./existsNode\"),\n    ExistsFromNode = require(\"./existsFromNode\"),\n    LeftAdapterNode = require(\"./leftAdapterNode\"),\n    RightAdapterNode = require(\"./rightAdapterNode\"),\n    TypeNode = require(\"./typeNode\"),\n    TerminalNode = require(\"./terminalNode\"),\n    PropertyNode = require(\"./propertyNode\");\n\nfunction hasRefernceConstraints(pattern) {\n    return some(pattern.constraints || [], function (c) {\n        return c instanceof ReferenceConstraint;\n    });\n}\n\ndeclare({\n    instance: {\n        constructor: function (wm, agendaTree) {\n            this.terminalNodes = [];\n            this.joinNodes = [];\n            this.nodes = [];\n            this.constraints = [];\n            this.typeNodes = [];\n            this.__ruleCount = 0;\n            this.bucket = {\n                counter: 0,\n                recency: 0\n            };\n            this.agendaTree = agendaTree;\n            this.workingMemory = wm;\n        },\n\n        assertRule: function (rule) {\n            var terminalNode = new TerminalNode(this.bucket, this.__ruleCount++, rule, this.agendaTree);\n            this.__addToNetwork(rule, rule.pattern, terminalNode);\n            this.__mergeJoinNodes();\n            this.terminalNodes.push(terminalNode);\n        },\n\n        resetCounter: function () {\n            this.bucket.counter = 0;\n        },\n\n        incrementCounter: function () {\n            this.bucket.counter++;\n        },\n\n        assertFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].assert(fact);\n            }\n        },\n\n        retractFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].retract(fact);\n            }\n        },\n\n        modifyFact: function (fact) {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].modify(fact);\n            }\n        },\n\n\n        containsRule: function (name) {\n            return some(this.terminalNodes, function (n) {\n                return n.rule.name === name;\n            });\n        },\n\n        dispose: function () {\n            var typeNodes = this.typeNodes, i = typeNodes.length - 1;\n            for (; i >= 0; i--) {\n                typeNodes[i].dispose();\n            }\n        },\n\n        __mergeJoinNodes: function () {\n            var joinNodes = this.joinNodes;\n            for (var i = 0; i < joinNodes.length; i++) {\n                var j1 = joinNodes[i], j2 = joinNodes[i + 1];\n                if (j1 && j2 && (j1.constraint && j2.constraint && j1.constraint.equal(j2.constraint))) {\n                    j1.merge(j2);\n                    joinNodes.splice(i + 1, 1);\n                }\n            }\n        },\n\n        __checkEqual: function (node) {\n            var constraints = this.constraints, i = constraints.length - 1;\n            for (; i >= 0; i--) {\n                var n = constraints[i];\n                if (node.equal(n)) {\n                    return  n;\n                }\n            }\n            constraints.push(node);\n            return node;\n        },\n\n        __createTypeNode: function (rule, pattern) {\n            var ret = new TypeNode(pattern.get(\"constraints\")[0]);\n            var constraints = this.typeNodes, i = constraints.length - 1;\n            for (; i >= 0; i--) {\n                var n = constraints[i];\n                if (ret.equal(n)) {\n                    return  n;\n                }\n            }\n            constraints.push(ret);\n            return ret;\n        },\n\n        __createEqualityNode: function (rule, constraint) {\n            return this.__checkEqual(new EqualityNode(constraint)).addRule(rule);\n        },\n\n        __createPropertyNode: function (rule, constraint) {\n            return this.__checkEqual(new PropertyNode(constraint)).addRule(rule);\n        },\n\n        __createAliasNode: function (rule, pattern) {\n            return this.__checkEqual(new AliasNode(pattern)).addRule(rule);\n        },\n\n        __createAdapterNode: function (rule, side) {\n            return (side === \"left\" ? new LeftAdapterNode() : new RightAdapterNode()).addRule(rule);\n        },\n\n        __createJoinNode: function (rule, pattern, outNode, side) {\n            var joinNode;\n            if (pattern.rightPattern instanceof NotPattern) {\n                joinNode = new NotNode();\n            } else if (pattern.rightPattern instanceof FromExistsPattern) {\n                joinNode = new ExistsFromNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern.rightPattern instanceof ExistsPattern) {\n                joinNode = new ExistsNode();\n            } else if (pattern.rightPattern instanceof FromNotPattern) {\n                joinNode = new FromNotNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern.rightPattern instanceof FromPattern) {\n                joinNode = new FromNode(pattern.rightPattern, this.workingMemory);\n            } else if (pattern instanceof CompositePattern && !hasRefernceConstraints(pattern.leftPattern) && !hasRefernceConstraints(pattern.rightPattern)) {\n                joinNode = new BetaNode();\n                this.joinNodes.push(joinNode);\n            } else {\n                joinNode = new JoinNode();\n                this.joinNodes.push(joinNode);\n            }\n            joinNode[\"__rule__\"] = rule;\n            var parentNode = joinNode;\n            if (outNode instanceof BetaNode) {\n                var adapterNode = this.__createAdapterNode(rule, side);\n                parentNode.addOutNode(adapterNode, pattern);\n                parentNode = adapterNode;\n            }\n            parentNode.addOutNode(outNode, pattern);\n            return joinNode.addRule(rule);\n        },\n\n        __addToNetwork: function (rule, pattern, outNode, side) {\n            if (pattern instanceof ObjectPattern) {\n                if (!(pattern instanceof InitialFactPattern) && (!side || side === \"left\")) {\n                    this.__createBetaNode(rule, new CompositePattern(new InitialFactPattern(), pattern), outNode, side);\n                } else {\n                    this.__createAlphaNode(rule, pattern, outNode, side);\n                }\n            } else if (pattern instanceof CompositePattern) {\n                this.__createBetaNode(rule, pattern, outNode, side);\n            }\n        },\n\n        __createBetaNode: function (rule, pattern, outNode, side) {\n            var joinNode = this.__createJoinNode(rule, pattern, outNode, side);\n            this.__addToNetwork(rule, pattern.rightPattern, joinNode, \"right\");\n            this.__addToNetwork(rule, pattern.leftPattern, joinNode, \"left\");\n            outNode.addParentNode(joinNode);\n            return joinNode;\n        },\n\n\n        __createAlphaNode: function (rule, pattern, outNode, side) {\n            var typeNode, parentNode;\n            if (!(pattern instanceof FromPattern)) {\n\n                var constraints = pattern.get(\"constraints\");\n                typeNode = this.__createTypeNode(rule, pattern);\n                var aliasNode = this.__createAliasNode(rule, pattern);\n                typeNode.addOutNode(aliasNode, pattern);\n                aliasNode.addParentNode(typeNode);\n                parentNode = aliasNode;\n                var i = constraints.length - 1;\n                for (; i > 0; i--) {\n                    var constraint = constraints[i], node;\n                    if (constraint instanceof HashConstraint) {\n                        node = this.__createPropertyNode(rule, constraint);\n                    } else if (constraint instanceof ReferenceConstraint) {\n                        outNode.constraint.addConstraint(constraint);\n                        continue;\n                    } else {\n                        node = this.__createEqualityNode(rule, constraint);\n                    }\n                    parentNode.addOutNode(node, pattern);\n                    node.addParentNode(parentNode);\n                    parentNode = node;\n                }\n\n                if (outNode instanceof BetaNode) {\n                    var adapterNode = this.__createAdapterNode(rule, side);\n                    adapterNode.addParentNode(parentNode);\n                    parentNode.addOutNode(adapterNode, pattern);\n                    parentNode = adapterNode;\n                }\n                outNode.addParentNode(parentNode);\n                parentNode.addOutNode(outNode, pattern);\n                return typeNode;\n            }\n        },\n\n        print: function () {\n            forEach(this.terminalNodes, function (t) {\n                t.print(\"    \");\n            });\n        }\n    }\n}).as(exports, \"RootNode\");\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/aliasNode.js":"var AlphaNode = require(\"./alphaNode\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this._super(arguments);\n            this.alias = this.constraint.get(\"alias\");\n        },\n\n        toString: function () {\n            return \"AliasNode\" + this.__count;\n        },\n\n        assert: function (context) {\n            return this.__propagate(\"assert\", context.set(this.alias, context.fact.object));\n        },\n\n        modify: function (context) {\n            return this.__propagate(\"modify\", context.set(this.alias, context.fact.object));\n        },\n\n        retract: function (context) {\n            return this.__propagate(\"retract\", context.set(this.alias, context.fact.object));\n        },\n\n        equal: function (other) {\n            return other instanceof this._static && this.alias === other.alias;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/alphaNode.js":"\"use strict\";\nvar Node = require(\"./node\");\n\nNode.extend({\n    instance: {\n        constructor: function (constraint) {\n            this._super([]);\n            this.constraint = constraint;\n            this.constraintAssert = this.constraint.assert;\n        },\n\n        toString: function () {\n            return \"AlphaNode \" + this.__count;\n        },\n\n        equal: function (constraint) {\n            return this.constraint.equal(constraint.constraint);\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/node.js":"var extd = require(\"../extended\"),\n    forEach = extd.forEach,\n    indexOf = extd.indexOf,\n    intersection = extd.intersection,\n    declare = extd.declare,\n    HashTable = extd.HashTable,\n    Context = require(\"../context\");\n\nvar count = 0;\ndeclare({\n    instance: {\n        constructor: function () {\n            this.nodes = new HashTable();\n            this.rules = [];\n            this.parentNodes = [];\n            this.__count = count++;\n            this.__entrySet = [];\n        },\n\n        addRule: function (rule) {\n            if (indexOf(this.rules, rule) === -1) {\n                this.rules.push(rule);\n            }\n            return this;\n        },\n\n        merge: function (that) {\n            that.nodes.forEach(function (entry) {\n                var patterns = entry.value, node = entry.key;\n                for (var i = 0, l = patterns.length; i < l; i++) {\n                    this.addOutNode(node, patterns[i]);\n                }\n                that.nodes.remove(node);\n            }, this);\n            var thatParentNodes = that.parentNodes;\n            for (var i = 0, l = that.parentNodes.l; i < l; i++) {\n                var parentNode = thatParentNodes[i];\n                this.addParentNode(parentNode);\n                parentNode.nodes.remove(that);\n            }\n            return this;\n        },\n\n        resolve: function (mr1, mr2) {\n            return mr1.hashCode === mr2.hashCode;\n        },\n\n        print: function (tab) {\n            console.log(tab + this.toString());\n            forEach(this.parentNodes, function (n) {\n                n.print(\"    \" + tab);\n            });\n        },\n\n        addOutNode: function (outNode, pattern) {\n            if (!this.nodes.contains(outNode)) {\n                this.nodes.put(outNode, []);\n            }\n            this.nodes.get(outNode).push(pattern);\n            this.__entrySet = this.nodes.entrySet();\n        },\n\n        addParentNode: function (n) {\n            if (indexOf(this.parentNodes, n) === -1) {\n                this.parentNodes.push(n);\n            }\n        },\n\n        shareable: function () {\n            return false;\n        },\n\n        __propagate: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode, paths, continuingPaths;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                paths = entry.value;\n\n                if ((continuingPaths = intersection(paths, context.paths)).length) {\n                    outNode[method](new Context(context.fact, continuingPaths, context.match));\n                }\n\n            }\n        },\n\n        dispose: function (assertable) {\n            this.propagateDispose(assertable);\n        },\n\n        retract: function (assertable) {\n            this.propagateRetract(assertable);\n        },\n\n        propagateDispose: function (assertable, outNodes) {\n            outNodes = outNodes || this.nodes;\n            var entrySet = this.__entrySet, i = entrySet.length - 1;\n            for (; i >= 0; i--) {\n                var entry = entrySet[i], outNode = entry.key;\n                outNode.dispose(assertable);\n            }\n        },\n\n        propagateAssert: function (assertable) {\n            this.__propagate(\"assert\", assertable);\n        },\n\n        propagateRetract: function (assertable) {\n            this.__propagate(\"retract\", assertable);\n        },\n\n        assert: function (assertable) {\n            this.propagateAssert(assertable);\n        },\n\n        modify: function (assertable) {\n            this.propagateModify(assertable);\n        },\n\n        propagateModify: function (assertable) {\n            this.__propagate(\"modify\", assertable);\n        }\n    }\n\n}).as(module);\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/context.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    isBoolean = extd.isBoolean,\n    declare = extd.declare,\n    indexOf = extd.indexOf,\n    pPush = Array.prototype.push;\n\nfunction createContextHash(paths, hashCode) {\n    var ret = \"\",\n        i = -1,\n        l = paths.length;\n    while (++i < l) {\n        ret += paths[i].id + \":\";\n    }\n    ret += hashCode;\n    return ret;\n}\n\nfunction merge(h1, h2, aliases) {\n    var i = -1, l = aliases.length, alias;\n    while (++i < l) {\n        alias = aliases[i];\n        h1[alias] = h2[alias];\n    }\n}\n\nfunction unionRecency(arr, arr1, arr2) {\n    pPush.apply(arr, arr1);\n    var i = -1, l = arr2.length, val, j = arr.length;\n    while (++i < l) {\n        val = arr2[i];\n        if (indexOf(arr, val) === -1) {\n            arr[j++] = val;\n        }\n    }\n}\n\nvar Match = declare({\n    instance: {\n\n        isMatch: true,\n        hashCode: \"\",\n        facts: null,\n        factIds: null,\n        factHash: null,\n        recency: null,\n        aliases: null,\n\n        constructor: function () {\n            this.facts = [];\n            this.factIds = [];\n            this.factHash = {};\n            this.recency = [];\n            this.aliases = [];\n        },\n\n        addFact: function (assertable) {\n            pPush.call(this.facts, assertable);\n            pPush.call(this.recency, assertable.recency);\n            pPush.call(this.factIds, assertable.id);\n            this.hashCode = this.factIds.join(\":\");\n            return this;\n        },\n\n        merge: function (mr) {\n            var ret = new Match();\n            ret.isMatch = mr.isMatch;\n            pPush.apply(ret.facts, this.facts);\n            pPush.apply(ret.facts, mr.facts);\n            pPush.apply(ret.aliases, this.aliases);\n            pPush.apply(ret.aliases, mr.aliases);\n            ret.hashCode = this.hashCode + \":\" + mr.hashCode;\n            merge(ret.factHash, this.factHash, this.aliases);\n            merge(ret.factHash, mr.factHash, mr.aliases);\n            unionRecency(ret.recency, this.recency, mr.recency);\n            return ret;\n        }\n    }\n});\n\nvar Context = declare({\n    instance: {\n        match: null,\n        factHash: null,\n        aliases: null,\n        fact: null,\n        hashCode: null,\n        paths: null,\n        pathsHash: null,\n\n        constructor: function (fact, paths, mr) {\n            this.fact = fact;\n            if (mr) {\n                this.match = mr;\n            } else {\n                this.match = new Match().addFact(fact);\n            }\n            this.factHash = this.match.factHash;\n            this.aliases = this.match.aliases;\n            this.hashCode = this.match.hashCode;\n            if (paths) {\n                this.paths = paths;\n                this.pathsHash = createContextHash(paths, this.hashCode);\n            } else {\n                this.pathsHash = this.hashCode;\n            }\n        },\n\n        \"set\": function (key, value) {\n            this.factHash[key] = value;\n            this.aliases.push(key);\n            return this;\n        },\n\n        isMatch: function (isMatch) {\n            if (isBoolean(isMatch)) {\n                this.match.isMatch = isMatch;\n            } else {\n                return this.match.isMatch;\n            }\n            return this;\n        },\n\n        mergeMatch: function (merge) {\n            var match = this.match = this.match.merge(merge);\n            this.factHash = match.factHash;\n            this.hashCode = match.hashCode;\n            this.aliases = match.aliases;\n            return this;\n        },\n\n        clone: function (fact, paths, match) {\n            return new Context(fact || this.fact, paths || this.path, match || this.match);\n        }\n    }\n}).as(module);\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/equalityNode.js":"var AlphaNode = require(\"./alphaNode\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this.memory = {};\n            this._super(arguments);\n            this.constraintAssert = this.constraint.assert;\n        },\n\n        assert: function (context) {\n            if ((this.memory[context.pathsHash] = this.constraintAssert(context.factHash))) {\n                this.__propagate(\"assert\", context);\n            }\n        },\n\n        modify: function (context) {\n            var memory = this.memory,\n                hashCode = context.pathsHash,\n                wasMatch = memory[hashCode];\n            if ((memory[hashCode] = this.constraintAssert(context.factHash))) {\n                this.__propagate(wasMatch ? \"modify\" : \"assert\", context);\n            } else if (wasMatch) {\n                this.__propagate(\"retract\", context);\n            }\n        },\n\n        retract: function (context) {\n            var hashCode = context.pathsHash,\n                memory = this.memory;\n            if (memory[hashCode]) {\n                this.__propagate(\"retract\", context);\n            }\n            delete memory[hashCode];\n        },\n\n        toString: function () {\n            return \"EqualityNode\" + this.__count;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/joinNode.js":"var BetaNode = require(\"./betaNode\"),\n    JoinReferenceNode = require(\"./joinReferenceNode\");\n\nBetaNode.extend({\n\n    instance: {\n        constructor: function () {\n            this._super(arguments);\n            this.constraint = new JoinReferenceNode(this.leftTuples, this.rightTuples);\n        },\n\n        nodeType: \"JoinNode\",\n\n        propagateFromLeft: function (context, rm) {\n            var mr;\n            if ((mr = this.constraint.match(context, rm)).isMatch) {\n                this.__propagate(\"assert\", this.__addToMemoryMatches(rm, context, context.clone(null, null, mr)));\n            }\n            return this;\n        },\n\n        propagateFromRight: function (context, lm) {\n            var mr;\n            if ((mr = this.constraint.match(lm, context)).isMatch) {\n                this.__propagate(\"assert\", this.__addToMemoryMatches(context, lm, context.clone(null, null, mr)));\n            }\n            return this;\n        },\n\n        propagateAssertModifyFromLeft: function (context, rightMatches, rm) {\n            var factId = rm.hashCode, mr;\n            if (factId in rightMatches) {\n                mr = this.constraint.match(context, rm);\n                var mrIsMatch = mr.isMatch;\n                if (!mrIsMatch) {\n                    this.__propagate(\"retract\", rightMatches[factId].clone());\n                } else {\n                    this.__propagate(\"modify\", this.__addToMemoryMatches(rm, context, context.clone(null, null, mr)));\n                }\n            } else {\n                this.propagateFromLeft(context, rm);\n            }\n        },\n\n        propagateAssertModifyFromRight: function (context, leftMatches, lm) {\n            var factId = lm.hashCode, mr;\n            if (factId in leftMatches) {\n                mr = this.constraint.match(lm, context);\n                var mrIsMatch = mr.isMatch;\n                if (!mrIsMatch) {\n                    this.__propagate(\"retract\", leftMatches[factId].clone());\n                } else {\n                    this.__propagate(\"modify\", this.__addToMemoryMatches(context, lm, context.clone(null, null, mr)));\n                }\n            } else {\n                this.propagateFromRight(context, lm);\n            }\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/betaNode.js":"var extd = require(\"../extended\"),\n    keys = extd.hash.keys,\n    Node = require(\"./node\"),\n    LeftMemory = require(\"./misc/leftMemory\"), RightMemory = require(\"./misc/rightMemory\");\n\nNode.extend({\n\n    instance: {\n\n        nodeType: \"BetaNode\",\n\n        constructor: function () {\n            this._super([]);\n            this.leftMemory = {};\n            this.rightMemory = {};\n            this.leftTuples = new LeftMemory();\n            this.rightTuples = new RightMemory();\n        },\n\n        __propagate: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                outNode[method](context);\n            }\n        },\n\n        dispose: function () {\n            this.leftMemory = {};\n            this.rightMemory = {};\n            this.leftTuples.clear();\n            this.rightTuples.clear();\n        },\n\n        disposeLeft: function (fact) {\n            this.leftMemory = {};\n            this.leftTuples.clear();\n            this.propagateDispose(fact);\n        },\n\n        disposeRight: function (fact) {\n            this.rightMemory = {};\n            this.rightTuples.clear();\n            this.propagateDispose(fact);\n        },\n\n        hashCode: function () {\n            return  this.nodeType + \" \" + this.__count;\n        },\n\n        toString: function () {\n            return this.nodeType + \" \" + this.__count;\n        },\n\n        retractLeft: function (context) {\n            context = this.removeFromLeftMemory(context).data;\n            var rightMatches = context.rightMatches,\n                hashCodes = keys(rightMatches),\n                i = -1,\n                l = hashCodes.length;\n            while (++i < l) {\n                this.__propagate(\"retract\", rightMatches[hashCodes[i]].clone());\n            }\n        },\n\n        retractRight: function (context) {\n            context = this.removeFromRightMemory(context).data;\n            var leftMatches = context.leftMatches,\n                hashCodes = keys(leftMatches),\n                i = -1,\n                l = hashCodes.length;\n            while (++i < l) {\n                this.__propagate(\"retract\", leftMatches[hashCodes[i]].clone());\n            }\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            var rm = this.rightTuples.getRightMemory(context), i = -1, l = rm.length;\n            while (++i < l) {\n                this.propagateFromLeft(context, rm[i].data);\n            }\n        },\n\n        assertRight: function (context) {\n            this.__addToRightMemory(context);\n            var lm = this.leftTuples.getLeftMemory(context), i = -1, l = lm.length;\n            while (++i < l) {\n                this.propagateFromRight(context, lm[i].data);\n            }\n        },\n\n        modifyLeft: function (context) {\n            var previousContext = this.removeFromLeftMemory(context).data;\n            this.__addToLeftMemory(context);\n            var rm = this.rightTuples.getRightMemory(context), l = rm.length, i = -1, rightMatches;\n            if (!l) {\n                this.propagateRetractModifyFromLeft(previousContext);\n            } else {\n                rightMatches = previousContext.rightMatches;\n                while (++i < l) {\n                    this.propagateAssertModifyFromLeft(context, rightMatches, rm[i].data);\n                }\n\n            }\n        },\n\n        modifyRight: function (context) {\n            var previousContext = this.removeFromRightMemory(context).data;\n            this.__addToRightMemory(context);\n            var lm = this.leftTuples.getLeftMemory(context);\n            if (!lm.length) {\n                this.propagateRetractModifyFromRight(previousContext);\n            } else {\n                var leftMatches = previousContext.leftMatches, i = -1, l = lm.length;\n                while (++i < l) {\n                    this.propagateAssertModifyFromRight(context, leftMatches, lm[i].data);\n                }\n            }\n        },\n\n        propagateFromLeft: function (context, rc) {\n            this.__propagate(\"assert\", this.__addToMemoryMatches(rc, context, context.clone(null, null, context.match.merge(rc.match))));\n        },\n\n        propagateFromRight: function (context, lc) {\n            this.__propagate(\"assert\", this.__addToMemoryMatches(context, lc, lc.clone(null, null, lc.match.merge(context.match))));\n        },\n\n        propagateRetractModifyFromLeft: function (context) {\n            var rightMatches = context.rightMatches,\n                hashCodes = keys(rightMatches),\n                l = hashCodes.length,\n                i = -1;\n            while (++i < l) {\n                this.__propagate(\"retract\", rightMatches[hashCodes[i]].clone());\n            }\n        },\n\n        propagateRetractModifyFromRight: function (context) {\n            var leftMatches = context.leftMatches,\n                hashCodes = keys(leftMatches),\n                l = hashCodes.length,\n                i = -1;\n            while (++i < l) {\n                this.__propagate(\"retract\", leftMatches[hashCodes[i]].clone());\n            }\n        },\n\n        propagateAssertModifyFromLeft: function (context, rightMatches, rm) {\n            var factId = rm.hashCode;\n            if (factId in rightMatches) {\n                this.__propagate(\"modify\", this.__addToMemoryMatches(rm, context, context.clone(null, null, context.match.merge(rm.match))));\n            } else {\n                this.propagateFromLeft(context, rm);\n            }\n        },\n\n        propagateAssertModifyFromRight: function (context, leftMatches, lm) {\n            var factId = lm.hashCode;\n            if (factId in leftMatches) {\n                this.__propagate(\"modify\", this.__addToMemoryMatches(context, lm, context.clone(null, null, lm.match.merge(context.match))));\n            } else {\n                this.propagateFromRight(context, lm);\n            }\n        },\n\n        removeFromRightMemory: function (context) {\n            var hashCode = context.hashCode, ret;\n            context = this.rightMemory[hashCode] || null;\n            var tuples = this.rightTuples;\n            if (context) {\n                var leftMemory = this.leftMemory;\n                ret = context.data;\n                var leftMatches = ret.leftMatches;\n                tuples.remove(context);\n                var hashCodes = keys(leftMatches), i = -1, l = hashCodes.length;\n                while (++i < l) {\n                    delete leftMemory[hashCodes[i]].data.rightMatches[hashCode];\n                }\n                delete this.rightMemory[hashCode];\n            }\n            return context;\n        },\n\n        removeFromLeftMemory: function (context) {\n            var hashCode = context.hashCode;\n            context = this.leftMemory[hashCode] || null;\n            if (context) {\n                var rightMemory = this.rightMemory;\n                var rightMatches = context.data.rightMatches;\n                this.leftTuples.remove(context);\n                var hashCodes = keys(rightMatches), i = -1, l = hashCodes.length;\n                while (++i < l) {\n                    delete rightMemory[hashCodes[i]].data.leftMatches[hashCode];\n                }\n                delete this.leftMemory[hashCode];\n            }\n            return context;\n        },\n\n        getRightMemoryMatches: function (context) {\n            var lm = this.leftMemory[context.hashCode], ret = {};\n            if (lm) {\n                ret = lm.rightMatches;\n            }\n            return ret;\n        },\n\n        __addToMemoryMatches: function (rightContext, leftContext, createdContext) {\n            var rightFactId = rightContext.hashCode,\n                rm = this.rightMemory[rightFactId],\n                lm, leftFactId = leftContext.hashCode;\n            if (rm) {\n                rm = rm.data;\n                if (leftFactId in rm.leftMatches) {\n                    throw new Error(\"Duplicate left fact entry\");\n                }\n                rm.leftMatches[leftFactId] = createdContext;\n            }\n            lm = this.leftMemory[leftFactId];\n            if (lm) {\n                lm = lm.data;\n                if (rightFactId in lm.rightMatches) {\n                    throw new Error(\"Duplicate right fact entry\");\n                }\n                lm.rightMatches[rightFactId] = createdContext;\n            }\n            return createdContext;\n        },\n\n        __addToRightMemory: function (context) {\n            var hashCode = context.hashCode, rm = this.rightMemory;\n            if (hashCode in rm) {\n                return false;\n            }\n            rm[hashCode] = this.rightTuples.push(context);\n            context.leftMatches = {};\n            return true;\n        },\n\n\n        __addToLeftMemory: function (context) {\n            var hashCode = context.hashCode, lm = this.leftMemory;\n            if (hashCode in lm) {\n                return false;\n            }\n            lm[hashCode] = this.leftTuples.push(context);\n            context.rightMatches = {};\n            return true;\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/leftMemory.js":"var Memory = require(\"./memory\");\n\nMemory.extend({\n\n    instance: {\n\n        getLeftMemory: function (tuple) {\n            return this.getMemory(tuple);\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/memory.js":"var extd = require(\"../../extended\"),\n    plucker = extd.plucker,\n    declare = extd.declare,\n    getMemory = require(\"./helpers\").getMemory,\n    Table = require(\"./table\"),\n    TupleEntry = require(\"./tupleEntry\");\n\n\nvar id = 0;\ndeclare({\n\n    instance: {\n        length: 0,\n\n        constructor: function () {\n            this.head = null;\n            this.tail = null;\n            this.indexes = [];\n            this.tables = new TupleEntry(null, new Table(), false);\n        },\n\n        push: function (data) {\n            var tail = this.tail, head = this.head, node = {data: data, tuples: [], hashCode: id++, prev: tail, next: null};\n            if (tail) {\n                this.tail.next = node;\n            }\n            this.tail = node;\n            if (!head) {\n                this.head = node;\n            }\n            this.length++;\n            this.__index(node);\n            this.tables.addNode(node);\n            return node;\n        },\n\n        remove: function (node) {\n            if (node.prev) {\n                node.prev.next = node.next;\n            } else {\n                this.head = node.next;\n            }\n            if (node.next) {\n                node.next.prev = node.prev;\n            } else {\n                this.tail = node.prev;\n            }\n            this.tables.removeNode(node);\n            this.__removeFromIndex(node);\n            this.length--;\n        },\n\n        forEach: function (cb) {\n            var head = {next: this.head};\n            while ((head = head.next)) {\n                cb(head.data);\n            }\n        },\n\n        toArray: function () {\n            return this.tables.tuples.slice();\n        },\n\n        clear: function () {\n            this.head = this.tail = null;\n            this.length = 0;\n            this.clearIndexes();\n        },\n\n        clearIndexes: function () {\n            this.tables = {};\n            this.indexes.length = 0;\n        },\n\n        __index: function (node) {\n            var data = node.data,\n                factHash = data.factHash,\n                indexes = this.indexes,\n                entry = this.tables,\n                i = -1, l = indexes.length,\n                tuples, index, val, path, tables, currEntry, prevLookup;\n            while (++i < l) {\n                index = indexes[i];\n                val = index[2](factHash);\n                path = index[0];\n                tables = entry.tables;\n                if (!(tuples = (currEntry = tables[path] || (tables[path] = new Table())).get(val))) {\n                    tuples = new TupleEntry(val, currEntry, true);\n                    currEntry.set(val, tuples);\n                }\n                if (currEntry !== prevLookup) {\n                    node.tuples.push(tuples.addNode(node));\n                }\n                prevLookup = currEntry;\n                if (index[4] === \"eq\") {\n                    entry = tuples;\n                }\n            }\n        },\n\n        __removeFromIndex: function (node) {\n            var tuples = node.tuples, i = tuples.length;\n            while (--i >= 0) {\n                tuples[i].removeNode(node);\n            }\n            node.tuples.length = 0;\n        },\n\n        getMemory: function (tuple) {\n            var ret;\n            if (!this.length) {\n                ret = [];\n            } else {\n                ret = getMemory(this.tables, tuple.factHash, this.indexes);\n            }\n            return ret;\n        },\n\n        __createIndexTree: function () {\n            var table = this.tables.tables = {};\n            var indexes = this.indexes;\n            table[indexes[0][0]] = new Table();\n        },\n\n\n        addIndex: function (primary, lookup, op) {\n            this.indexes.push([primary, lookup, plucker(primary), plucker(lookup), op || \"eq\"]);\n            this.indexes.sort(function (a, b) {\n                var aOp = a[4], bOp = b[4];\n                return aOp === bOp ? 0 : aOp > bOp ? 1 : aOp === bOp ? 0 : -1;\n            });\n            this.__createIndexTree();\n\n        }\n\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/helpers.js":"exports.getMemory = (function () {\n\n    var pPush = Array.prototype.push, NPL = 0, EMPTY_ARRAY = [], NOT_POSSIBLES_HASH = {}, POSSIBLES_HASH = {}, PL = 0;\n\n    function mergePossibleTuples(ret, a, l) {\n        var val, j = 0, i = -1;\n        if (PL < l) {\n            while (PL && ++i < l) {\n                if (POSSIBLES_HASH[(val = a[i]).hashCode]) {\n                    ret[j++] = val;\n                    PL--;\n                }\n            }\n        } else {\n            pPush.apply(ret, a);\n        }\n        PL = 0;\n        POSSIBLES_HASH = {};\n    }\n\n\n    function mergeNotPossibleTuples(ret, a, l) {\n        var val, j = 0, i = -1;\n        if (NPL < l) {\n            while (++i < l) {\n                if (!NPL) {\n                    ret[j++] = a[i];\n                } else if (!NOT_POSSIBLES_HASH[(val = a[i]).hashCode]) {\n                    ret[j++] = val;\n                } else {\n                    NPL--;\n                }\n            }\n        }\n        NPL = 0;\n        NOT_POSSIBLES_HASH = {};\n    }\n\n    function mergeBothTuples(ret, a, l) {\n        if (PL === l) {\n            mergeNotPossibles(ret, a, l);\n        } else if (NPL < l) {\n            var val, j = 0, i = -1, hashCode;\n            while (++i < l) {\n                if (!NOT_POSSIBLES_HASH[(hashCode = (val = a[i]).hashCode)] && POSSIBLES_HASH[hashCode]) {\n                    ret[j++] = val;\n                }\n            }\n        }\n        NPL = 0;\n        NOT_POSSIBLES_HASH = {};\n        PL = 0;\n        POSSIBLES_HASH = {};\n    }\n\n    function mergePossiblesAndNotPossibles(a, l) {\n        var ret = EMPTY_ARRAY;\n        if (l) {\n            if (NPL || PL) {\n                ret = [];\n                if (!NPL) {\n                    mergePossibleTuples(ret, a, l);\n                } else if (!PL) {\n                    mergeNotPossibleTuples(ret, a, l);\n                } else {\n                    mergeBothTuples(ret, a, l);\n                }\n            } else {\n                ret = a;\n            }\n        }\n        return ret;\n    }\n\n    function getRangeTuples(op, currEntry, val) {\n        var ret;\n        if (op === \"gt\") {\n            ret = currEntry.findGT(val);\n        } else if (op === \"gte\") {\n            ret = currEntry.findGTE(val);\n        } else if (op === \"lt\") {\n            ret = currEntry.findLT(val);\n        } else if (op === \"lte\") {\n            ret = currEntry.findLTE(val);\n        }\n        return ret;\n    }\n\n    function mergeNotPossibles(tuples, tl) {\n        if (tl) {\n            var j = -1, hashCode;\n            while (++j < tl) {\n                hashCode = tuples[j].hashCode;\n                if (!NOT_POSSIBLES_HASH[hashCode]) {\n                    NOT_POSSIBLES_HASH[hashCode] = true;\n                    NPL++;\n                }\n            }\n        }\n    }\n\n    function mergePossibles(tuples, tl) {\n        if (tl) {\n            var j = -1, hashCode;\n            while (++j < tl) {\n                hashCode = tuples[j].hashCode;\n                if (!POSSIBLES_HASH[hashCode]) {\n                    POSSIBLES_HASH[hashCode] = true;\n                    PL++;\n                }\n            }\n        }\n    }\n\n    return function _getMemory(entry, factHash, indexes) {\n        var i = -1, l = indexes.length,\n            ret = entry.tuples,\n            rl = ret.length,\n            intersected = false,\n            tables = entry.tables,\n            index, val, op, nextEntry, currEntry, tuples, tl;\n        while (++i < l && rl) {\n            index = indexes[i];\n            val = index[3](factHash);\n            op = index[4];\n            currEntry = tables[index[0]];\n            if (op === \"eq\" || op === \"seq\") {\n                if ((nextEntry = currEntry.get(val))) {\n                    rl = (ret = (entry = nextEntry).tuples).length;\n                    tables = nextEntry.tables;\n                } else {\n                    rl = (ret = EMPTY_ARRAY).length;\n                }\n            } else if (op === \"neq\" || op === \"sneq\") {\n                if ((nextEntry = currEntry.get(val))) {\n                    tl = (tuples = nextEntry.tuples).length;\n                    mergeNotPossibles(tuples, tl);\n                }\n            } else if (!intersected) {\n                rl = (ret = getRangeTuples(op, currEntry, val)).length;\n                intersected = true;\n            } else if ((tl = (tuples = getRangeTuples(op, currEntry, val)).length)) {\n                mergePossibles(tuples, tl);\n            } else {\n                ret = tuples;\n                rl = tl;\n            }\n        }\n        return mergePossiblesAndNotPossibles(ret, rl);\n    };\n}());","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/table.js":"var extd = require(\"../../extended\"),\n    pPush = Array.prototype.push,\n    HashTable = extd.HashTable,\n    AVLTree = extd.AVLTree;\n\nfunction compare(a, b) {\n    /*jshint eqeqeq: false*/\n    a = a.key;\n    b = b.key;\n    var ret;\n    if (a == b) {\n        ret = 0;\n    } else if (a > b) {\n        ret = 1;\n    } else if (a < b) {\n        ret = -1;\n    } else {\n        ret = 1;\n    }\n    return ret;\n}\n\nfunction compareGT(v1, v2) {\n    return compare(v1, v2) === 1;\n}\nfunction compareGTE(v1, v2) {\n    return compare(v1, v2) !== -1;\n}\n\nfunction compareLT(v1, v2) {\n    return compare(v1, v2) === -1;\n}\nfunction compareLTE(v1, v2) {\n    return compare(v1, v2) !== 1;\n}\n\nvar STACK = [],\n    VALUE = {key: null};\nfunction traverseInOrder(tree, key, comparator) {\n    VALUE.key = key;\n    var ret = [];\n    var i = 0, current = tree.__root, v;\n    while (true) {\n        if (current) {\n            current = (STACK[i++] = current).left;\n        } else {\n            if (i > 0) {\n                v = (current = STACK[--i]).data;\n                if (comparator(v, VALUE)) {\n                    pPush.apply(ret, v.value.tuples);\n                    current = current.right;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    STACK.length = 0;\n    return ret;\n}\n\nfunction traverseReverseOrder(tree, key, comparator) {\n    VALUE.key = key;\n    var ret = [];\n    var i = 0, current = tree.__root, v;\n    while (true) {\n        if (current) {\n            current = (STACK[i++] = current).right;\n        } else {\n            if (i > 0) {\n                v = (current = STACK[--i]).data;\n                if (comparator(v, VALUE)) {\n                    pPush.apply(ret, v.value.tuples);\n                    current = current.left;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    STACK.length = 0;\n    return ret;\n}\n\nAVLTree.extend({\n    instance: {\n\n        constructor: function () {\n            this._super([\n                {\n                    compare: compare\n                }\n            ]);\n            this.gtCache = new HashTable();\n            this.gteCache = new HashTable();\n            this.ltCache = new HashTable();\n            this.lteCache = new HashTable();\n            this.hasGTCache = false;\n            this.hasGTECache = false;\n            this.hasLTCache = false;\n            this.hasLTECache = false;\n        },\n\n        clearCache: function () {\n            this.hasGTCache && this.gtCache.clear() && (this.hasGTCache = false);\n            this.hasGTECache && this.gteCache.clear() && (this.hasGTECache = false);\n            this.hasLTCache && this.ltCache.clear() && (this.hasLTCache = false);\n            this.hasLTECache && this.lteCache.clear() && (this.hasLTECache = false);\n        },\n\n        contains: function (key) {\n            return  this._super([\n                {key: key}\n            ]);\n        },\n\n        \"set\": function (key, value) {\n            this.insert({key: key, value: value});\n            this.clearCache();\n        },\n\n        \"get\": function (key) {\n            var ret = this.find({key: key});\n            return ret && ret.value;\n        },\n\n        \"remove\": function (key) {\n            this.clearCache();\n            return this._super([\n                {key: key}\n            ]);\n        },\n\n        findGT: function (key) {\n            var ret = this.gtCache.get(key);\n            if (!ret) {\n                this.hasGTCache = true;\n                this.gtCache.put(key, (ret = traverseReverseOrder(this, key, compareGT)));\n            }\n            return ret;\n        },\n\n        findGTE: function (key) {\n            var ret = this.gteCache.get(key);\n            if (!ret) {\n                this.hasGTECache = true;\n                this.gteCache.put(key, (ret = traverseReverseOrder(this, key, compareGTE)));\n            }\n            return ret;\n        },\n\n        findLT: function (key) {\n            var ret = this.ltCache.get(key);\n            if (!ret) {\n                this.hasLTCache = true;\n                this.ltCache.put(key, (ret = traverseInOrder(this, key, compareLT)));\n            }\n            return ret;\n        },\n\n        findLTE: function (key) {\n            var ret = this.lteCache.get(key);\n            if (!ret) {\n                this.hasLTECache = true;\n                this.lteCache.put(key, (ret = traverseInOrder(this, key, compareLTE)));\n            }\n            return ret;\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/tupleEntry.js":"var extd = require(\"../../extended\"),\n    indexOf = extd.indexOf;\n//    HashSet = require(\"./hashSet\");\n\n\nvar TUPLE_ID = 0;\nextd.declare({\n\n    instance: {\n        tuples: null,\n        tupleMap: null,\n        hashCode: null,\n        tables: null,\n        entry: null,\n        constructor: function (val, entry, canRemove) {\n            this.val = val;\n            this.canRemove = canRemove;\n            this.tuples = [];\n            this.tupleMap = {};\n            this.hashCode = TUPLE_ID++;\n            this.tables = {};\n            this.length = 0;\n            this.entry = entry;\n        },\n\n        addNode: function (node) {\n            this.tuples[this.length++] = node;\n            if (this.length > 1) {\n                this.entry.clearCache();\n            }\n            return this;\n        },\n\n        removeNode: function (node) {\n            var tuples = this.tuples, index = indexOf(tuples, node);\n            if (index !== -1) {\n                tuples.splice(index, 1);\n                this.length--;\n                this.entry.clearCache();\n            }\n            if (this.canRemove && !this.length) {\n                this.entry.remove(this.val);\n            }\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/misc/rightMemory.js":"var Memory = require(\"./memory\");\n\nMemory.extend({\n\n    instance: {\n\n        getRightMemory: function (tuple) {\n            return this.getMemory(tuple);\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/joinReferenceNode.js":"var Node = require(\"./node\"),\n    constraints = require(\"../constraint\"),\n    ReferenceEqualityConstraint = constraints.ReferenceEqualityConstraint;\n\nvar DEFUALT_CONSTRAINT = {\n    isDefault: true,\n    assert: function () {\n        return true;\n    },\n\n    equal: function () {\n        return false;\n    }\n};\n\nvar inversions = {\n    \"gt\": \"lte\",\n    \"gte\": \"lte\",\n    \"lt\": \"gte\",\n    \"lte\": \"gte\",\n    \"eq\": \"eq\",\n    \"neq\": \"neq\"\n};\n\nfunction normalizeRightIndexConstraint(rightIndex, indexes, op) {\n    if (rightIndex === indexes[1]) {\n        op = inversions[op];\n    }\n    return op;\n}\n\nfunction normalizeLeftIndexConstraint(leftIndex, indexes, op) {\n    if (leftIndex === indexes[1]) {\n        op = inversions[op];\n    }\n    return op;\n}\n\nNode.extend({\n\n    instance: {\n\n        constraint: DEFUALT_CONSTRAINT,\n\n        constructor: function (leftMemory, rightMemory) {\n            this._super(arguments);\n            this.constraint = DEFUALT_CONSTRAINT;\n            this.constraintAssert = DEFUALT_CONSTRAINT.assert;\n            this.rightIndexes = [];\n            this.leftIndexes = [];\n            this.constraintLength = 0;\n            this.leftMemory = leftMemory;\n            this.rightMemory = rightMemory;\n        },\n\n        addConstraint: function (constraint) {\n            if (constraint instanceof ReferenceEqualityConstraint) {\n                var identifiers = constraint.getIndexableProperties();\n                var alias = constraint.get(\"alias\");\n                if (identifiers.length === 2 && alias) {\n                    var leftIndex, rightIndex, i = -1, indexes = [];\n                    while (++i < 2) {\n                        var index = identifiers[i];\n                        if (index.match(new RegExp(\"^\" + alias + \"(\\\\.?)\")) === null) {\n                            indexes.push(index);\n                            leftIndex = index;\n                        } else {\n                            indexes.push(index);\n                            rightIndex = index;\n                        }\n                    }\n                    if (leftIndex && rightIndex) {\n                        var leftOp = normalizeLeftIndexConstraint(leftIndex, indexes, constraint.op),\n                            rightOp = normalizeRightIndexConstraint(rightIndex, indexes, constraint.op);\n                        this.rightMemory.addIndex(rightIndex, leftIndex, rightOp);\n                        this.leftMemory.addIndex(leftIndex, rightIndex, leftOp);\n                    }\n                }\n            }\n            if (this.constraint.isDefault) {\n                this.constraint = constraint;\n                this.isDefault = false;\n            } else {\n                this.constraint = this.constraint.merge(constraint);\n            }\n            this.constraintAssert = this.constraint.assert;\n\n        },\n\n        equal: function (constraint) {\n            return this.constraint.equal(constraint.constraint);\n        },\n\n        isMatch: function (lc, rc) {\n            return this.constraintAssert(lc.factHash, rc.factHash);\n        },\n\n        match: function (lc, rc) {\n            var ret = {isMatch: false};\n            if (this.constraintAssert(lc.factHash, rc.factHash)) {\n                ret = lc.match.merge(rc.match);\n            }\n            return ret;\n        }\n\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/notNode.js":"var JoinNode = require(\"./joinNode\"),\n    LinkedList = require(\"../linkedList\"),\n    Context = require(\"../context\"),\n    InitialFact = require(\"../pattern\").InitialFact;\n\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"NotNode\",\n\n        constructor: function () {\n            this._super(arguments);\n            this.leftTupleMemory = {};\n            //use this ensure a unique match for and propagated context.\n            this.notMatch = new Context(new InitialFact()).match;\n        },\n\n        __cloneContext: function (context) {\n            return context.clone(null, null, context.match.merge(this.notMatch));\n        },\n\n\n        retractRight: function (context) {\n            var ctx = this.removeFromRightMemory(context),\n                rightContext = ctx.data,\n                blocking = rightContext.blocking;\n            if (blocking.length) {\n                //if we are blocking left contexts\n                var leftContext, thisConstraint = this.constraint, blockingNode = {next: blocking.head}, rc;\n                while ((blockingNode = blockingNode.next)) {\n                    leftContext = blockingNode.data;\n                    this.removeFromLeftBlockedMemory(leftContext);\n                    var rm = this.rightTuples.getRightMemory(leftContext), l = rm.length, i;\n                    i = -1;\n                    while (++i < l) {\n                        if (thisConstraint.isMatch(leftContext, rc = rm[i].data)) {\n                            this.blockedContext(leftContext, rc);\n                            leftContext = null;\n                            break;\n                        }\n                    }\n                    if (leftContext) {\n                        this.notBlockedContext(leftContext, true);\n                    }\n                }\n                blocking.clear();\n            }\n\n        },\n\n        blockedContext: function (leftContext, rightContext, propagate) {\n            leftContext.blocker = rightContext;\n            this.removeFromLeftMemory(leftContext);\n            this.addToLeftBlockedMemory(rightContext.blocking.push(leftContext));\n            propagate && this.__propagate(\"retract\", this.__cloneContext(leftContext));\n        },\n\n        notBlockedContext: function (leftContext, propagate) {\n            this.__addToLeftMemory(leftContext);\n            propagate && this.__propagate(\"assert\", this.__cloneContext(leftContext));\n        },\n\n        propagateFromLeft: function (leftContext) {\n            this.notBlockedContext(leftContext, true);\n        },\n\n        propagateFromRight: function (leftContext) {\n            this.notBlockedContext(leftContext, true);\n        },\n\n        blockFromAssertRight: function (leftContext, rightContext) {\n            this.blockedContext(leftContext, rightContext, true);\n        },\n\n        blockFromAssertLeft: function (leftContext, rightContext) {\n            this.blockedContext(leftContext, rightContext, false);\n        },\n\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                this.__propagate(\"retract\", this.__cloneContext(ctx));\n            } else {\n                if (!this.removeFromLeftBlockedMemory(context)) {\n                    throw new Error();\n                }\n            }\n        },\n\n        assertLeft: function (context) {\n            var values = this.rightTuples.getRightMemory(context),\n                thisConstraint = this.constraint, rc, i = -1, l = values.length;\n            while (++i < l) {\n                if (thisConstraint.isMatch(context, rc = values[i].data)) {\n                    this.blockFromAssertLeft(context, rc);\n                    context = null;\n                    i = l;\n                }\n            }\n            if (context) {\n                this.propagateFromLeft(context);\n            }\n        },\n\n        assertRight: function (context) {\n            this.__addToRightMemory(context);\n            context.blocking = new LinkedList();\n            var fl = this.leftTuples.getLeftMemory(context).slice(),\n                i = -1, l = fl.length,\n                leftContext, thisConstraint = this.constraint;\n            while (++i < l) {\n                leftContext = fl[i].data;\n                if (thisConstraint.isMatch(leftContext, context)) {\n                    this.blockFromAssertRight(leftContext, context);\n                }\n            }\n        },\n\n        addToLeftBlockedMemory: function (context) {\n            var data = context.data, hashCode = data.hashCode;\n            var ctx = this.leftMemory[hashCode];\n            this.leftTupleMemory[hashCode] = context;\n            if (ctx) {\n                this.leftTuples.remove(ctx);\n            }\n            return this;\n        },\n\n        removeFromLeftBlockedMemory: function (context) {\n            var ret = this.leftTupleMemory[context.hashCode] || null;\n            if (ret) {\n                delete this.leftTupleMemory[context.hashCode];\n                ret.data.blocker.blocking.remove(ret);\n            }\n            return ret;\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context),\n                leftContext,\n                thisConstraint = this.constraint,\n                rightTuples = this.rightTuples.getRightMemory(context),\n                l = rightTuples.length,\n                isBlocked = false,\n                i, rc, blocker;\n            if (!ctx) {\n                //blocked before\n                ctx = this.removeFromLeftBlockedMemory(context);\n                isBlocked = true;\n            }\n            if (ctx) {\n                leftContext = ctx.data;\n\n                if (leftContext && leftContext.blocker) {\n                    //we were blocked before so only check nodes previous to our blocker\n                    blocker = this.rightMemory[leftContext.blocker.hashCode];\n                    leftContext.blocker = null;\n                }\n                if (blocker) {\n                    if (thisConstraint.isMatch(context, rc = blocker.data)) {\n                        //we cant be proagated so retract previous\n                        if (!isBlocked) {\n                            //we were asserted before so retract\n                            this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                        }\n                        context.blocker = rc;\n                        this.addToLeftBlockedMemory(rc.blocking.push(context));\n                        context = null;\n                    }\n                }\n                if (context && l) {\n                    i = -1;\n                    //we were propogated before\n                    while (++i < l) {\n                        if (thisConstraint.isMatch(context, rc = rightTuples[i].data)) {\n                            //we cant be proagated so retract previous\n                            if (!isBlocked) {\n                                //we were asserted before so retract\n                                this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                            }\n                            this.addToLeftBlockedMemory(rc.blocking.push(context));\n                            context.blocker = rc;\n                            context = null;\n                            break;\n                        }\n                    }\n                }\n                if (context) {\n                    //we can still be propogated\n                    this.__addToLeftMemory(context);\n                    if (!isBlocked) {\n                        //we weren't blocked before so modify\n                        this.__propagate(\"modify\", this.__cloneContext(context));\n                    } else {\n                        //we were blocked before but aren't now\n                        this.__propagate(\"assert\", this.__cloneContext(context));\n                    }\n\n                }\n            } else {\n                throw new Error();\n            }\n\n        },\n\n        modifyRight: function (context) {\n            var ctx = this.removeFromRightMemory(context);\n            if (ctx) {\n                var rightContext = ctx.data,\n                    leftTuples = this.leftTuples.getLeftMemory(context).slice(),\n                    leftTuplesLength = leftTuples.length,\n                    leftContext,\n                    thisConstraint = this.constraint,\n                    i, node,\n                    blocking = rightContext.blocking;\n                this.__addToRightMemory(context);\n                context.blocking = new LinkedList();\n\n                var rc;\n                //check old blocked contexts\n                //check if the same contexts blocked before are still blocked\n                var blockingNode = {next: blocking.head};\n                while ((blockingNode = blockingNode.next)) {\n                    leftContext = blockingNode.data;\n                    leftContext.blocker = null;\n                    if (thisConstraint.isMatch(leftContext, context)) {\n                        leftContext.blocker = context;\n                        this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                        leftContext = null;\n                    } else {\n                        //we arent blocked anymore\n                        leftContext.blocker = null;\n                        node = ctx;\n                        while ((node = node.next)) {\n                            if (thisConstraint.isMatch(leftContext, rc = node.data)) {\n                                leftContext.blocker = rc;\n                                this.addToLeftBlockedMemory(rc.blocking.push(leftContext));\n                                leftContext = null;\n                                break;\n                            }\n                        }\n                        if (leftContext) {\n                            this.__addToLeftMemory(leftContext);\n                            this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                        }\n                    }\n                }\n                if (leftTuplesLength) {\n                    //check currently left tuples in memory\n                    i = -1;\n                    while (++i < leftTuplesLength) {\n                        leftContext = leftTuples[i].data;\n                        if (thisConstraint.isMatch(leftContext, context)) {\n                            this.__propagate(\"retract\", this.__cloneContext(leftContext));\n                            this.removeFromLeftMemory(leftContext);\n                            this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                            leftContext.blocker = context;\n                        }\n                    }\n                }\n            } else {\n                throw new Error();\n            }\n\n\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/fromNode.js":"var JoinNode = require(\"./joinNode\"),\n    extd = require(\"../extended\"),\n    constraint = require(\"../constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    HashConstraint = constraint.HashConstraint,\n    ReferenceConstraint = constraint.ReferenceConstraint,\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    isEmpty = extd.isEmpty,\n    forEach = extd.forEach,\n    isArray = extd.isArray;\n\nvar DEFAULT_MATCH = {\n    isMatch: function () {\n        return false;\n    }\n};\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"FromNode\",\n\n        constructor: function (pattern, wm) {\n            this._super(arguments);\n            this.workingMemory = wm;\n            this.fromMemory = {};\n            this.pattern = pattern;\n            this.type = pattern.get(\"constraints\")[0].assert;\n            this.alias = pattern.get(\"alias\");\n            this.from = pattern.from.assert;\n            var eqConstraints = this.__equalityConstraints = [];\n            var vars = [];\n            forEach(this.constraints = this.pattern.get(\"constraints\").slice(1), function (c) {\n                if (c instanceof EqualityConstraint || c instanceof ReferenceConstraint) {\n                    eqConstraints.push(c.assert);\n                } else if (c instanceof HashConstraint) {\n                    vars = vars.concat(c.get(\"variables\"));\n                }\n            });\n            this.__variables = vars;\n        },\n\n        __createMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    this.__checkMatch(context, o[i], true);\n                }\n            } else if (isDefined(o)) {\n                this.__checkMatch(context, o, true);\n            }\n        },\n\n        __checkMatch: function (context, o, propogate) {\n            var newContext;\n            if ((newContext = this.__createMatch(context, o)).isMatch() && propogate) {\n                this.__propagate(\"assert\", newContext.clone());\n            }\n            return newContext;\n        },\n\n        __createMatch: function (lc, o) {\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o, true),\n                    createdContext,\n                    rc = new Context(createdFact, null, null)\n                        .set(this.alias, o),\n                    createdFactId = createdFact.id;\n                var fh = rc.factHash, lcFh = lc.factHash;\n                for (var key in lcFh) {\n                    fh[key] = lcFh[key];\n                }\n                var eqConstraints = this.__equalityConstraints, vars = this.__variables, i = -1, l = eqConstraints.length;\n                while (++i < l) {\n                    if (!eqConstraints[i](fh, fh)) {\n                        createdContext = DEFAULT_MATCH;\n                        break;\n                    }\n                }\n                var fm = this.fromMemory[createdFactId];\n                if (!fm) {\n                    fm = this.fromMemory[createdFactId] = {};\n                }\n                if (!createdContext) {\n                    var prop;\n                    i = -1;\n                    l = vars.length;\n                    while (++i < l) {\n                        prop = vars[i];\n                        fh[prop] = o[prop];\n                    }\n                    lc.fromMatches[createdFact.id] = createdContext = rc.clone(createdFact, null, lc.match.merge(rc.match));\n                }\n                fm[lc.hashCode] = [lc, createdContext];\n                return createdContext;\n            }\n            return DEFAULT_MATCH;\n        },\n\n        retractRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        },\n\n        removeFromFromMemory: function (context) {\n            var factId = context.fact.id;\n            var fm = this.fromMemory[factId];\n            if (fm) {\n                var entry;\n                for (var i in fm) {\n                    entry = fm[i];\n                    if (entry[1] === context) {\n                        delete fm[i];\n                        if (isEmpty(fm)) {\n                            delete this.fromMemory[factId];\n                        }\n                        break;\n                    }\n                }\n            }\n\n        },\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                var fromMatches = ctx.fromMatches;\n                for (var i in fromMatches) {\n                    this.removeFromFromMemory(fromMatches[i]);\n                    this.__propagate(\"retract\", fromMatches[i].clone());\n                }\n            }\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context), newContext, i, l, factId, fact;\n            if (ctx) {\n                this.__addToLeftMemory(context);\n\n                var leftContext = ctx.data,\n                    fromMatches = (context.fromMatches = {}),\n                    rightMatches = leftContext.fromMatches,\n                    o = this.from(context.factHash);\n\n                if (isArray(o)) {\n                    for (i = 0, l = o.length; i < l; i++) {\n                        newContext = this.__checkMatch(context, o[i], false);\n                        if (newContext.isMatch()) {\n                            factId = newContext.fact.id;\n                            if (factId in rightMatches) {\n                                this.__propagate(\"modify\", newContext.clone());\n                            } else {\n                                this.__propagate(\"assert\", newContext.clone());\n                            }\n                        }\n                    }\n                } else if (isDefined(o)) {\n                    newContext = this.__checkMatch(context, o, false);\n                    if (newContext.isMatch()) {\n                        factId = newContext.fact.id;\n                        if (factId in rightMatches) {\n                            this.__propagate(\"modify\", newContext.clone());\n                        } else {\n                            this.__propagate(\"assert\", newContext.clone());\n                        }\n                    }\n                }\n                for (i in rightMatches) {\n                    if (!(i in fromMatches)) {\n                        this.removeFromFromMemory(rightMatches[i]);\n                        this.__propagate(\"retract\", rightMatches[i].clone());\n                    }\n                }\n            } else {\n                this.assertLeft(context);\n            }\n            fact = context.fact;\n            factId = fact.id;\n            var fm = this.fromMemory[factId];\n            this.fromMemory[factId] = {};\n            if (fm) {\n                var lc, entry, cc, createdIsMatch, factObject = fact.object;\n                for (i in fm) {\n                    entry = fm[i];\n                    lc = entry[0];\n                    cc = entry[1];\n                    createdIsMatch = cc.isMatch();\n                    if (lc.hashCode !== context.hashCode) {\n                        newContext = this.__createMatch(lc, factObject, false);\n                        if (createdIsMatch) {\n                            this.__propagate(\"retract\", cc.clone());\n                        }\n                        if (newContext.isMatch()) {\n                            this.__propagate(createdIsMatch ? \"modify\" : \"assert\", newContext.clone());\n                        }\n\n                    }\n                }\n            }\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            context.fromMatches = {};\n            this.__createMatches(context);\n        },\n\n        assertRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/fromNotNode.js":"var JoinNode = require(\"./joinNode\"),\n    extd = require(\"../extended\"),\n    constraint = require(\"../constraint\"),\n    EqualityConstraint = constraint.EqualityConstraint,\n    HashConstraint = constraint.HashConstraint,\n    ReferenceConstraint = constraint.ReferenceConstraint,\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    forEach = extd.forEach,\n    isArray = extd.isArray;\n\nJoinNode.extend({\n    instance: {\n\n        nodeType: \"FromNotNode\",\n\n        constructor: function (pattern, workingMemory) {\n            this._super(arguments);\n            this.workingMemory = workingMemory;\n            this.pattern = pattern;\n            this.type = pattern.get(\"constraints\")[0].assert;\n            this.alias = pattern.get(\"alias\");\n            this.from = pattern.from.assert;\n            this.fromMemory = {};\n            var eqConstraints = this.__equalityConstraints = [];\n            var vars = [];\n            forEach(this.constraints = this.pattern.get(\"constraints\").slice(1), function (c) {\n                if (c instanceof EqualityConstraint || c instanceof ReferenceConstraint) {\n                    eqConstraints.push(c.assert);\n                } else if (c instanceof HashConstraint) {\n                    vars = vars.concat(c.get(\"variables\"));\n                }\n            });\n            this.__variables = vars;\n\n        },\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                if (!ctx.blocked) {\n                    this.__propagate(\"retract\", ctx.clone());\n                }\n            }\n        },\n\n        __modify: function (context, leftContext) {\n            var leftContextBlocked = leftContext.blocked;\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        break;\n                    }\n                }\n            } else if (isDefined(o)) {\n                context.blocked = this.__isMatch(context, o, true);\n            }\n            var newContextBlocked = context.blocked;\n            if (!newContextBlocked) {\n                if (leftContextBlocked) {\n                    this.__propagate(\"assert\", context.clone());\n                } else {\n                    this.__propagate(\"modify\", context.clone());\n                }\n            } else if (!leftContextBlocked) {\n                this.__propagate(\"retract\", leftContext.clone());\n            }\n\n        },\n\n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                this.__addToLeftMemory(context);\n                this.__modify(context, ctx.data);\n            } else {\n                throw new Error();\n            }\n            var fm = this.fromMemory[context.fact.id];\n            this.fromMemory[context.fact.id] = {};\n            if (fm) {\n                for (var i in fm) {\n                    // update any contexts associated with this fact\n                    if (i !== context.hashCode) {\n                        var lc = fm[i];\n                        ctx = this.removeFromLeftMemory(lc);\n                        if (ctx) {\n                            lc = lc.clone();\n                            lc.blocked = false;\n                            this.__addToLeftMemory(lc);\n                            this.__modify(lc, ctx.data);\n                        }\n                    }\n                }\n            }\n        },\n\n        __findMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh), isMatch = false;\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        return;\n                    }\n                }\n                this.__propagate(\"assert\", context.clone());\n            } else if (isDefined(o) && !(context.blocked = this.__isMatch(context, o, true))) {\n                this.__propagate(\"assert\", context.clone());\n            }\n            return isMatch;\n        },\n\n        __isMatch: function (oc, o, add) {\n            var ret = false;\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o);\n                var context = new Context(createdFact, null)\n                    .mergeMatch(oc.match)\n                    .set(this.alias, o);\n                if (add) {\n                    var fm = this.fromMemory[createdFact.id];\n                    if (!fm) {\n                        fm = this.fromMemory[createdFact.id] = {};\n                    }\n                    fm[oc.hashCode] = oc;\n                }\n                var fh = context.factHash;\n                var eqConstraints = this.__equalityConstraints;\n                for (var i = 0, l = eqConstraints.length; i < l; i++) {\n                    if (eqConstraints[i](fh, fh)) {\n                        ret = true;\n                    } else {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            return ret;\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            this.__findMatches(context);\n        },\n\n        assertRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        },\n\n        retractRight: function () {\n            throw new Error(\"Shouldnt have gotten here\");\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/existsNode.js":"var NotNode = require(\"./notNode\"),\n    LinkedList = require(\"../linkedList\");\n\n\nNotNode.extend({\n    instance: {\n\n        nodeType: \"ExistsNode\",\n\n        blockedContext: function (leftContext, rightContext) {\n            leftContext.blocker = rightContext;\n            this.removeFromLeftMemory(leftContext);\n            this.addToLeftBlockedMemory(rightContext.blocking.push(leftContext));\n            this.__propagate(\"assert\", this.__cloneContext(leftContext));\n        },\n\n        notBlockedContext: function (leftContext, propagate) {\n            this.__addToLeftMemory(leftContext);\n            propagate && this.__propagate(\"retract\", this.__cloneContext(leftContext));\n        },\n\n        propagateFromLeft: function (leftContext) {\n            this.notBlockedContext(leftContext, false);\n        },\n\n\n        retractLeft: function (context) {\n            var ctx;\n            if (!this.removeFromLeftMemory(context)) {\n                if ((ctx = this.removeFromLeftBlockedMemory(context))) {\n                    this.__propagate(\"retract\", this.__cloneContext(ctx.data));\n                } else {\n                    throw new Error();\n                }\n            }\n        },\n       \n        modifyLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context),\n                leftContext,\n                thisConstraint = this.constraint,\n                rightTuples = this.rightTuples,\n                l = rightTuples.length,\n                isBlocked = false,\n                node, rc, blocker;\n            if (!ctx) {\n                //blocked before\n                ctx = this.removeFromLeftBlockedMemory(context);\n                isBlocked = true;\n            }\n            if (ctx) {\n                leftContext = ctx.data;\n\n                if (leftContext && leftContext.blocker) {\n                    //we were blocked before so only check nodes previous to our blocker\n                    blocker = this.rightMemory[leftContext.blocker.hashCode];\n                }\n                if (blocker) {\n                    if (thisConstraint.isMatch(context, rc = blocker.data)) {\n                        //propogate as a modify or assert\n                        this.__propagate(!isBlocked ? \"assert\" : \"modify\", this.__cloneContext(leftContext));\n                        context.blocker = rc;\n                        this.addToLeftBlockedMemory(rc.blocking.push(context));\n                        context = null;\n                    }\n                    if (context) {\n                        node = {next: blocker.next};\n                    }\n                } else {\n                    node = {next: rightTuples.head};\n                }\n                if (context && l) {\n                    node = {next: rightTuples.head};\n                    //we were propagated before\n                    while ((node = node.next)) {\n                        if (thisConstraint.isMatch(context, rc = node.data)) {\n                            //we cant be proagated so retract previous\n\n                            //we were asserted before so retract\n                            this.__propagate(!isBlocked ? \"assert\" : \"modify\", this.__cloneContext(leftContext));\n\n                            this.addToLeftBlockedMemory(rc.blocking.push(context));\n                            context.blocker = rc;\n                            context = null;\n                            break;\n                        }\n                    }\n                }\n                if (context) {\n                    //we can still be propogated\n                    this.__addToLeftMemory(context);\n                    if (isBlocked) {\n                        //we were blocked so retract\n                        this.__propagate(\"retract\", this.__cloneContext(context));\n                    }\n\n                }\n            } else {\n                throw new Error();\n            }\n\n        },\n\n        modifyRight: function (context) {\n            var ctx = this.removeFromRightMemory(context);\n            if (ctx) {\n                var rightContext = ctx.data,\n                    leftTuples = this.leftTuples,\n                    leftTuplesLength = leftTuples.length,\n                    leftContext,\n                    thisConstraint = this.constraint,\n                    node,\n                    blocking = rightContext.blocking;\n                this.__addToRightMemory(context);\n                context.blocking = new LinkedList();\n                if (leftTuplesLength || blocking.length) {\n                    if (blocking.length) {\n                        var rc;\n                        //check old blocked contexts\n                        //check if the same contexts blocked before are still blocked\n                        var blockingNode = {next: blocking.head};\n                        while ((blockingNode = blockingNode.next)) {\n                            leftContext = blockingNode.data;\n                            leftContext.blocker = null;\n                            if (thisConstraint.isMatch(leftContext, context)) {\n                                leftContext.blocker = context;\n                                this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                                this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                leftContext = null;\n                            } else {\n                                //we arent blocked anymore\n                                leftContext.blocker = null;\n                                node = ctx;\n                                while ((node = node.next)) {\n                                    if (thisConstraint.isMatch(leftContext, rc = node.data)) {\n                                        leftContext.blocker = rc;\n                                        this.addToLeftBlockedMemory(rc.blocking.push(leftContext));\n                                        this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                        leftContext = null;\n                                        break;\n                                    }\n                                }\n                                if (leftContext) {\n                                    this.__addToLeftMemory(leftContext);\n                                }\n                            }\n                        }\n                    }\n\n                    if (leftTuplesLength) {\n                        //check currently left tuples in memory\n                        node = {next: leftTuples.head};\n                        while ((node = node.next)) {\n                            leftContext = node.data;\n                            if (thisConstraint.isMatch(leftContext, context)) {\n                                this.__propagate(\"assert\", this.__cloneContext(leftContext));\n                                this.removeFromLeftMemory(leftContext);\n                                this.addToLeftBlockedMemory(context.blocking.push(leftContext));\n                                leftContext.blocker = context;\n                            }\n                        }\n                    }\n\n\n                }\n            } else {\n                throw new Error();\n            }\n\n\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/existsFromNode.js":"var FromNotNode = require(\"./fromNotNode\"),\n    extd = require(\"../extended\"),\n    Context = require(\"../context\"),\n    isDefined = extd.isDefined,\n    isArray = extd.isArray;\n\nFromNotNode.extend({\n    instance: {\n\n        nodeType: \"ExistsFromNode\",\n\n        retractLeft: function (context) {\n            var ctx = this.removeFromLeftMemory(context);\n            if (ctx) {\n                ctx = ctx.data;\n                if (ctx.blocked) {\n                    this.__propagate(\"retract\", ctx.clone());\n                }\n            }\n        },\n\n        __modify: function (context, leftContext) {\n            var leftContextBlocked = leftContext.blocked;\n            var fh = context.factHash, o = this.from(fh);\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        break;\n                    }\n                }\n            } else if (isDefined(o)) {\n                context.blocked = this.__isMatch(context, o, true);\n            }\n            var newContextBlocked = context.blocked;\n            if (newContextBlocked) {\n                if (leftContextBlocked) {\n                    this.__propagate(\"modify\", context.clone());\n                } else {\n                    this.__propagate(\"assert\", context.clone());\n                }\n            } else if (leftContextBlocked) {\n                this.__propagate(\"retract\", context.clone());\n            }\n\n        },\n\n        __findMatches: function (context) {\n            var fh = context.factHash, o = this.from(fh), isMatch = false;\n            if (isArray(o)) {\n                for (var i = 0, l = o.length; i < l; i++) {\n                    if (this.__isMatch(context, o[i], true)) {\n                        context.blocked = true;\n                        this.__propagate(\"assert\", context.clone());\n                        return;\n                    }\n                }\n            } else if (isDefined(o) && (this.__isMatch(context, o, true))) {\n                context.blocked = true;\n                this.__propagate(\"assert\", context.clone());\n            }\n            return isMatch;\n        },\n\n        __isMatch: function (oc, o, add) {\n            var ret = false;\n            if (this.type(o)) {\n                var createdFact = this.workingMemory.getFactHandle(o);\n                var context = new Context(createdFact, null, null)\n                    .mergeMatch(oc.match)\n                    .set(this.alias, o);\n                if (add) {\n                    var fm = this.fromMemory[createdFact.id];\n                    if (!fm) {\n                        fm = this.fromMemory[createdFact.id] = {};\n                    }\n                    fm[oc.hashCode] = oc;\n                }\n                var fh = context.factHash;\n                var eqConstraints = this.__equalityConstraints;\n                for (var i = 0, l = eqConstraints.length; i < l; i++) {\n                    if (eqConstraints[i](fh)) {\n                        ret = true;\n                    } else {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            return ret;\n        },\n\n        assertLeft: function (context) {\n            this.__addToLeftMemory(context);\n            this.__findMatches(context);\n        }\n\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/leftAdapterNode.js":"var Node = require(\"./adapterNode\");\n\nNode.extend({\n    instance: {\n        propagateAssert: function (context) {\n            this.__propagate(\"assertLeft\", context);\n        },\n\n        propagateRetract: function (context) {\n            this.__propagate(\"retractLeft\", context);\n        },\n\n        propagateResolve: function (context) {\n            this.__propagate(\"retractResolve\", context);\n        },\n\n        propagateModify: function (context) {\n            this.__propagate(\"modifyLeft\", context);\n        },\n\n        retractResolve: function (match) {\n            this.__propagate(\"retractResolve\", match);\n        },\n\n        dispose: function (context) {\n            this.propagateDispose(context);\n        },\n\n        toString: function () {\n            return \"LeftAdapterNode \" + this.__count;\n        }\n    }\n\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/adapterNode.js":"var Node = require(\"./node\"),\n    intersection = require(\"../extended\").intersection;\n\nNode.extend({\n    instance: {\n\n        __propagatePaths: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length, entry, outNode, paths, continuingPaths;\n            while (--i > -1) {\n                entry = entrySet[i];\n                outNode = entry.key;\n                paths = entry.value;\n                if ((continuingPaths = intersection(paths, context.paths)).length) {\n                    outNode[method](context.clone(null, continuingPaths, null));\n                }\n            }\n        },\n\n        __propagateNoPaths: function (method, context) {\n            var entrySet = this.__entrySet, i = entrySet.length;\n            while (--i > -1) {\n                entrySet[i].key[method](context);\n            }\n        },\n\n        __propagate: function (method, context) {\n            if (context.paths) {\n                this.__propagatePaths(method, context);\n            } else {\n                this.__propagateNoPaths(method, context);\n            }\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/rightAdapterNode.js":"var Node = require(\"./adapterNode\");\n\nNode.extend({\n    instance: {\n\n        retractResolve: function (match) {\n            this.__propagate(\"retractResolve\", match);\n        },\n\n        dispose: function (context) {\n            this.propagateDispose(context);\n        },\n\n        propagateAssert: function (context) {\n            this.__propagate(\"assertRight\", context);\n        },\n\n        propagateRetract: function (context) {\n            this.__propagate(\"retractRight\", context);\n        },\n\n        propagateResolve: function (context) {\n            this.__propagate(\"retractResolve\", context);\n        },\n\n        propagateModify: function (context) {\n            this.__propagate(\"modifyRight\", context);\n        },\n\n        toString: function () {\n            return \"RightAdapterNode \" + this.__count;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/typeNode.js":"var AlphaNode = require(\"./alphaNode\"),\n    Context = require(\"../context\");\n\nAlphaNode.extend({\n    instance: {\n\n        assert: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"assert\", fact);\n            }\n        },\n\n        modify: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"modify\", fact);\n            }\n        },\n\n        retract: function (fact) {\n            if (this.constraintAssert(fact.object)) {\n                this.__propagate(\"retract\", fact);\n            }\n        },\n\n        toString: function () {\n            return \"TypeNode\" + this.__count;\n        },\n\n        dispose: function () {\n            var es = this.__entrySet, i = es.length - 1;\n            for (; i >= 0; i--) {\n                var e = es[i], outNode = e.key, paths = e.value;\n                outNode.dispose({paths: paths});\n            }\n        },\n\n        __propagate: function (method, fact) {\n            var es = this.__entrySet, i = -1, l = es.length;\n            while (++i < l) {\n                var e = es[i], outNode = e.key, paths = e.value;\n                outNode[method](new Context(fact, paths));\n            }\n        }\n    }\n}).as(module);\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/terminalNode.js":"var Node = require(\"./node\"),\n    extd = require(\"../extended\"),\n    bind = extd.bind;\n\nNode.extend({\n    instance: {\n        constructor: function (bucket, index, rule, agenda) {\n            this._super([]);\n            this.resolve = bind(this, this.resolve);\n            this.rule = rule;\n            this.index = index;\n            this.name = this.rule.name;\n            this.agenda = agenda;\n            this.bucket = bucket;\n            agenda.register(this);\n        },\n\n        __assertModify: function (context) {\n            var match = context.match;\n            if (match.isMatch) {\n                var rule = this.rule, bucket = this.bucket;\n                this.agenda.insert(this, {\n                    rule: rule,\n                    hashCode: context.hashCode,\n                    index: this.index,\n                    name: rule.name,\n                    recency: bucket.recency++,\n                    match: match,\n                    counter: bucket.counter\n                });\n            }\n        },\n\n        assert: function (context) {\n            this.__assertModify(context);\n        },\n\n        modify: function (context) {\n            this.agenda.retract(this, context);\n            this.__assertModify(context);\n        },\n\n        retract: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        retractRight: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        retractLeft: function (context) {\n            this.agenda.retract(this, context);\n        },\n\n        assertLeft: function (context) {\n            this.__assertModify(context);\n        },\n\n        assertRight: function (context) {\n            this.__assertModify(context);\n        },\n\n        toString: function () {\n            return \"TerminalNode \" + this.rule.name;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nodes/propertyNode.js":"var AlphaNode = require(\"./alphaNode\"),\n    Context = require(\"../context\"),\n    extd = require(\"../extended\");\n\nAlphaNode.extend({\n    instance: {\n\n        constructor: function () {\n            this._super(arguments);\n            this.alias = this.constraint.get(\"alias\");\n            this.varLength = (this.variables = extd(this.constraint.get(\"variables\")).toArray().value()).length;\n        },\n\n        assert: function (context) {\n            var c = new Context(context.fact, context.paths);\n            var variables = this.variables, o = context.fact.object, item;\n            c.set(this.alias, o);\n            for (var i = 0, l = this.varLength; i < l; i++) {\n                item = variables[i];\n                c.set(item[1], o[item[0]]);\n            }\n\n            this.__propagate(\"assert\", c);\n\n        },\n\n        retract: function (context) {\n            this.__propagate(\"retract\", new Context(context.fact, context.paths));\n        },\n\n        modify: function (context) {\n            var c = new Context(context.fact, context.paths);\n            var variables = this.variables, o = context.fact.object, item;\n            c.set(this.alias, o);\n            for (var i = 0, l = this.varLength; i < l; i++) {\n                item = variables[i];\n                c.set(item[1], o[item[0]]);\n            }\n            this.__propagate(\"modify\", c);\n        },\n\n\n        toString: function () {\n            return \"PropertyNode\" + this.__count;\n        }\n    }\n}).as(module);\n\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/workingMemory.js":"\"use strict\";\nvar declare = require(\"declare.js\"),\n    LinkedList = require(\"./linkedList\"),\n    InitialFact = require(\"./pattern\").InitialFact,\n    id = 0;\n\nvar Fact = declare({\n\n    instance: {\n        constructor: function (obj) {\n            this.object = obj;\n            this.recency = 0;\n            this.id = id++;\n        },\n\n        equals: function (fact) {\n            return fact === this.object;\n        },\n\n        hashCode: function () {\n            return this.id;\n        }\n    }\n\n});\n\ndeclare({\n\n    instance: {\n\n        constructor: function () {\n            this.recency = 0;\n            this.facts = new LinkedList();\n        },\n\n        dispose: function () {\n            this.facts.clear();\n        },\n\n        getFacts: function () {\n            var head = {next: this.facts.head}, ret = [], i = 0, val;\n            while ((head = head.next)) {\n                if (!((val = head.data.object)  instanceof InitialFact)) {\n                    ret[i++] = val;\n                }\n            }\n            return ret;\n        },\n\n        getFactsByType: function (Type) {\n            var head = {next: this.facts.head}, ret = [], i = 0;\n            while ((head = head.next)) {\n                var val = head.data.object;\n                if (!(val  instanceof InitialFact) && (val instanceof Type || val.constructor === Type)) {\n                    ret[i++] = val;\n                }\n            }\n            return ret;\n        },\n\n        getFactHandle: function (o) {\n            var head = {next: this.facts.head}, ret;\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(o)) {\n                    return existingFact;\n                }\n            }\n            if (!ret) {\n                ret = new Fact(o);\n                ret.recency = this.recency++;\n                //this.facts.push(ret);\n            }\n            return ret;\n        },\n\n        modifyFact: function (fact) {\n            var head = {next: this.facts.head};\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(fact)) {\n                    existingFact.recency = this.recency++;\n                    return existingFact;\n                }\n            }\n            //if we made it here we did not find the fact\n            throw new Error(\"the fact to modify does not exist\");\n        },\n\n        assertFact: function (fact) {\n            var ret = new Fact(fact);\n            ret.recency = this.recency++;\n            this.facts.push(ret);\n            return ret;\n        },\n\n        retractFact: function (fact) {\n            var facts = this.facts, head = {next: facts.head};\n            while ((head = head.next)) {\n                var existingFact = head.data;\n                if (existingFact.equals(fact)) {\n                    facts.remove(head);\n                    return existingFact;\n                }\n            }\n            //if we made it here we did not find the fact\n            throw new Error(\"the fact to remove does not exist\");\n\n\n        }\n    }\n\n}).as(exports, \"WorkingMemory\");\n\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/executionStrategy.js":"var extd = require(\"./extended\"),\n    Promise = extd.Promise,\n    nextTick = require(\"./nextTick\"),\n    isPromiseLike = extd.isPromiseLike;\n\nPromise.extend({\n    instance: {\n\n        looping: false,\n\n        constructor: function (flow, matchUntilHalt) {\n            this._super([]);\n            this.flow = flow;\n            this.agenda = flow.agenda;\n            this.rootNode = flow.rootNode;\n            this.matchUntilHalt = !!(matchUntilHalt);\n            extd.bindAll(this, [\"onAlter\", \"callNext\"]);\n        },\n\n        halt: function () {\n            this.__halted = true;\n            if (!this.looping) {\n                this.callback();\n            }\n        },\n\n        onAlter: function () {\n            this.flowAltered = true;\n            if (!this.looping && this.matchUntilHalt && !this.__halted) {\n                this.callNext();\n            }\n        },\n\n        setup: function () {\n            var flow = this.flow;\n            this.rootNode.resetCounter();\n            flow.on(\"assert\", this.onAlter);\n            flow.on(\"modify\", this.onAlter);\n            flow.on(\"retract\", this.onAlter);\n        },\n\n        tearDown: function () {\n            var flow = this.flow;\n            flow.removeListener(\"assert\", this.onAlter);\n            flow.removeListener(\"modify\", this.onAlter);\n            flow.removeListener(\"retract\", this.onAlter);\n        },\n\n        __handleAsyncNext: function (next) {\n            var self = this, agenda = self.agenda;\n            return next.then(function () {\n                self.looping = false;\n                if (!agenda.isEmpty()) {\n                    if (self.flowAltered) {\n                        self.rootNode.incrementCounter();\n                        self.flowAltered = false;\n                    }\n                    if (!self.__halted) {\n                        self.callNext();\n                    } else {\n                        self.callback();\n                    }\n                } else if (!self.matchUntilHalt || self.__halted) {\n                    self.callback();\n                }\n                self = null;\n            }, this.errback);\n        },\n\n        __handleSyncNext: function (next) {\n            this.looping = false;\n            if (!this.agenda.isEmpty()) {\n                if (this.flowAltered) {\n                    this.rootNode.incrementCounter();\n                    this.flowAltered = false;\n                }\n            }\n            if (next && !this.__halted) {\n                nextTick(this.callNext);\n            } else if (!this.matchUntilHalt || this.__halted) {\n                this.callback();\n            }\n            return next;\n        },\n\n        callback: function () {\n            this.tearDown();\n            this._super(arguments);\n        },\n\n\n        callNext: function () {\n            this.looping = true;\n            var next = this.agenda.fireNext();\n            return isPromiseLike(next) ? this.__handleAsyncNext(next) : this.__handleSyncNext(next);\n        },\n\n        execute: function () {\n            this.setup();\n            this.callNext();\n            return this;\n        }\n    }\n}).as(module);","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/nextTick.js":"/*global setImmediate, window, MessageChannel*/\nvar extd = require(\"./extended\");\nvar nextTick;\nif (typeof setImmediate === \"function\") {\n    // In IE10, or use https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        nextTick = extd.bind(window, setImmediate);\n    } else {\n        nextTick = setImmediate;\n    }\n} else if (typeof process !== \"undefined\") {\n    // node\n    nextTick = process.nextTick;\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    // linked list of tasks (single, with head node)\n    var head = {}, tail = head;\n    channel.port1.onmessage = function () {\n        head = head.next;\n        var task = head.task;\n        delete head.task;\n        task();\n    };\n    nextTick = function (task) {\n        tail = tail.next = {task: task};\n        channel.port2.postMessage(0);\n    };\n} else {\n    // old browsers\n    nextTick = function (task) {\n        setTimeout(task, 0);\n    };\n}\n\nmodule.exports = nextTick;","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/lib/agenda.js":"\"use strict\";\nvar extd = require(\"./extended\"),\n    declare = extd.declare,\n    AVLTree = extd.AVLTree,\n    LinkedList = extd.LinkedList,\n    isPromise = extd.isPromiseLike,\n    EventEmitter = require(\"events\").EventEmitter;\n\n\nvar FactHash = declare({\n    instance: {\n        constructor: function () {\n            this.memory = {};\n            this.memoryValues = new LinkedList();\n        },\n\n        clear: function () {\n            this.memoryValues.clear();\n            this.memory = {};\n        },\n\n\n        remove: function (v) {\n            var hashCode = v.hashCode,\n                memory = this.memory,\n                ret = memory[hashCode];\n            if (ret) {\n                this.memoryValues.remove(ret);\n                delete memory[hashCode];\n            }\n            return ret;\n        },\n\n        insert: function (insert) {\n            var hashCode = insert.hashCode;\n            if (hashCode in this.memory) {\n                throw new Error(\"Activation already in agenda \" + insert.rule.name + \" agenda\");\n            }\n            this.memoryValues.push((this.memory[hashCode] = insert));\n        }\n    }\n});\n\n\nvar DEFAULT_AGENDA_GROUP = \"main\";\nmodule.exports = declare(EventEmitter, {\n\n    instance: {\n        constructor: function (flow, conflictResolution) {\n            this.agendaGroups = {};\n            this.agendaGroupStack = [DEFAULT_AGENDA_GROUP];\n            this.rules = {};\n            this.flow = flow;\n            this.comparator = conflictResolution;\n            this.setFocus(DEFAULT_AGENDA_GROUP).addAgendaGroup(DEFAULT_AGENDA_GROUP);\n        },\n\n        addAgendaGroup: function (groupName) {\n            if (!extd.has(this.agendaGroups, groupName)) {\n                this.agendaGroups[groupName] = new AVLTree({compare: this.comparator});\n            }\n        },\n\n        getAgendaGroup: function (groupName) {\n            return this.agendaGroups[groupName || DEFAULT_AGENDA_GROUP];\n        },\n\n        setFocus: function (agendaGroup) {\n            if (agendaGroup !== this.getFocused() && this.agendaGroups[agendaGroup]) {\n                this.agendaGroupStack.push(agendaGroup);\n                this.emit(\"focused\", agendaGroup);\n            }\n            return this;\n        },\n\n        getFocused: function () {\n            var ags = this.agendaGroupStack;\n            return ags[ags.length - 1];\n        },\n\n        getFocusedAgenda: function () {\n            return this.agendaGroups[this.getFocused()];\n        },\n\n        register: function (node) {\n            var agendaGroup = node.rule.agendaGroup;\n            this.rules[node.name] = {tree: new AVLTree({compare: this.comparator}), factTable: new FactHash()};\n            if (agendaGroup) {\n                this.addAgendaGroup(agendaGroup);\n            }\n        },\n\n        isEmpty: function () {\n            var agendaGroupStack = this.agendaGroupStack, changed = false;\n            while (this.getFocusedAgenda().isEmpty() && this.getFocused() !== DEFAULT_AGENDA_GROUP) {\n                agendaGroupStack.pop();\n                changed = true;\n            }\n            if (changed) {\n                this.emit(\"focused\", this.getFocused());\n            }\n            return this.getFocusedAgenda().isEmpty();\n        },\n\n        fireNext: function () {\n            var agendaGroupStack = this.agendaGroupStack, ret = false;\n            while (this.getFocusedAgenda().isEmpty() && this.getFocused() !== DEFAULT_AGENDA_GROUP) {\n                agendaGroupStack.pop();\n            }\n            if (!this.getFocusedAgenda().isEmpty()) {\n                var activation = this.pop();\n                this.emit(\"fire\", activation.rule.name, activation.match.factHash);\n                var fired = activation.rule.fire(this.flow, activation.match);\n                if (isPromise(fired)) {\n                    ret = fired.then(function () {\n                        //return true if an activation fired\n                        return true;\n                    });\n                } else {\n                    ret = true;\n                }\n            }\n            //return false if activation not fired\n            return ret;\n        },\n\n        pop: function () {\n            var tree = this.getFocusedAgenda(), root = tree.__root;\n            while (root.right) {\n                root = root.right;\n            }\n            var v = root.data;\n            tree.remove(v);\n            var rule = this.rules[v.name];\n            rule.tree.remove(v);\n            rule.factTable.remove(v);\n            return v;\n        },\n\n        peek: function () {\n            var tree = this.getFocusedAgenda(), root = tree.__root;\n            while (root.right) {\n                root = root.right;\n            }\n            return root.data;\n        },\n\n        modify: function (node, context) {\n            this.retract(node, context);\n            this.insert(node, context);\n        },\n\n        retract: function (node, retract) {\n            var rule = this.rules[node.name];\n            retract.rule = node;\n            var activation = rule.factTable.remove(retract);\n            if (activation) {\n                this.getAgendaGroup(node.rule.agendaGroup).remove(activation);\n                rule.tree.remove(activation);\n            }\n        },\n\n        insert: function (node, insert) {\n            var rule = this.rules[node.name], nodeRule = node.rule, agendaGroup = nodeRule.agendaGroup;\n            rule.tree.insert(insert);\n            this.getAgendaGroup(agendaGroup).insert(insert);\n            if (nodeRule.autoFocus) {\n                this.setFocus(agendaGroup);\n            }\n\n            rule.factTable.insert(insert);\n        },\n\n        dispose: function () {\n            for (var i in this.agendaGroups) {\n                this.agendaGroups[i].clear();\n            }\n            var rules = this.rules;\n            for (i in rules) {\n                if (i in rules) {\n                    rules[i].tree.clear();\n                    rules[i].factTable.clear();\n\n                }\n            }\n            this.rules = {};\n        }\n    }\n\n});","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/Gruntfile.js":"/*global module:false*/\nmodule.exports = function (grunt) {\n    // Project configuration.\n    var path = require(\"path\"),\n        child = require(\"child_process\");\n    grunt.initConfig({\n        pkg: grunt.file.readJSON('package.json'),\n\n        exec: {\n            removeDocs: \"rm -rf docs/* && mkdir -p ./docs/examples/browser && cp -r ./examples/browser ./docs/examples && cp ./nools.min.js ./docs/nools.js\",\n            createDocs: 'node_modules/coddoc/bin/coddoc -f multi-html -d ./lib --dir ./docs'\n        },\n\n        jshint: {\n            src: [\"./index.js\", \"lib/**/*.js\", \"Gruntfile.js\"],\n            options: {\n                jshintrc: '.jshintrc',\n                ignores: [\"./lib/parser/constraint/parser.js\"]\n            }\n        },\n        it: {\n            all: {\n                src: 'test/**/*.test.js',\n                options: {\n                    timeout: 3000, // not fully supported yet\n                    reporter: 'dotmatrix'\n                }\n            }\n        },\n        watch: {\n            files: '<config:lint.files>',\n            tasks: 'lint it'\n        },\n        uglify: {\n            options: {\n                banner: '/*! <%= pkg.name %> - v<%= pkg.version %> - ' +\n                    '<%= grunt.template.today(\"yyyy-mm-dd\") %>\\n' +\n                    '<%= pkg.homepage ? \"* \" + pkg.homepage + \"\\\\n\" : \"\" %>' +\n                    '* Copyright (c) <%= grunt.template.today(\"yyyy\") %> <%= pkg.author %>;' +\n                    ' Licensed <%= pkg.license %> */\\n',\n                report: 'min'\n            },\n            min: {\n                files: {\n                    '<%= pkg.name %>.min.js': ['nools.js']\n                }\n            }\n        },\n\n        browserify: {\n            'nools': {\n                src: ['./browser/nools.js'],\n                dest: './nools.js'\n            }\n        },\n\n        benchmark: {\n            manners: {\n                files: \"./benchmark/manners/benchmark.js\"\n            },\n            sendMoreMoney: {\n                files: \"./benchmark/sendMoreMoney/benchmark.js\"\n            },\n            simple: {\n                files: \"./benchmark/simple/benchmark.js\"\n            },\n            waltzDb: {\n                files: \"./benchmark/waltzDb/benchmark.js\"\n            }\n        }\n    });\n\n    // Default task.\n    grunt.registerTask('default', ['jshint', \"compile-tests\", 'it', 'browserify:nools', 'uglify:min', 'exec']);\n    grunt.loadNpmTasks('grunt-it');\n    grunt.loadNpmTasks('grunt-contrib-jshint');\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    grunt.loadNpmTasks('grunt-browserify');\n    grunt.loadNpmTasks('grunt-exec');\n\n    grunt.registerTask(\"compile-tests\", \"compiles all nools files\", function () {\n        var files = grunt.file.expand(\"./test/rules/*.nools\"), count = files.length, done = this.async();\n\n        function counter(err) {\n            if (err) {\n                done(err);\n            } else {\n                count--;\n                if (!count) {\n                    done();\n                }\n            }\n        }\n\n        files.forEach(function (file) {\n            var base = path.basename(file, \".nools\"),\n                out = path.resolve(path.dirname(file), base + \"-compiled.js\");\n            child.exec(path.resolve(__dirname, \"./bin/nools\") + \" compile \" + file + \" -l ../../ -n \" + base + \"-compiled\", function (err, output) {\n                if (!err) {\n                    grunt.file.write(out, output.toString());\n                }\n                counter(err);\n            });\n        });\n    });\n\n    grunt.registerTask(\"benchmarks\", function () {\n\n    });\n\n    grunt.registerMultiTask('benchmark', 'execute it unit tests in a spawned process', function () {\n        var done = this.async();\n        require(this.data.files).classic(function (err) {\n            if (err) {\n                done(false);\n            } else {\n                done();\n            }\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-nools/node_modules/nools/browser/nools.js":"(function () {\n    \"use strict\";\n    var nools = require(\"../\");\n\n    if (typeof Object.getPrototypeOf !== \"function\") {\n        Object.getPrototypeOf = \"\".__proto__ === String.prototype\n            ? function (object) {\n            return object.__proto__;\n        }\n            : function (object) {\n            // May break if the constructor has been tampered with\n            return object.constructor.prototype;\n        };\n    }\n\n    if (\"function\" === typeof this.define && this.define.amd) {\n        define([], function () {\n            return nools;\n        });\n    } else {\n        this.nools = nools;\n    }\n}).call(typeof window !== \"undefined\" ? window : this);\n"}